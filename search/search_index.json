{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"community","text":"<p>The <code>community</code> repository provides a comprehensive, community-supported configuration for the Talon voice control system. It includes a wide array of features, from basic text manipulation and keyboard shortcuts to application-specific commands and advanced code editing tools.</p> <p>The repository leverages several key dependencies:</p> <ul> <li>Talon: The core voice control system which provides the framework to execute voice commands, manage contexts, and interact with the operating system. All the files in this repository extend and customize Talon's functionality.</li> <li>Python: Used extensively for implementing core logic, actions, and UI elements for Talon extensions and language support.</li> <li>Skia: Used by Talon, particularly for drawing custom UIs such as the mode indicator and mouse grid.</li> <li>imgui:  A cross-platform UI library that is used by Talon to create custom GUIs, including help windows and command pickers.</li> <li>cubeb: A cross-platform audio API that provides support for microphone selection in Talon.</li> <li>pre-commit: A tool that manages and runs code linters and formatters.</li> <li>pytest: A Python testing framework that provides the ability to test Talon functionality without launching the full application.</li> <li>Various external libraries and command line utilities: Some features rely on external tools or APIs to operate (e.g., <code>i3-msg</code> for i3 window management, <code>wslpath</code> for path translation in WSL, and <code>curl</code> for remote procedure calls).</li> </ul> <p>Here's a breakdown of the most important and interesting subdirectories and files:</p> <ul> <li> <p>The <code>core</code> directory contains the fundamental functionality of the Talon community configuration. It manages aspects of Talon such as text manipulation, code snippets, vocabulary, key bindings, application switching, and many other core systems.</p> <ul> <li><code>core/abbreviate</code> defines a system for expanding abbreviations based on a dictionary and a CSV file.</li> <li><code>core/app_switcher</code> provides functionality to switch between and launch applications using voice commands, using platform-specific CSV files to manage application names and overrides.</li> <li><code>core/edit</code> implements core editing functionality for Talon, including actions for navigation, selection, and text manipulation. It includes platform-specific files and advanced editing capabilities.</li> <li><code>core/file_extension</code> enables users to speak file extensions using a Talon list populated by a CSV file.</li> <li><code>core/formatters</code> defines text formatters, used to format text based on surrounding context.</li> <li><code>core/help</code> provides a help system for Talon, including an ImGui window, and support for showing the current Talon scope.</li> <li><code>core/homophones</code> implements a GUI for selecting homophones using a CSV file and actions.</li> <li><code>core/keys</code> provides configuration files for mapping spoken words to keyboard keys, including platform-specific definitions and a phonetic alphabet.</li> <li><code>core/menu_choose</code> allows for selecting items from menus using voice commands.</li> <li><code>core/modes</code> defines and manages different modes of operation, such as \"sleep\", \"command\", \"dictation\", and various language modes, including platform specific handling for Dragon and Wav2Letter.</li> <li><code>core/mouse_grid</code> contains the code for the mouse grid system.</li> <li><code>core/navigation</code> provides context-aware navigation with different keybindings for browser, macOS, and other contexts.</li> <li><code>core/numbers</code> contains logic for parsing and representing numbers using voice commands, including prefixed and unprefixed numbers, and ordinal numbers.</li> <li><code>core/screens</code> manages and displays information about multiple screens.</li> <li><code>core/snippets</code> manages code snippets, including logic for parsing, inserting, and managing language-aware snippets stored in the <code>core/snippets/snippets</code> subdirectory.</li> <li><code>core/text</code> defines how Talon handles text input and formatting, including lists of words, phrases, and core logic for text manipulation and dictation.</li> <li><code>core/vocabulary</code> manages custom vocabulary and word replacements, using a CSV file and a Talon list for user customizations.</li> <li><code>core/websites_and_search_engines</code> allows users to quickly navigate to websites and perform searches using voice commands.</li> <li><code>core/windows_and_tabs</code> manages windows and tabs across different operating systems, including support for snapping windows to different screen positions.</li> </ul> </li> <li> <p>The <code>apps</code> directory contains configurations for a wide variety of specific applications, including terminals, IDEs, browsers, and messaging apps. It often uses a combination of <code>.talon</code> files for voice commands and <code>.py</code> files for implementing the underlying logic and actions. The files are often platform-specific.</p> </li> <li>Many of the subdirectories provide their own <code>README.md</code> file describing how they work.</li> <li> <p><code>apps/vscode</code> provides particularly comprehensive support for VS Code using a file-based RPC system. Its subdirectory, <code>apps/vscode/command_client</code> provides the details of that RPC system, and <code>apps/vscode/command_client/rpc_client</code> provides the core implementation for the file based communication.</p> </li> <li> <p>The <code>plugin</code> directory contains a variety of extensions to Talon, ranging from basic text manipulation and command repetition to complex desktop management and custom UI elements.</p> <ul> <li><code>plugin/macro</code> implements a macro recording and playback system.</li> <li><code>plugin/desktops</code> enables cross-platform virtual desktop management.</li> <li><code>plugin/mouse</code> provides comprehensive mouse control.</li> <li><code>plugin/talon_draft_window</code> implements a dedicated text editing window using word labels for voice-driven manipulation.</li> <li><code>plugin/repeater</code> enables repeating commands and phrases.</li> <li><code>plugin/datetimeinsert</code> provides a plugin for inserting date and time formats.</li> <li><code>plugin/cancel</code> provides a way to cancel a spoken command using a specific phrase.</li> <li><code>plugin/subtitles</code> displays subtitles of speech input on the screen.</li> <li><code>plugin/are_you_sure</code> implements a confirmation dialog before executing potentially destructive actions.</li> <li><code>plugin/talon_helpers</code> provides helper utilities for debugging and working with Talon, and an action to create new app contexts.</li> <li><code>plugin/gamepad</code> provides gamepad support for Talon.</li> <li><code>plugin/text_navigation</code> implements advanced text navigation.</li> <li><code>plugin/then</code> provides a \"then\" command to chain otherwise ambiguous commands.</li> <li><code>plugin/microphone_selection</code> provides a microphone selection UI.</li> <li><code>plugin/draft_editor</code> enables using a text editor as a draft editor.</li> <li><code>plugin/symbols</code> defines commands for inserting and wrapping text with symbols.</li> <li><code>plugin/media</code> implements basic media controls.</li> <li><code>plugin/command_history</code> adds command history functionality to Talon.</li> <li><code>plugin/screenshot</code> provides screenshot functionality.</li> <li><code>plugin/mode_indicator</code> displays a graphical mode indicator.</li> <li><code>plugin/listening_timeout</code> implements a timeout for speech recognition.</li> </ul> </li> <li> <p>The <code>tags</code> directory contains a collection of subdirectories, each representing a different tag used to group related commands and functionality in Talon. These subdirectories provide reusable components for adding common features:</p> <ul> <li><code>tags/messaging</code> implements commands for controlling multi-channel messaging applications.</li> <li><code>tags/file_manager</code> provides a way to interact with the file system.</li> <li><code>tags/browser</code> defines common browser actions.</li> <li><code>tags/command_search</code> allows searching for and executing other Talon commands by name or description.</li> <li><code>tags/chapters</code> provides a way to navigate chapters in a reader application.</li> <li><code>tags/pages</code> provides commands for page navigation.</li> <li><code>tags/splits</code> manages window splits.</li> <li><code>tags/find</code> implements a simple find functionality.</li> <li><code>tags/line_commands</code> provides a set of line navigation and manipulation commands.</li> <li><code>tags/emoji</code> contains functionality for inserting emoji, emoticons, and kaomoji.</li> <li><code>tags/find_and_replace</code> provides advanced find and replace functionality.</li> <li><code>tags/debugger</code> provides voice control for debuggers.</li> <li><code>tags/multiple_cursors</code> adds support for multiple cursors.</li> <li><code>tags/terminal</code> provides support for interacting with terminal applications.</li> <li><code>tags/address</code> provides a way to navigate to locations using an address such as a file path.</li> </ul> </li> <li> <p>The <code>lang</code> directory contains support for a variety of programming and markup languages, including Python, Rust, Lua, Terraform, R, SQL, Scala, Protocol Buffer, PHP, C#, CSS, HTML, Java, C, Batch, Ruby, Elixir, Kotlin, Typescript, Talon, Javascript, Vimscript, and Markdown. Each language subdirectory typically includes a <code>.py</code> file defining core logic, lists, and actions, and a <code>.talon</code> file for voice commands. The <code>lang/tags</code> directory provides a reusable set of rules that can be included in other language modules.</p> </li> <li> <p>The <code>test</code> directory provides tests for the community repository, with stub implementations of the Talon APIs for use in automated tests.</p> <ul> <li>The <code>test/stubs</code> directory provides a stub implementation of the Talon API, allowing for isolated and faster testing, using python files in the <code>test/stubs/talon</code> subdirectory.</li> </ul> </li> <li> <p>The <code>migration_helpers</code> directory provides functionality to convert CSV files into <code>.talon-list</code> files, a more robust method of managing Talon lists.</p> </li> <li> <p>The <code>core/snippets/snippets</code> directory stores <code>.snippet</code> files that define code snippets, and the core logic for handling snippets is located in <code>core/snippets</code>.</p> </li> <li> <p>The <code>core/vocabulary</code> directory defines how custom vocabulary is loaded, modified, and used by Talon.</p> </li> <li> <p>The <code>core/keys</code> directory contains configuration files for mapping spoken words to keyboard keys, with platform specific lists for special and modifier keys.</p> </li> <li> <p>The <code>core/websites_and_search_engines</code> directory defines lists of websites and search engines and allows for using them through voice commands.</p> </li> <li> <p>The <code>core/edit_text_file</code> directory allows opening commonly edited text files using a preferred text editor.</p> </li> <li> <p>The <code>core/modes</code> directory defines and manages different modes of operation for Talon.</p> </li> <li> <p>The <code>core/formatters</code> directory provides functionality for formatting text within Talon.</p> </li> <li> <p>The <code>core/navigation</code> directory defines actions for navigating forward and backward, using different keybindings based on the context.</p> </li> <li> <p>The <code>core/numbers</code> directory provides files for parsing and representing numbers using voice commands, including prefixed and unprefixed numbers and ordinal numbers.</p> </li> <li> <p>The <code>core/help</code> directory provides a help system for Talon, using ImGUI.</p> </li> <li> <p>The <code>core/menu_choose</code> directory implements functionality for selecting items from menus using voice commands.</p> </li> <li> <p>The <code>core/homophones</code> directory implements a GUI for selecting homophones.</p> </li> <li> <p>The <code>core/windows_and_tabs</code> directory manages windows and tabs across different operating systems.</p> </li> <li> <p>The <code>core/mouse_grid</code> directory implements a system for moving the mouse using a grid.</p> </li> <li> <p>The <code>core/file_extension</code> directory implements commands for inserting file extensions.</p> </li> <li> <p>The <code>core/screens</code> directory provides functionality to manage and show information about multiple screens.</p> </li> <li> <p>The <code>_github</code> directory contains configuration files for GitHub features, such as workflows (in the <code>_github/workflows</code> subdirectory) and Dependabot.</p> </li> </ul> <p>In summary, this repository is a complex and comprehensive configuration for the Talon voice control system. It provides a large number of features for text editing, code writing, application control, and system management, and all of these pieces work together to provide a cohesive and highly customizable experience.</p>"},{"location":"_github/","title":".github","text":"<p>The <code>community/.github</code> directory contains configuration files for GitHub features.</p> <p>The workflows subdirectory contains configuration files for GitHub Actions workflows. These workflows automate tasks related to the repository, such as continuous integration (CI). The <code>ci.yml</code> file defines a CI workflow that is triggered on every push to the <code>main</code> branch and on every pull request targeting the <code>main</code> branch. The workflow checks out the repository code, sets up Python, installs dependencies, and runs tests. This workflow helps to prevent bugs from being introduced into the main branch.</p> <p>The <code>dependabot.yml</code> file configures Dependabot to automatically update GitHub Actions dependencies daily.</p>"},{"location":"_github/workflows/","title":"workflows","text":"<p>The <code>community/.github/workflows</code> directory contains configuration files for GitHub Actions workflows. These workflows automate tasks related to the repository, such as continuous integration (CI).</p> <p>The file <code>ci.yml</code> defines a CI workflow. This workflow is triggered on every push to the <code>main</code> branch and on every pull request targeting the <code>main</code> branch. The workflow's job, <code>test</code>, runs on the latest version of Ubuntu and performs the following steps:</p> <ol> <li>It checks out the repository code using the <code>actions/checkout@v4</code> action.</li> <li>It sets up Python 3.9 using the <code>actions/setup-python@v5</code> action and caches the <code>pip</code> dependencies.</li> <li>It installs the development dependencies from <code>requirements-dev.txt</code>.</li> <li>It runs the <code>pytest</code> test suite.</li> </ol> <p>This workflow ensures that the code in the repository is tested on every push and pull request. This helps to prevent bugs from being introduced into the main branch.</p>"},{"location":"apps/","title":"apps","text":"<p>The <code>community/apps</code> directory contains a collection of subdirectories, each providing specific configurations and commands for various applications. These configurations use a combination of <code>.talon</code> files for voice commands and <code>.py</code> files for implementing the underlying logic and actions.  Most of these applications have their own <code>README.md</code> files which provide a more detailed explanation of how to use that particular application with Talon.</p> <p>Here's a summary of the most important or interesting subdirectories:</p> <ul> <li> <p><code>apple_terminal</code>: This directory provides support for using Talon with the Apple Terminal application. It activates tags for terminal functionality, readline keybindings, and other shell-related features, such as <code>git</code>, <code>anaconda</code>, and <code>kubectl</code>. It also remaps some actions and provides file manager actions based on the terminal's current path.</p> </li> <li> <p><code>outlook</code>: This directory contains Talon scripts for interacting with Outlook, with separate files for the web version (<code>outlook_web.talon</code>) and the Windows desktop application (<code>outlook_win.talon</code>).</p> </li> <li> <p><code>terraform</code>: This directory provides voice commands for the Terraform CLI, with a core <code>terraform.talon</code> file and a <code>terraform.py</code> file that defines the application context and the <code>user.terraform_client</code> tag.</p> </li> <li> <p><code>iterm</code>: This directory contains configuration files for the iTerm2 terminal application on macOS. It defines custom actions and activates tags for enhanced terminal interaction, including <code>terminal</code>, <code>user.generic_unix_shell</code>, <code>user.git</code>, <code>user.kubectl</code>, <code>user.tabs</code>, and <code>user.readline</code> tags.</p> </li> <li> <p><code>slack</code>: This directory provides voice control for the Slack application on macOS, Windows, and Linux. It uses separate <code>.py</code> and <code>.talon</code> files for each operating system to define actions and commands, such as <code>line_insert_down</code>, workspace navigation, channel navigation, and messaging features.</p> </li> <li> <p><code>windbg</code>: This directory provides voice control for the WinDbg debugger. It defines actions for stepping through code, viewing breakpoints, and other debugging tasks using <code>windbg.py</code>, while <code>windbg.talon</code> provides the voice commands that trigger those actions.</p> </li> <li> <p><code>visualstudio</code>: This directory contains files that provide voice control for the Visual Studio IDE on Windows. It defines actions for navigation, code editing, and debugging using the <code>.py</code> files, and voice commands that trigger those actions in the <code>.talon</code> file. It also includes tags to enable additional modules.</p> </li> <li> <p><code>vivaldi</code>: This directory provides support for controlling the Vivaldi browser. It defines actions for toggling panels, closing tabs, and performing browser functions in <code>vivaldi.py</code>, and it defines platform-specific overrides in <code>vivaldi_mac.py</code>. <code>vivaldi.talon</code> binds voice commands to those actions.</p> </li> <li> <p><code>wsl</code>: This directory contains files to enable voice control of the Windows Subsystem for Linux (WSL) within the Windows Terminal. The <code>wsl.py</code> file translates paths between Windows and WSL, and the <code>wsl.talon</code> file provides voice commands that leverage that.</p> </li> <li> <p><code>notepad++</code>: This directory provides Talon bindings for Notepad++ on Windows, including actions for tab navigation, commenting, line manipulation, and find and replace using keyboard shortcuts.</p> </li> <li> <p><code>gnome_terminal</code>: This directory contains configuration for the Gnome Terminal application. It defines actions for tab and window management, and activates the <code>terminal</code>, <code>user.tabs</code>, <code>user.generic_unix_shell</code>, <code>user.git</code>, and <code>user.kubectl</code> tags.</p> </li> <li> <p><code>stata</code>: This directory contains files to add support for the Stata application. It provides actions for defining the language for code contexts and executing Stata commands.</p> </li> <li> <p><code>vscode</code>: This directory provides comprehensive support for VS Code. It includes a <code>command_client</code> subdirectory that provides a mechanism for Talon to communicate with VS Code using a file-based RPC system. It also provides many custom commands and tags via the <code>vscode.talon</code> and <code>vscode.py</code> files.</p> </li> <li>The <code>command_client</code> subdirectory has its own subdirectories, which are also of interest:<ul> <li><code>command_client/rpc_client</code> provides the generic RPC client, which is used to send commands to VS Code and handle responses.</li> </ul> </li> <li> <p><code>foxit_reader</code>: This directory contains files to enable Talon control of the Foxit Reader application, including actions for page navigation, and tab management.</p> </li> <li> <p><code>discord</code>: This directory contains files to control the Discord application. It defines actions in <code>discord.py</code> that are implemented for macOS in <code>discord_mac.py</code> and for Windows and Linux in <code>discord_win.py</code>, and it provides voice commands that map to those actions in <code>discord.talon</code>.</p> </li> <li> <p><code>opera</code>: This directory provides support for controlling the Opera web browser on macOS, Windows and Linux, including tab management and browser actions. It provides actions common to all platforms in <code>opera.py</code>, and platform-specific implementations in <code>opera_mac.py</code> and <code>opera_win_linux.py</code>.</p> </li> <li> <p><code>orion</code>: This directory contains files to support the Orion browser on macOS, including actions for opening new tabs, managing downloads, extensions, and the tab overview.</p> </li> <li> <p><code>nitro_reader</code>: This directory provides support for interacting with Nitro Reader, specifically Nitro Reader 5. The <code>nitro_reader_5.py</code> file provides implementations for opening tabs, and navigating pages, while <code>nitro_reader_5.talon</code> activates the <code>user.pages</code> and <code>user.tabs</code> tags.</p> </li> <li> <p><code>kindle</code>: This directory provides support for controlling the Kindle application. The <code>kindle.py</code> file defines the app, <code>kindle.talon</code> activates the <code>user.pages</code> tag, and <code>kindle_win.py</code> defines the implementation of those page navigation commands.</p> </li> <li> <p><code>mintty</code>: This directory provides configuration for the Mintty terminal application, including file management actions, and remapped editing actions. It activates the <code>terminal</code>, <code>user.generic_unix_shell</code>, <code>user.file_manager</code>, <code>user.git</code>, and <code>user.kubectl</code> tags.</p> </li> <li> <p><code>notepad</code>: This directory contains the Talon files for controlling the Windows Notepad application. The <code>notepad.talon</code> file activates the <code>user.tabs</code> and <code>user.find_and_replace</code> tags, and <code>notepad.py</code> defines the application context and a <code>filename()</code> action.</p> </li> <li> <p><code>adobe</code>: This directory contains configurations for Adobe Acrobat Reader DC. It implements actions for tabbing, zooming, and page navigation in <code>adobe_acrobat_reader_dc_win.py</code>, and the <code>adobe_acrobat_reader_dc.talon</code> file activates the <code>user.tabs</code> and <code>user.pages</code> tags.</p> </li> <li> <p><code>keepassx</code>: This directory provides commands for common KeePassX actions like opening, saving, and locking databases, as well as adding, editing, and deleting entries. The implementation is in <code>keepassx_linux.talon</code>, and is intended for use on Linux.</p> </li> <li> <p><code>kubectl</code>: This directory provides voice commands for interacting with <code>kubectl</code>, the Kubernetes command-line tool. The <code>kubectl.talon</code> file contains the commands, and the <code>kubectl.py</code> file defines the <code>user.kubectl</code> tag, and provides lists that are used in <code>kubectl.talon</code>.</p> </li> <li> <p><code>evince</code>: This directory provides support for controlling the Evince document viewer on Linux. The <code>evince_linux.py</code> file provides implementations of various page navigation actions, and <code>evince.talon</code> sets the <code>user.pages</code> tag, enabling those actions.</p> </li> <li> <p><code>evernote</code>: This directory provides a small configuration specific to Evernote on macOS. The <code>mac.talon</code> file sets a <code>key_wait</code> setting that helps with the multiple keypress issues that Talon can sometimes have.</p> </li> <li> <p><code>windows_explorer</code>: This directory provides support for interacting with Windows Explorer and file dialogs. The <code>windows_explorer.py</code> file provides implementations for file and folder actions, and <code>windows_explorer.talon</code> provides voice commands that call those actions.</p> </li> <li> <p><code>1password</code>: This directory provides platform specific commands for using 1Password. The <code>1password.py</code> file defines the application and custom actions, and the <code>1password_mac.py</code> and <code>1password_win.py</code> implement the actions by simulating keyboard presses. The <code>1password.talon</code> and <code>1password_global.talon</code> files provide voice commands for those actions.</p> </li> <li> <p><code>jetbrains</code>: This directory provides support for interacting with JetBrains IDEs. It uses an HTTP-based RPC system to communicate with the IDE, and the <code>jetbrains.talon</code> file defines a large number of useful commands for navigating and refactoring code, using the actions in <code>jetbrains.py</code>.</p> </li> <li> <p><code>thunderbird</code>: This directory provides support for controlling the Thunderbird email client, including inbox navigation, message composition, contact management, calendar and tasks. It includes OS-specific implementations, and it has specific configurations for different views within the application.</p> </li> <li> <p><code>gdb</code>: This directory contains files to enable voice control of the GNU Debugger (GDB).  The <code>gdb_active.talon</code> file defines the voice commands and the <code>gdb.py</code> file defines the <code>user.gdb</code> tag, which is toggled by <code>gdb_global.talon</code>.</p> </li> <li> <p><code>windows_terminal</code>: This directory contains configurations for the Windows Terminal application, including support for tabs, splits, and file management actions. The <code>windows_terminal.py</code> file implements the actions, and <code>windows_terminal.talon</code> activates the necessary tags.</p> </li> <li> <p><code>protonmail</code>: This directory contains scripts for interacting with the ProtonMail web application, including navigation, email management, and composer actions. The <code>protonmail.talon</code> file contains most of the voice commands.</p> </li> <li> <p><code>calibre</code>: This directory provides support for controlling the Calibre ebook management software and its ebook viewer. The <code>calibre.py</code> file defines the context for the main application, and <code>calibre_viewer.py</code> and <code>calibre_viewer.talon</code> provides the configurations for the ebook viewer.</p> </li> <li> <p><code>i3wm</code>: This directory provides configurations for the i3 window manager on Linux. It provides commands for managing workspaces and windows. The <code>i3wm.py</code> file provides the implementations of various <code>i3-msg</code> commands, and <code>i3wm.talon</code> binds those to voice commands.</p> </li> <li> <p><code>tmux</code>: This directory contains files to enable voice control of <code>tmux</code>. It provides basic pane management with <code>tmux.talon</code> and a more comprehensive command set for Linux with <code>tmux_linux.talon</code>, all using actions defined in <code>tmux.py</code>.</p> </li> <li> <p><code>brave</code>: This directory contains configurations for the Brave browser. The <code>brave.talon</code> file activates the <code>browser</code> and <code>user.tabs</code> tags, and the <code>brave.py</code> file defines a <code>tab_close_wrapper</code> action.</p> </li> <li> <p><code>anaconda</code>: This directory provides integration with the <code>conda</code> package manager. The <code>anaconda.talon</code> file defines the voice commands, and the <code>anaconda.py</code> file defines the <code>user.anaconda</code> tag which enables them.</p> </li> <li> <p><code>gitlab</code>: This directory provides voice commands for interacting with GitLab in a web browser. The commands are implemented in the <code>gitlab.talon</code> file.</p> </li> <li> <p><code>chrome</code>: This directory provides configurations for the Google Chrome browser. The <code>chrome.py</code> file defines the application context, and the <code>chrome.talon</code> file enables the <code>browser</code> and <code>user.tabs</code> tags and defines some additional commands for Chrome.</p> </li> <li> <p><code>rstudio</code>: This directory contains support for the RStudio application on macOS. The commands are defined in the <code>rstudio_mac.talon</code> file, and provide a variety of actions for coding, debugging, and navigating the IDE.</p> </li> <li> <p><code>github</code>: This directory provides voice commands for interacting with GitHub in a web browser. The commands are implemented in the <code>github_web.talon</code> file.</p> </li> <li> <p><code>amethyst</code>: This directory provides voice commands for the Amethyst window manager on macOS. The <code>amethyst.talon</code> file contains the relevant commands.</p> </li> <li> <p><code>taskwarrior</code>: This directory provides voice commands for the Taskwarrior command-line task manager. The commands are implemented in the <code>taskwarrior_linux.talon</code> file, and are intended for use on Linux.</p> </li> <li> <p><code>powershell</code>: This directory provides configurations for the Windows PowerShell. The <code>powershell_win.py</code> file implements the actions, and the <code>powershell_win.talon</code> activates the <code>terminal</code>, <code>user.generic_windows_shell</code>, <code>user.git</code>, <code>user.anaconda</code>, and <code>user.file_manager</code> tags.</p> </li> <li> <p><code>warp</code>: This directory provides support for the Warp terminal application on macOS. The <code>warp.talon</code> file activates a number of tags, and <code>warp.py</code> defines the application context.</p> </li> <li> <p><code>dunst</code>: This directory provides configurations for the Dunst notification daemon. The <code>dunst.talon</code> file contains the voice commands.</p> </li> <li> <p><code>windows_command_processor</code>: This directory contains support for the Windows Command Prompt and Windows Terminal, including actions for file management and terminal interaction. The actions are implemented in <code>command_processor_win.py</code> and <code>command_processor_actions_win.py</code>.</p> </li> <li> <p><code>teams</code>: This directory contains support for controlling the Microsoft Teams application. The <code>teams_linux.py</code> file defines some Linux specific actions, <code>teams.py</code> defines the application, and <code>teams.talon</code> and <code>teams_mac.talon</code> define the voice commands for Linux/Windows and macOS, respectively.</p> </li> <li> <p><code>finder</code>: This directory contains configurations for the macOS Finder. The <code>finder.py</code> implements actions related to file management and navigation, while <code>finder.talon</code> activates tags and provides voice commands to call those actions.</p> </li> <li> <p><code>signal</code>: This directory contains configuration for the Signal application on Linux.  The <code>signal_linux.talon</code> file contains the voice commands.</p> </li> <li> <p><code>nautilus</code>: This directory provides configurations for the Nautilus file manager on Linux. The <code>nautilus.py</code> file implements the actions, and <code>nautilus.talon</code> activates the <code>user.tabs</code> and <code>user.file_manager</code> tags.</p> </li> <li> <p><code>arc</code>: This directory provides support for the Arc browser. The <code>arc.py</code> file defines custom actions, <code>little-arc_mac.talon</code> defines a command for opening a new \"Little Arc\" window, and <code>arc_mac.talon</code> activates the <code>browser</code>, <code>user.tabs</code>, and <code>user.command_search</code> tags.</p> </li> <li> <p><code>edge</code>: This directory provides support for the Microsoft Edge browser. The <code>edge.py</code> file defines an action for opening the extensions page, and <code>edge.talon</code> activates the <code>browser</code> and <code>user.tabs</code> tags.</p> </li> <li> <p><code>firefox</code>: This directory provides support for the Firefox browser. The <code>firefox.py</code> file defines the application context and some generic actions, and the platform specific implementations are in <code>firefox_win_linux.py</code> and <code>firefox_mac.py</code>. The voice commands are in <code>firefox.talon</code>.</p> </li> <li> <p><code>termite</code>: This directory provides configuration for the Termite terminal application. The <code>termite.talon</code> file activates the <code>user.kubectl</code>, <code>user.git</code>, <code>user.taskwarrior</code>, and <code>terminal</code> tags.</p> </li> <li> <p><code>guake</code>: This directory provides configuration for the Guake terminal application on Linux. The <code>guake_linux.py</code> file activates the <code>user.git</code>, <code>user.kubectl</code>, <code>user.tabs</code>, and <code>terminal</code> tags, and provides tab management actions.</p> </li> <li> <p><code>sumatrapdf</code>: This directory provides configurations for the SumatraPDF application. The <code>sumatrapdf.talon</code> file activates the <code>user.pages</code> and <code>user.tabs</code> tags, and the <code>sumatrapdf.py</code> implements actions for tab management, zooming, and page navigation.</p> </li> <li> <p><code>talon</code>: This directory contains configurations that are specific to the Talon application itself.</p> <ul> <li><code>talon/talon_repl</code> provides commands for interacting with the Talon REPL, and includes commands for debugging and inspecting the state of the Talon runtime.</li> <li><code>talon/talon_debug_window</code> provides commands that are available when the Talon debug window is active, including commands to inspect internal talon structures, and dictating key combinations.</li> </ul> </li> <li> <p><code>dock</code>: This directory contains configurations to interact with the macOS Dock. The <code>dock.py</code> file defines actions for sending notifications and activating App Expos\u00e9, and <code>dock.talon</code> defines voice commands that trigger those actions.</p> </li> <li> <p><code>git</code>: This directory provides commands for interacting with Git from the command line. It provides a set of commands, arguments and convenience functions, that are implemented in <code>git.talon</code>, and used by <code>git_add_patch.talon</code>, using <code>user.git_command</code>, <code>user.git_argument</code>, and other lists defined in <code>git.py</code>.</p> </li> <li> <p><code>safari</code>: This directory provides support for the Safari browser. The <code>safari.py</code> file defines the application context and some browser actions, and <code>safari.talon</code> activates the <code>browser</code> and <code>user.tabs</code> tags.</p> </li> <li> <p><code>eclipse</code>: This directory provides voice commands for the Eclipse IDE on Windows.  The <code>eclipse_win.py</code> file implements the actions, and <code>eclipse.talon</code> defines the voice commands that use those actions, and also defines some keybindings.</p> </li> <li> <p><code>obsidian</code>: This directory provides support for the Obsidian application. The <code>obsidian.py</code> file sets the default code language to markdown, and <code>obsidian.talon</code> activates the <code>user.tabs</code> tag.</p> </li> <li> <p><code>emacs</code>: This directory provides support for the Emacs text editor. The <code>emacs.py</code> file provides implementations of various actions, and <code>emacs.talon</code> defines voice commands for those actions. The <code>emacs_commands.csv</code> provides data to create short and spoken forms of Emacs commands, which are loaded by <code>emacs_commands.py</code>.</p> </li> <li> <p><code>meld</code>: This directory contains files that provide support for the Meld visual diff and merge tool, providing tab management and actions for moving between changes. The <code>meld.py</code> file implements the basic actions, and <code>meld.talon</code> provides the voice commands.</p> </li> <li> <p><code>terminator</code>: This directory provides configurations for the Terminator terminal emulator on Linux.  The <code>terminator_linux.py</code> file sets up the application context, and provides implementations of various user, app, and edit actions.</p> </li> <li> <p><code>kde_konsole</code>: This directory provides support for the KDE Konsole terminal emulator on Linux. The <code>kde_konsole.py</code> file defines actions for tab management and remapped edit actions, and <code>kde_konsole.talon</code> activates the <code>terminal</code>, <code>user.generic_unix_shell</code>, <code>user.git</code>, <code>user.anaconda</code>, and <code>user.tabs</code> tags.</p> </li> <li> <p><code>okular</code>: This directory provides support for the Okular document viewer. The <code>okular.py</code> file provides actions for page navigation, and <code>okular.talon</code> activates the <code>user.pages</code> tag.</p> </li> <li> <p><code>vscode/command_client</code>: This directory is part of the VS Code support and provides a mechanism for Talon to communicate with VS Code using a file based RPC system.</p> <ul> <li><code>vscode/command_client/rpc_client</code>: This subdirectory provides the core functionality for implementing RPC using files. It includes a variety of utilities to prevent file locking and race conditions.</li> </ul> </li> </ul> <p>The top-level <code>README.md</code> file explains the use of <code>browser.host</code> and suggests browser extensions for non-macOS platforms to populate the browser.host matcher, which is used in some of the web app configurations.</p> <p>These subdirectories contain configurations for a wide variety of applications, and they use a combination of <code>.talon</code> files for voice commands and <code>.py</code> files for the implementation.  They often use tags to enable additional functionality from other parts of the Talon configuration. The <code>README.md</code> files that are contained within each directory provide more specific information.</p>"},{"location":"apps/1password/","title":"1password","text":"<p>The <code>community/apps/1password</code> directory contains files that enable voice control for the 1Password password manager application. It includes platform-specific keybindings and generic Talon commands.</p> <p>The core functionality is defined in <code>password_manager.py</code>. This file defines the application identifiers for 1Password on different platforms and declares the user actions that can be performed. These actions include: <code>password_fill</code>, <code>password_show</code>, <code>password_new</code>, <code>password_duplicate</code>, <code>password_edit</code>, and <code>password_delete</code>. The action implementations are defined in the platform-specific files, <code>1password_mac.py</code> and <code>1password_win.py</code>.</p> <p><code>1password_mac.py</code> defines the keybindings for the actions on macOS. For example, <code>password_fill</code> is bound to <code>cmd-\\</code> and <code>password_show</code> is bound to <code>cmd-alt-\\</code>. Similarly, <code>1password_win.py</code> defines the keybindings for the actions on Windows. For example, <code>password_fill</code> is bound to <code>ctrl-\\\\</code>.</p> <p>The Talon files, <code>1password.talon</code> and <code>1password_global.talon</code>, provide the voice commands for the user actions. <code>1password.talon</code> contains commands that are specific to the 1Password application, such as \"password new\", \"password dup\", \"password edit\", and \"password delete\". <code>1password_global.talon</code> contains global commands that can be used in any context, such as \"password fill\" and \"password show\". These files map the voice commands to the actions defined in <code>password_manager.py</code>.</p>"},{"location":"apps/adobe/","title":"adobe","text":"<p>This directory contains files for controlling Adobe Acrobat Reader DC.</p> <p>The file <code>adobe_acrobat_reader_dc.py</code> defines the application that Talon will recognize. It specifies that the application is \"Adobe Acrobat DC\" or \"Adobe Acrobat Reader DC\" on Windows, using the executable names <code>acrobat.exe</code> or <code>acrord32.exe</code>. This file uses Talon's module system to define the application that the other files in this directory will be associated with.</p> <p><code>adobe_acrobat_reader_dc.talon</code> defines which tags to activate when the application is in focus. In this case, the <code>user.tabs</code> and <code>user.pages</code> tags are activated which makes the commands defined by those tags available.</p> <p><code>adobe_acrobat_reader_dc_win.py</code> contains the bulk of the functionality for controlling the application. It defines an application context that matches the <code>adobe_acrobat_reader_dc</code> application defined in <code>adobe_acrobat_reader_dc.py</code> on Windows. It then defines implementations for several actions:</p> <ul> <li><code>app.tab_next</code> and <code>app.tab_previous</code>: These are implemented with <code>ctrl-tab</code> and <code>ctrl-shift-tab</code> to cycle through open documents.</li> <li><code>edit.zoom_in</code>, <code>edit.zoom_out</code>, and <code>edit.zoom_reset</code>: These are implemented with <code>ctrl-0</code>, <code>ctrl-1</code>, and <code>ctrl-2</code> respectively.  The comments indicate that these keyboard shortcuts are used for the German version of the application and that the implementation should be updated to handle different languages.</li> <li><code>user.page_current</code>: This is implemented by opening a dialog to show the current page number using <code>ctrl-shift-n</code>, reading the selected text, and returning the number as an integer.</li> <li><code>user.page_next</code> and <code>user.page_previous</code>: These use <code>ctrl-pagedown</code> and <code>ctrl-pageup</code> to navigate pages.</li> <li><code>user.page_jump</code>: This opens the same dialog as <code>user.page_current</code>, inserts the desired page number, and activates the dialog using enter.</li> <li><code>user.page_final</code>: This goes to the last page of the document with <code>end</code>.</li> <li><code>user.page_rotate_right</code> and <code>user.page_rotate_left</code>: These rotate the page to the right or left by using <code>shift-ctrl-0</code> and <code>shift-ctrl-1</code> respectively.</li> </ul> <p>These files work together to provide a set of commands for controlling Adobe Acrobat Reader DC on Windows. The <code>.py</code> files define the application context and actions, and the <code>.talon</code> file activates the necessary tags for these actions to be used.</p>"},{"location":"apps/amethyst/","title":"amethyst","text":"<p>The <code>community/apps/amethyst</code> directory contains configurations for the Amethyst window manager.</p> <p>The most important file in this directory is <code>amethyst.talon</code>. This file defines Talon voice commands for interacting with Amethyst. It includes commands for:</p> <ul> <li>Moving between windows (<code>window next</code>, <code>window previous</code>)</li> <li>Maximizing and floating windows (<code>window full</code>, <code>window float</code>)</li> <li>Changing the window layout (<code>window tall</code>, <code>window middle</code>)</li> <li>Moving a window to the main area (<code>window move main</code>)</li> <li>Resizing windows (<code>window grow</code>, <code>window shrink</code>)</li> <li>Reevaluating window layout (<code>window reevaluate</code>)</li> </ul> <p>These commands use keyboard shortcuts to control Amethyst, allowing a user to manage their windows with voice commands.</p>"},{"location":"apps/anaconda/","title":"anaconda","text":"<p>The <code>community/apps/anaconda</code> directory contains files that integrate with the <code>conda</code> package manager, commonly used in Python development.</p> <p>The file <code>anaconda.talon</code> defines voice commands for interacting with <code>conda</code>. It includes commands for common operations such as listing environments (<code>anaconda environment list</code>), creating environments (<code>anaconda environment create</code>), activating environments (<code>anaconda activate</code>), and installing packages (<code>anaconda install</code>). It also includes a variety of less common commands. All commands start with the word \"anaconda\" followed by a description of the conda command being invoked. The commands are enabled when both the <code>terminal</code> and <code>user.anaconda</code> tags are active.</p> <p>The file <code>anaconda.py</code> sets up a Talon module and context for the anaconda commands. It defines the <code>anaconda</code> tag, and then activates a context when that tag is set along with the <code>user.anaconda</code> tag. This context makes the commands in <code>anaconda.talon</code> available.</p> <p>Together, these files allow users to control <code>conda</code> through voice commands when in a terminal and the user.anaconda tag is set, streamlining the process of managing Python environments and packages.</p>"},{"location":"apps/apple_notes/","title":"apple_notes","text":"<p>The <code>community/apps/apple_notes</code> directory contains files that provide support for controlling the Apple Notes application using Talon.</p> <p>The core functionality is implemented in the <code>apple_notes.talon</code> file, which contains a list of commands for controlling the application. It provides commands for basic editing tasks such as creating new notes, duplicating notes, and creating folders. It also has commands for view management such as toggling folders, showing the main view, switching to list or gallery view, and toggling attachments. It also provides commands for common editing tasks such as finding text, printing, attaching a file, creating a link, inserting a table, applying formatting styles, increasing or decreasing font sizes, and inserting a line break. There are also commands for marking text, and for dragging selected lines up or down.</p> <p>The <code>apple_notes.py</code> file defines a Talon context that is active when the Apple Notes application is in focus. It defines custom implementations of existing <code>edit</code> actions, specifically adding <code>zoom_in</code>, <code>zoom_out</code>, <code>zoom_reset</code> and <code>indent_less</code> actions.</p>"},{"location":"apps/apple_terminal/","title":"apple_terminal","text":"<p>The <code>community/apps/apple_terminal</code> directory contains files that provide support for using Talon with the Apple Terminal application.</p> <p>The core functionality is defined in <code>apple_terminal.talon</code>. This file activates several important tags: *   <code>terminal</code>: This tag makes the commands defined in <code>terminal.talon</code> available, providing general terminal functionality. *   <code>user.readline</code>: This tag enables readline keybindings for editing commands within the terminal. *   <code>user.generic_unix_shell</code>: This tag activates the commands and functions in <code>terminal.talon</code>, which provide generic Unix shell functionality. *   <code>user.git</code>, <code>user.anaconda</code>, and <code>user.kubectl</code>: These tags make commands specific to those applications available, but can be disabled if not used. *   <code>user.tabs</code> and <code>user.file_manager</code>: These tags activate additional functionality related to tab management and file management within the terminal.</p> <p>The <code>apple_terminal.talon</code> file also defines <code>suspend</code> and <code>resume</code> commands. The <code>suspend</code> command sends <code>ctrl-z</code> to the terminal, which suspends the current process. The <code>resume</code> command types <code>fg</code> followed by enter, which resumes the suspended process.</p> <p>The file <code>apple_terminal.py</code> defines the application context and implements custom actions for the Apple Terminal. *   It defines a context that matches the <code>apple_terminal</code> application. *   It remaps the <code>edit.delete_line()</code> action to <code>ctrl-u</code>. *   It provides file manager actions within a <code>user</code> context such as:     *   <code>file_manager_current_path()</code>: Extracts the current path from the terminal's window title.     *   <code>file_manager_open_directory(path)</code>: Inserts a <code>cd</code> command into the terminal.     *   <code>file_manager_open_parent()</code>: Inserts a <code>cd ..</code> command into the terminal.     *   <code>file_manager_select_directory(path)</code>: Inserts the provided path.     *  <code>file_manager_new_folder(name)</code>: Inserts a <code>mkdir</code> command with the provided name.     *   <code>file_manager_open_file(path)</code>: Inserts the provided path, followed by enter.     *    <code>file_manager_select_file(path)</code>: Inserts the provided path. *   It defines application actions within an <code>app</code> context, specifically <code>tab_previous()</code> and <code>tab_next()</code> which use the keyboard shortcuts for switching tabs in the Apple Terminal application.</p>"},{"location":"apps/arc/","title":"arc","text":"<p>This directory contains files to add support for the Arc browser to Talon.</p> <p>The file <code>arc.py</code> defines the app context for Arc on macOS, and defines custom actions for that context.</p> <p><code>tab_close_wrapper</code> adds a short pause before closing a tab. This is helpful because Arc can sometimes be slow to respond to the close command.</p> <p><code>command_search</code> focuses the URL bar and inserts the given text.</p> <p><code>show_extensions</code> opens a new tab and navigates to the extensions page.</p> <p>The file <code>little-arc_mac.talon</code> defines a command for opening a new \"Little Arc\" window. It presses <code>cmd-alt-n</code> which is the shortcut to open a new \"Little Arc\" window. Then it inserts any text spoken after \"little arc\".</p> <p>The file <code>arc_mac.talon</code> activates the <code>browser</code>, <code>user.tabs</code>, and <code>user.command_search</code> tags when the Arc app is active on macOS. This allows the user to use commands defined in other files that use these tags.</p>"},{"location":"apps/atril/","title":"atril","text":"<p>The <code>community/apps/atril</code> directory contains files to enable Talon voice control for the Atril document viewer application on Linux.</p> <p>The primary file is <code>atril.py</code>, which defines the application context and implements custom user actions. It declares an application named \"atril\" that matches when running on Linux and the app name is \"Atril\". It then defines a context that will activate when the \"atril\" application is active. This context contains implementations for <code>user.page_current</code>, <code>user.page_next</code>, <code>user.page_previous</code>, <code>user.page_jump</code>, and <code>user.page_final</code> actions, which are used to navigate pages in a document. These actions generally rely on keyboard shortcuts like <code>ctrl-l</code> to focus the page number input, <code>ctrl-pagedown</code> for next page, <code>ctrl-pageup</code> for previous page, etc.</p> <p>The file <code>atril.talon</code> sets the <code>user.pages</code> tag whenever Atril is the active application. This tag is used to enable the user to say things like \"page next\" and \"page jump 5\".</p>"},{"location":"apps/brave/","title":"brave","text":"<p>The <code>community/apps/brave</code> directory contains files that provide Talon voice control for the Brave browser.</p> <p>The file <code>brave.talon</code> defines the application tag for the Brave browser. It sets the <code>browser</code> and <code>user.tabs</code> tags, which are used by other Talon scripts to apply browser-specific commands and tab-related commands, respectively.</p> <p>The file <code>brave.py</code> defines the application context and custom actions for Brave. It defines the app using multiple formats to handle the differences between platforms and app names.  The <code>UserActions</code> class contains a custom <code>tab_close_wrapper</code> action that adds a short sleep before closing a tab.  The <code>BrowserActions</code> class contains a <code>show_extensions</code> action that opens a new tab and navigates to <code>brave://extensions</code>, which is the URL for the extensions management page.</p> <p>These two files work together to enable basic Brave browser control. The <code>.talon</code> file tags the application, allowing the <code>.py</code> file to use the <code>ctx.matches</code> to apply the contained action implementations.</p>"},{"location":"apps/calibre/","title":"calibre","text":"<p>The <code>community/apps/calibre</code> directory contains files that add Talon voice control for the Calibre ebook management software and its ebook viewer.</p> <p>The file <code>calibre.py</code> defines the application context for the main Calibre application. It specifies the app names and executable names for Windows and Linux. This allows Talon to identify when the Calibre application is active.</p> <p>The file <code>calibre_viewer.py</code> defines the application context for the Calibre ebook viewer. It specifies the app name and title patterns for Windows and Linux. This allows Talon to identify when the Calibre ebook viewer is active. It also defines user actions such as <code>page_next</code>, <code>page_previous</code>, <code>chapter_next</code>, and <code>chapter_previous</code> by sending the appropriate keyboard shortcuts.</p> <p>The file <code>calibre_viewer.talon</code> sets tags <code>user.pages</code> and <code>user.chapters</code> when the Calibre ebook viewer is active, enabling use of commands for those tags.</p>"},{"location":"apps/chrome/","title":"chrome","text":"<p>This directory contains configuration files for the Google Chrome browser, enabling Talon to interact with it effectively.</p> <p>The file <code>chrome.py</code> defines the application context for Chrome across different operating systems. It uses Talon's <code>Context</code> and <code>Module</code> to specify which application it applies to based on the OS and the executable name or bundle identifier. It also defines a <code>chrome_mod</code> action that presses a key with the correct modifier (<code>cmd</code> on macOS and <code>ctrl</code> on other platforms). Additionally it defines a <code>tab_close_wrapper</code> that waits for a short time before closing a tab, and it defines a <code>show_extensions</code> action that opens a new tab and navigates to the chrome extensions page.</p> <p>The file <code>chrome.talon</code> uses the <code>app: chrome</code> context defined in <code>chrome.py</code> to enable certain tags when chrome is active, specifically <code>browser</code> and <code>user.tabs</code>, which makes the commands defined elsewhere in the Talon configuration that relate to browsers and tabs available when using Chrome. It also defines custom voice commands such as \"profile switch\" to switch profiles and \"tab search\" to open tab search and type text.</p>"},{"location":"apps/conemu/","title":"conemu","text":"<p>The <code>community/apps/conemu</code> directory contains configuration for the ConEmu terminal application.</p> <p>The <code>conemu.talon</code> file enables the <code>terminal</code> and <code>user.git</code> tags when ConEmu is the active application. This allows Talon commands and scripts that rely on these tags to work when you are using ConEmu.</p>"},{"location":"apps/discord/","title":"discord","text":"<p>The <code>community/apps/discord</code> directory contains files that implement support for controlling the Discord application with Talon.</p> <p>The core logic is split across multiple files:</p> <ul> <li><code>discord.py</code>: This file defines the Talon module for Discord, including the application definition and a list of possible destinations when using quick switcher. It also declares the actions used to control Discord, without implementing the specific key presses.</li> <li><code>discord.talon</code>: This file contains the Talon commands that users will say to control Discord. These commands map to the actions defined in <code>discord.py</code>. The commands use the <code>user.discord_destination</code> list to specify the type of destination when using quick switcher.</li> <li><code>discord_win.py</code>: This file implements the actions for the Windows and Linux operating systems by specifying the necessary key presses to perform the actions defined in <code>discord.py</code>.</li> <li><code>discord_mac.py</code>: This file implements the actions for the macOS operating system by specifying the necessary key presses to perform the actions defined in <code>discord.py</code>.</li> </ul> <p>These files work together to provide a cross-platform way to control Discord with Talon. The <code>discord.py</code> file defines the module, actions, and application definition. The <code>discord.talon</code> file binds user voice commands to those actions. The platform-specific python files implement the actions by simulating key presses.</p>"},{"location":"apps/dock/","title":"dock","text":"<p>The <code>community/apps/dock</code> directory contains files that allow the user to control the macOS Dock via Talon.</p> <p>The <code>dock.py</code> file defines the core functionality, using the Talon API and macOS's Accessibility API to interact with the Dock.  It defines two custom actions:</p> <ul> <li><code>dock_send_notification(notification: str)</code>: Sends a notification to the macOS Dock using SPI (System Programming Interface). The implementation of this action is in the <code>UserActions</code> class which calls <code>talon.mac.dock.dock_notify</code>. This action can be used to trigger certain Dock behaviors, such as showing the desktop or toggling Launchpad.</li> <li><code>dock_app_expose(app: Optional[ui.App] = None)</code>: Activates macOS app Expos\u00e9 for a given app's Dock item. If no app is specified, it defaults to the frontmost app. The implementation of this action is in the <code>UserActions</code> class. It first locates the Dock icon for the application by searching the accessibility tree. Then it performs the <code>AXShowExpose</code> action on the Dock item. If no Dock icon or multiple Dock icons are found, a notification is sent to the user.</li> </ul> <p>The <code>dock.talon</code> file contains Talon commands that use the actions defined in <code>dock.py</code>:</p> <ul> <li><code>^desktop$</code>: Triggers <code>user.dock_send_notification(\"com.apple.showdesktop.awake\")</code> to show the desktop.</li> <li><code>^window$</code>: Triggers <code>user.dock_app_expose()</code> to activate App Expos\u00e9 for the frontmost app.</li> <li><code>^launch pad$</code>: Triggers <code>user.dock_send_notification(\"com.apple.launchpad.toggle\")</code> to toggle Launchpad.</li> </ul> <p>In summary, the files in <code>community/apps/dock</code> work together to provide a way to control the macOS Dock with Talon. <code>dock.py</code> implements the core functionality of sending notifications to the Dock and activating App Expos\u00e9. <code>dock.talon</code> provides the commands that trigger these actions.</p>"},{"location":"apps/dunst/","title":"dunst","text":"<p>The <code>community/apps/dunst</code> directory contains files that integrate the Dunst notification daemon with Talon.</p> <p>The file <code>dunst.talon</code> defines Talon commands for controlling Dunst.</p> <p>Specifically, it defines the following commands:</p> <ul> <li><code>show notifications</code>: bound to <code>ctrl-</code>`, this command likely focuses or brings the Dunst notification window to the foreground.</li> <li><code>dismiss [notifications]</code>: executes <code>dunstctl close</code>, which dismisses the currently displayed notification.</li> <li><code>dismiss all [notifications]</code>: executes <code>dunstctl close-all</code>, which dismisses all currently displayed notifications.</li> </ul> <p>The commented-out lines are likely experimental or alternative commands that the author has chosen to disable. They would have provided the ability to pause, resume, and test notifications.</p>"},{"location":"apps/eclipse/","title":"eclipse","text":"<p>The <code>community/apps/eclipse</code> directory contains files that provide Talon voice commands for the Eclipse IDE.</p> <p>The file <code>eclipse_win.py</code> defines the core logic for how Talon interacts with Eclipse. It leverages Talon's context system to define actions specific to the Eclipse application on Windows. The file is organized into several action classes:</p> <ul> <li><code>AppActions</code> defines actions like closing/navigating tabs, and opening/closing windows.</li> <li><code>CodeActions</code> defines code-related actions, such as toggling comments.</li> <li><code>EditActions</code> provides actions for editing text, such as navigating lines, indenting, and saving.</li> <li><code>UserActions</code> implements actions related to plugins, such as HandySplit, and find and replace functionality. This includes actions for manipulating splits and performing find and replace operations.</li> </ul> <p>The <code>eclipse.talon</code> file defines the voice commands that use the actions defined in <code>eclipse_win.py</code>, and also defines some basic keybindings. The file also includes tags, which are used to activate certain Talon modules with additional features, in this case: <code>user.find_and_replace</code>, <code>user.line_commands</code>, <code>user.splits</code>, <code>user.tabs</code>, and <code>user.command_search</code>. Some important commands defined in this file are:</p> <ul> <li>Sidebar Navigation: Commands to open different sidebars like \"explore\", \"outline\".</li> <li>Panel Navigation: Commands to open different panels like \"output\", \"problems\", \"search\", etc.</li> <li>Settings and Shortcuts: Commands to open Eclipse settings and shortcuts dialogs.</li> <li>File Commands: Commands for creating, opening, and renaming files.</li> <li>Language Features: Commands for features like fixing imports, and refactoring code.</li> <li>Code Navigation: Commands for navigation within code, such as going to declarations, and going back/forward in navigation history.</li> <li>Bookmarks: Commands for setting, and navigating bookmarks.</li> <li>Debugging: Commands for controlling the debugger such as setting breakpoints, stepping, and continuing execution.</li> <li>Copy Line: Commands for copying a line up or down.</li> </ul> <p>Together, <code>eclipse_win.py</code> and <code>eclipse.talon</code> enable voice control for common Eclipse tasks, including editing, navigating, debugging, and managing files and panels.</p>"},{"location":"apps/edge/","title":"edge","text":"<p>The <code>community/apps/edge</code> directory contains files to add support for Microsoft Edge.</p> <p>The file <code>edge.py</code> defines a Talon module and context for Microsoft Edge. It defines the app id, \"microsoft_edge\", which can be used to match the application across different operating systems. The context defines an action, <code>show_extensions()</code>, which opens a new tab and navigates to <code>edge://extensions</code>. This action is associated with the <code>browser</code> action class.</p> <p>The file <code>edge.talon</code> applies the <code>browser</code> and <code>user.tabs</code> tags to the \"microsoft_edge\" app. These tags can then be used to trigger other actions and rules, such as those defined in <code>browser.talon</code> or <code>tabs.talon</code>.</p>"},{"location":"apps/emacs/","title":"emacs","text":"<p>The <code>community/apps/emacs</code> directory contains files that add support for using Talon with the Emacs text editor.</p> <p>The core functionality is in emacs.py, which defines Talon actions for interacting with Emacs. It defines an <code>emacs_meta</code> setting which determines how the \"meta\" key is handled (defaults to \"esc\", but can be set to \"alt\" or \"cmd\"). It defines actions such as <code>emacs_meta</code> for pressing keys modified by the meta key, <code>emacs_key</code> for pressing keys with meta key translation, <code>emacs_prefix</code> for inputting a prefix argument, <code>emacs</code> for running emacs commands, and <code>emacs_help</code> for running help commands. It also defines many actions that override the standard Talon <code>user</code>, <code>edit</code>, <code>app</code>, <code>code</code>, and <code>win</code> actions for more seamless Emacs integration, such as <code>cut_line</code>, <code>save</code>, <code>copy</code>, <code>find</code>, <code>tab_next</code>, <code>toggle_comment</code>, and <code>filename</code>.</p> <p>emacs.talon defines the voice commands that trigger the actions defined in <code>emacs.py</code>. It includes commands for common Emacs actions such as <code>execute</code>, <code>prefix</code>, <code>cancel</code>, <code>switch</code>, and <code>shell command</code>, along with commands for more complex actions like <code>sort lines</code>, <code>fill paragraph</code>, <code>customize face</code>, <code>dired omit mode</code>, <code>profiler start</code>, <code>split solo</code>, <code>apropos</code>, <code>file open</code>, and <code>search back</code>. There are also a number of commands for interacting with different modes such as <code>python mode</code>, <code>smerge mode</code>, and <code>outline minor mode</code>. Many commands take optional text or numbers as arguments, which are captured using Talon's <code>&lt;user.text&gt;$</code> and <code>&lt;user.number_signed_small&gt;</code> tags.</p> <p>emacs_commands.csv is a CSV file that lists Emacs commands, their key bindings, short forms, and spoken forms. This data is used by <code>emacs_commands.py</code> to provide keybindings, short forms, and spoken forms for Emacs commands in Talon. For example, the <code>Command</code> <code>transpose-lines</code>, has the <code>Key binding</code> <code>ctrl-x ctrl-t</code>, the <code>Short form</code> is empty, and the <code>Spoken form</code> is <code>tr-lines</code>.</p> <p>emacs_commands.py is a Python file that reads <code>emacs_commands.csv</code> and provides actions for looking up the keybindings and short forms of Emacs commands. This file is used by <code>emacs.py</code> to implement the <code>emacs_command_keybinding</code> and <code>emacs_command_short_form</code> actions. The <code>load_commands</code> function parses the CSV, and uses the <code>user.create_spoken_forms_from_list</code> action to generate a list of commands that are recognized by Talon, using the <code>Spoken form</code> column where provided.</p> <p>These files work together to create a comprehensive Emacs integration for Talon. <code>emacs_commands.csv</code> provides the data, <code>emacs_commands.py</code> loads it and makes it available to Talon actions, <code>emacs.py</code> implements the actions, and <code>emacs.talon</code> binds those actions to voice commands.</p>"},{"location":"apps/evernote/","title":"evernote","text":"<p>The <code>community/apps/evernote</code> directory contains Talon code for controlling the Evernote application on macOS.</p> <p>The file <code>mac.talon</code> applies only to macOS and the Evernote application. It defines a <code>settings()</code> block that sets <code>key_wait</code> to <code>9.0</code>. This is used to prevent issues where Talon commands that involve multiple keystrokes (like \"slap\") can get jumbled due to delays.</p>"},{"location":"apps/evince/","title":"evince","text":"<p>The files in the <code>community/apps/evince</code> directory provide support for controlling the Evince document viewer application on Linux using Talon.</p> <p>The core functionality is split between two files: *  <code>evince_linux.py</code>: This Python file defines the application context and implements custom user actions for controlling Evince. It leverages the Talon API (<code>actions</code>, <code>Context</code>, <code>Module</code>) to define the Evince application and its associated actions. The defined actions include moving to the next or previous page, jumping to a specific page number, navigating to the final page, and getting the current page number. It uses keyboard shortcuts within Evince to implement its functionality.</p> <ul> <li><code>evince.talon</code>: This Talon file defines the application tag for Evince. It activates the <code>user.pages</code> tag whenever the Evince application is in focus, enabling the custom user actions defined in <code>evince_linux.py</code>.</li> </ul>"},{"location":"apps/finder/","title":"finder","text":"<p>The <code>community/apps/finder</code> directory contains files that integrate Talon with the macOS Finder application, providing voice commands for file management and navigation.</p> <p>The <code>finder.talon</code> file, found at https://github.com/talonhub/community/blob/main/apps/finder/finder.talon, defines the voice commands and tags that are used within the Finder. It assigns the <code>user.address</code>, <code>user.file_manager</code>, <code>user.navigation</code>, and <code>user.tabs</code> tags, allowing these actions to be used in the finder. It provides voice commands for: *   Opening preferences (<code>preferences: key(cmd-,)</code>), options (<code>options: key(cmd-j)</code>), and search (<code>search: key(cmd-alt-f)</code>). *   Sorting files by none, name, kind, date opened, date added, date modified, and size. For example, saying \"sort by name\" executes <code>key(ctrl-alt-cmd-1)</code>. *   Changing the view mode including icon view, column view, list view, and gallery view. For example, saying \"column view\" executes <code>key(cmd-3)</code>. *   Trashing files (<code>trash it: key(cmd-backspace)</code>). *   Hiding the Finder or other applications.</p> <p>The <code>finder.py</code> file, located at https://github.com/talonhub/community/blob/main/apps/finder/finder.py, implements the actions that are called from the <code>finder.talon</code> file. It defines a Talon context that is only active when the focused application is the Finder, and provides actions to: *   Open the parent directory (<code>file_manager_open_parent</code>): executes <code>key(cmd-up)</code>. *   Get the current path (<code>file_manager_current_path</code>): retrieves the title of the active window, expands it if it includes <code>~</code>, remaps known paths from the <code>directories_to_remap</code> dictionary (e.g. an empty string to <code>/Volumes</code>), and removes paths from <code>directories_to_exclude</code>. *   Open a terminal in the current directory (<code>file_manager_terminal_here</code>): executes an AppleScript that gets the current path and then opens a new Terminal window or tab and <code>cd</code>s to the path. *   Show properties for a file or folder (<code>file_manager_show_properties</code>): executes <code>key(cmd-i)</code>. *   Open or select a directory, file or folder (<code>file_manager_open_directory</code>, <code>file_manager_select_directory</code>, <code>file_manager_open_file</code>, <code>file_manager_select_file</code>): executes <code>key(cmd-shift-g)</code>, <code>key(home)</code>, <code>key(cmd-o)</code> and then types the path passed to the function, followed by <code>key(enter)</code> for <code>file_manager_open_directory</code>. *   Create a new folder (<code>file_manager_new_folder</code>): executes <code>key(cmd-shift-n)</code> and inserts the folder name. *   Focus the address bar or copy the current address (<code>address_focus</code>, <code>address_copy_address</code>): executes <code>key(cmd-shift-g)</code> and <code>key(alt-cmd-c)</code>. *   Navigate to an address (<code>address_navigate</code>): calls <code>actions.user.file_manager_open_directory(address)</code>.</p> <p>These files work together to allow a user to control Finder using voice commands, including file navigation, view changes, and other file management actions.</p>"},{"location":"apps/firefox/","title":"firefox","text":"<p>The <code>community/apps/firefox</code> directory contains files that add support for the Firefox browser to Talon. This includes defining the application context, and implementing actions for controlling the browser.</p> <p>The core logic is in these files: *   <code>firefox.py</code>: This file defines the application context for Firefox, matching different operating systems and Firefox variants. It also defines the <code>firefox_bookmarks_sidebar</code> and <code>firefox_history_sidebar</code> actions, which are implemented differently per operating system. It also contains some generic browser actions, such as <code>focus_page</code> which focuses the address bar and triggers the find dialog, and <code>go_home</code>. *   <code>firefox_win_linux.py</code>: This file defines actions specific to Windows and Linux, including <code>firefox_bookmarks_sidebar</code>, <code>firefox_history_sidebar</code>, <code>focus_address</code>, <code>open_private_window</code>, <code>show_downloads</code>, <code>show_extensions</code>, and <code>show_history</code>. It leverages the <code>actions.key</code> function to send keyboard shortcuts for these actions. *   <code>firefox_mac.py</code>: This file defines actions specific to macOS, including <code>firefox_bookmarks_sidebar</code>, <code>firefox_history_sidebar</code>, <code>bookmarks</code>, <code>open_private_window</code>, <code>show_downloads</code>, and <code>show_extensions</code>. Similar to <code>firefox_win_linux.py</code>, it leverages <code>actions.key</code> to send keyboard shortcuts for these actions.</p> <p>The file <code>firefox.talon</code> provides the voice commands to trigger the actions defined in the Python files. It defines voice commands such as \"tab search\" and \"sidebar bookmarks\" to interact with the browser. These commands use the <code>browser.focus_address</code> and <code>user.firefox_bookmarks_sidebar</code> actions.</p> <p>These files work together by first defining the Firefox application context and then defining operating system-specific implementations for browser actions. The <code>.talon</code> file then binds voice commands to these actions.</p>"},{"location":"apps/foxit_reader/","title":"foxit_reader","text":"<p>The <code>community/apps/foxit_reader</code> directory contains files to enable Talon control of the Foxit Reader application.</p> <p>The core logic is within foxit_reader.py. This file defines the application context for Foxit Reader, using its window title and executable name. It then defines custom actions for the <code>app</code> and <code>user</code> action classes that provide the following functionality:</p> <ul> <li><code>app.tab_open()</code>: Opens a new tab using <code>ctrl-o</code>.</li> <li><code>app.tab_reopen()</code>: Notifies the user that Foxit doesn't support this action.</li> <li><code>user.tab_jump(number)</code>: Notifies the user that Foxit doesn't support this action.</li> <li><code>user.tab_final()</code>: Notifies the user that Foxit doesn't support this action.</li> <li><code>user.tab_duplicate()</code>: Notifies the user that Foxit doesn't support this action.</li> <li><code>user.page_current() -&gt; int</code>: Returns the current page number by using <code>ctrl-g</code>, getting selected text, and converting to an int.</li> <li><code>user.page_next()</code>: Navigates to the next page using the right arrow key.</li> <li><code>user.page_previous()</code>: Navigates to the previous page using the left arrow key.</li> <li><code>user.page_jump(number: int)</code>: Jumps to a specific page by using <code>ctrl-g</code>, inserting the page number and pressing enter.</li> <li><code>user.page_final()</code>: Navigates to the last page using the <code>end</code> key.</li> <li><code>user.page_rotate_right()</code>: Rotates the page right using <code>shift-ctrl-keypad_plus</code>.</li> <li><code>user.page_rotate_left()</code>: Rotates the page left using <code>shift-ctrl-keypad_minus</code>.</li> </ul> <p>foxit_reader.talon is a Talon script that provides the integration with the <code>foxit_reader</code> application context. It imports the <code>user.tabs</code> and <code>user.pages</code> tags that are used to manage the actions defined in <code>foxit_reader.py</code>. It also defines a command to close all tabs using <code>ctrl-shift-w</code>.</p>"},{"location":"apps/gdb/","title":"gdb","text":"<p>The <code>community/apps/gdb</code> directory contains files that enable voice control for the GNU Debugger (GDB). The files work together to provide a comprehensive set of commands that allow a user to interact with GDB using their voice.</p> <ul> <li> <p><code>gdb_active.talon</code> defines the core voice commands for interacting with GDB. This file uses the <code>user.gdb</code> tag, which is enabled and disabled by <code>gdb_global.talon</code>. It defines commands for common debugging actions like setting breakpoints (<code>break [on] clipboard</code>), inspecting variables (<code>print [variable] &lt;user.text&gt;</code>), stepping through code (<code>until &lt;number&gt;</code>), and controlling program execution (<code>continue</code>). It also includes commands for displaying information about the program state, such as registers, threads, and disassembly. The file also includes some specialized commands like hex dumping (<code>hex dump &lt;number&gt; bytes</code>) and commands for showing and setting GDB settings.</p> </li> <li> <p><code>gdb.py</code> defines a module with actions and contexts that are used in the Talon files. It defines the <code>user.gdb</code> tag and actions to enable and disable it. It also defines a number of actions on the <code>user</code> namespace that are used in <code>gdb_active.talon</code>, such as the debugger commands <code>debugger_step_into()</code>, <code>debugger_step_over()</code>, <code>debugger_continue()</code>, <code>debugger_add_sw_breakpoint()</code>, and more. These actions are responsible for inserting the corresponding GDB commands into the terminal.</p> </li> <li> <p><code>gdb_global.talon</code> provides commands to toggle the <code>user.gdb</code> tag, enabling and disabling the GDB-specific voice commands defined in <code>gdb_active.talon</code>. This file contains two commands, \"enable debug mode\" which calls <code>user.gdb_enable()</code> and \"disable debug mode\" which calls <code>user.gdb_disable()</code>.</p> </li> </ul>"},{"location":"apps/git/","title":"git","text":"<p>The <code>community/apps/git</code> directory provides a set of Talon scripts for interacting with Git from the command line. It defines commands, arguments, and convenience functions to make common Git operations faster and easier to use with voice.</p> <p>The directory contains the following key files:</p> <ul> <li><code>git_add_patch.talon</code>: This file defines a set of commands to navigate the interactive <code>git add --patch</code> interface. It uses single-letter mnemonics common in the <code>git add --patch</code> interface (<code>y</code>, <code>n</code>, <code>q</code>, <code>d</code>, <code>a</code>). This provides voice equivalents for common interactive patch selection operations.</li> <li><code>git.talon</code>: This file provides the core Talon commands for interacting with git. It defines a generic <code>git</code> command that takes a command name from the <code>user.git_command</code> list and a variable number of arguments from the <code>user.git_argument</code> list. It also defines specific commands, such as <code>git commit</code> and <code>git stash</code>, that can take a spoken message. It also includes commonly used commands, like <code>git status</code>, <code>git add patch</code>, <code>git show head</code>, and <code>git diff</code> to be executed using the <code>$</code>, meaning they require no arguments. Finally, it provides a set of convenience commands using the clipboard or the current selection, such as <code>git clone clipboard</code>, <code>git diff highlighted</code>, and <code>git add clipboard</code>.</li> <li><code>git_argument.talon-list</code>: This file defines the <code>user.git_argument</code> list used in <code>git.talon</code>. This list provides named arguments such as <code>--amend</code> or <code>--force</code>, as well as branch names that can be used with git commands.</li> <li><code>git.py</code>: This file defines the <code>user.git_command</code> and <code>user.git_argument</code> lists used in <code>git.talon</code>, and a capture rule to allow multiple arguments, so that the command \"git commit amend message foo bar\" is interpreted as \"git commit --amend --message \"foo bar\"\".</li> <li><code>git_command.talon-list</code>: This file defines the <code>user.git_command</code> list used in <code>git.talon</code>. It contains most git commands, such as <code>add</code>, <code>commit</code>, <code>push</code>, and <code>fetch</code>, etc.</li> </ul> <p>These files work together to provide a comprehensive voice interface for Git. The <code>git_command.talon-list</code> and <code>git_argument.talon-list</code> files define the vocabulary of git commands and options. The <code>git.talon</code> file uses these lists to create a flexible system to execute any git command. The <code>git_add_patch.talon</code> file uses single-letter mnemonics to make common interactive patch selection operations faster with voice. The <code>git.py</code> provides the necessary infrastructure to allow the use of user defined lists and arguments to be used in <code>git.talon</code>.</p>"},{"location":"apps/github/","title":"github","text":"<p>The <code>community/apps/github</code> directory contains configuration for interacting with the GitHub website using the Talon voice control system.</p> <p>The key file in this directory is <code>github_web.talon</code>. It defines a set of voice commands and keyboard shortcuts that allow users to navigate and interact with the GitHub website more efficiently.</p> <p>Here's a breakdown of the functionality provided by <code>github_web.talon</code>:</p> <ul> <li>Site-wide shortcuts: Provides commands for focusing the search bar, navigating to notifications and the dashboard, viewing keyboard shortcuts, and moving/opening selections.</li> <li>Repositories:  Provides commands to navigate to different parts of a repository, such as code, issues, pull requests, wiki, actions, projects, and discussions.</li> <li>Source code editing: Enables the user to open the web editor.</li> <li>Source code browsing: Provides commands for finding files, jumping to a specific line, switching branches/tags, expanding URLs, showing/hiding comments and annotations, and opening the blame view.</li> <li>Issues: Includes commands for creating issues, searching for issues and pull requests, filtering by labels/milestones/assignee, replying, submitting and previewing comments, and toggling fullscreen.</li> <li>Browsing commits: Allows for closing forms and navigating to parent commits.</li> <li>Notifications: Enables marking notifications as read and muting threads.</li> <li>Issue or pull request lists: Includes commands for opening and creating issues.</li> <li>Issues and pull requests: Provides commands to set reviewers, milestones, assignees, and labels.</li> <li>Actions: Allows navigating to workflows and toggling timestamps and fullscreen.</li> </ul> <p>In summary, <code>github_web.talon</code> acts as a central configuration file for streamlining GitHub interactions with voice commands, providing shortcuts to perform common tasks more quickly and easily.</p>"},{"location":"apps/gitlab/","title":"gitlab","text":"<p>The <code>community/apps/gitlab</code> directory contains a single file, <code>gitlab.talon</code>, which defines Talon voice commands for interacting with GitLab in a web browser.</p> <p>The file implements a wide range of commands, categorized as follows:</p> <ul> <li>Global Shortcuts: These commands provide access to common GitLab pages, such as projects, groups, activity, milestones, snippets, issues, and merge requests. It also includes commands for showing/hiding the performance bar and toggling the markdown preview.</li> <li>Project Navigation: These commands allow the user to quickly navigate to different sections within a project, like the project home, activity feed, releases, files, commits, repository graph, issues, merge requests, jobs, metrics, environments, cubes, snippets, and the project wiki.</li> <li>Issues and Merge Request Shortcuts: These shortcuts provide actions within an issue or merge request, like editing the description, changing the assignee, milestone, and label, right commenting, and moving between discussions.</li> <li>Project File Shortcuts: These provide shortcuts for navigating project files and opening permalinks.</li> <li>Wiki Page Shortcuts: These shortcuts allow editing the current page.</li> </ul> <p>The commands are designed to work on <code>gitlab.com</code>, as indicated by the <code>browser.host</code> setting. The commands are typically a combination of single-key shortcuts (often using modifiers like <code>shift</code> or <code>ctrl</code>) or insert commands.</p>"},{"location":"apps/gnome_terminal/","title":"gnome_terminal","text":"<p>This directory, <code>community/apps/gnome_terminal</code>, contains configuration files for the Gnome Terminal application within the Talon voice control system. It defines how Talon interacts with Gnome Terminal by mapping voice commands to specific actions.</p> <p>The core functionality is defined in two files:</p> <ul> <li> <p><code>gnome_terminal.py</code>: This Python file defines the application context and custom actions for Gnome Terminal.</p> <ul> <li>It starts by defining an application definition for Gnome Terminal, matching various executable names and application names.</li> <li>It then defines a context (<code>ctx</code>) which matches when the Gnome Terminal app is active.</li> <li>Within the context, it defines two action classes: <code>user_actions</code> and <code>app_actions</code>. The <code>user_actions</code> class overrides the <code>tab_jump</code> action to enable jumping between tabs using <code>alt-number</code> keys. The <code>app_actions</code> class defines several actions related to managing tabs and windows, such as opening, closing, and switching between tabs. Additionally, it overrides the global actions for opening and closing windows.</li> <li>Finally, it overrides several <code>edit</code> actions to provide <code>page_up</code>, <code>page_down</code>, <code>paste</code>, <code>copy</code>, <code>find</code>, and <code>delete_line</code>. It also defines several extend selection actions as <code>pass</code> because they are not supported by Gnome Terminal.</li> </ul> </li> <li> <p><code>gnome_terminal.talon</code>: This Talon script activates several tags when the Gnome Terminal app is active. These tags enable functionality and voice commands from other parts of the Talon configuration. The tags include:</p> <ul> <li><code>terminal</code>: Enables generic terminal commands.</li> <li><code>user.tabs</code>: Enables tab management commands.</li> <li><code>user.generic_unix_shell</code>: Enables commands specific to Unix-like shells.</li> <li><code>user.git</code>: Enables commands related to Git.</li> <li><code>user.kubectl</code>: Enables commands related to Kubernetes.</li> </ul> </li> </ul> <p>In summary, the files in this directory configure Gnome Terminal for use with Talon. The Python file defines actions and mappings to keyboard shortcuts, while the Talon file applies tags to enable further functionality. Together, these files allow users to control Gnome Terminal using voice commands for tab management, window management, text editing, and various developer-centric functions like shell interaction, Git, and Kubernetes.</p>"},{"location":"apps/guake/","title":"guake","text":"<p>The <code>community/apps/guake</code> directory contains configuration for the Guake terminal application on Linux.</p> <p>The file <code>guake_linux.py</code> defines a Talon context for Guake on Linux. It activates when the user is on Linux and using the Guake application. The context then sets the <code>user.git</code>, <code>user.kubectl</code>, <code>user.tabs</code>, and <code>terminal</code> tags, enabling commands defined in other files.</p> <p>The <code>AppActions</code> class defines custom actions for Guake:</p> <ul> <li><code>tab_open</code>: Opens a new tab using <code>ctrl-shift-t</code>.</li> <li><code>tab_close</code>: Closes the current tab using <code>ctrl-shift-w</code>.</li> <li><code>tab_next</code>: Switches to the next tab using <code>ctrl-pagedown</code>.</li> <li><code>tab_previous</code>: Switches to the previous tab using <code>ctrl-pageup</code>.</li> </ul> <p>These actions allow the user to interact with Guake using voice commands, leveraging the <code>app</code> action class, which is provided by Talon.</p>"},{"location":"apps/i3wm/","title":"i3wm","text":"<p>The <code>community/apps/i3wm</code> directory provides Talon bindings for the i3 window manager on Linux. The two files in this directory work together to enable voice control of i3.</p> <ul> <li> <p><code>i3wm.talon</code>: This file contains the Talon commands that a user can say to control i3. It uses the actions defined in <code>i3wm.py</code> to perform actions. For example, saying \"port 1\" will trigger the <code>user.i3wm_switch_to_workspace(number_small)</code> action, passing \"1\" as the argument. This switches i3 to workspace 1. The file also includes commands for moving, resizing, and managing windows, launching applications, and locking the screen. Some commands are generic such as \"win kill\" while others are specific to i3 such as \"reload i three config\". Note that the file uses <code>user.i3wm</code> tag to activate the commands, so you must enable this tag to use these commands.</p> </li> <li> <p><code>i3wm.py</code>: This file defines the Talon module, settings, context, and actions that are used by <code>i3wm.talon</code>. It sets the <code>user.i3wm</code> tag, defines settings such as the i3 config path and modifier key, and contains the implementation of the actions called from <code>i3wm.talon</code>. Most actions involve executing the <code>i3-msg</code> command to interact with the i3 window manager. For example, <code>i3wm_switch_to_workspace</code> calls <code>i3-msg workspace number 1</code> to switch to workspace 1. The file also includes actions to launch applications using the i3 mod key and execute shell commands.</p> </li> </ul>"},{"location":"apps/iterm/","title":"iterm","text":"<p>The <code>community/apps/iterm</code> directory contains configuration files for the iTerm2 terminal application on macOS. It provides Talon voice commands and integrates with other Talon modules for a more seamless experience.</p> <p>The primary files in this directory are:</p> <ul> <li> <p><code>iterm.py</code>: This Python file defines the core functionality for iTerm2 within the Talon ecosystem.</p> <ul> <li>It starts by creating a Talon <code>Context</code> and <code>Module</code> specifically for iTerm2.</li> <li>It defines the application as matching macOS and the bundle ID <code>com.googlecode.iterm2</code>.</li> <li>It includes an <code>EditActions</code> class that overrides <code>line_start</code> and <code>line_end</code> actions to use the <code>home</code> and <code>end</code> keys, respectively.</li> <li>It also includes a <code>UserActions</code> class that provides several terminal-related actions:<ul> <li><code>tab_jump</code>: Allows jumping to a specific tab using <code>cmd-number</code>.</li> <li><code>tab_final</code>: Jumps to the last tab with <code>cmd-9</code>.</li> <li><code>terminal_clear_screen</code>: Clears the terminal screen with <code>ctrl-l</code>.</li> <li>Commented out actions that appear to be related to file management are likely a work in progress, but are intended to provide file manipulation functionality directly in the terminal.</li> </ul> </li> </ul> </li> <li> <p><code>iterm.talon</code>: This Talon file enables a set of tags whenever iTerm2 is the active application. These tags enhance the user experience and are used to enable specific sets of commands.</p> <ul> <li>It declares the application as running on macOS and having the bundle ID <code>iterm2</code>, similar to the <code>iterm.py</code> file.</li> <li>It activates the <code>terminal</code>, <code>user.generic_unix_shell</code>, <code>user.git</code>, <code>user.kubectl</code>, <code>user.tabs</code>, and <code>user.readline</code> tags when iTerm2 is active.</li> <li>The comment <code># todo: filemanager support</code> indicates that file manager support via the <code>user.file_manager</code> tag is not yet fully implemented.</li> </ul> </li> </ul> <p>In essence, these files work together to provide a richer and more efficient experience when using iTerm2 with Talon. The Python file defines custom actions, while the Talon file activates relevant tags, enabling a more comprehensive set of voice commands and features for terminal interaction.</p>"},{"location":"apps/jetbrains/","title":"jetbrains","text":"<p>The <code>community/apps/jetbrains</code> directory contains files that enable Talon to interact with JetBrains IDEs.</p> <p>The core functionality is implemented in <code>jetbrains.py</code>. This file defines a <code>port_mapping</code> dictionary that associates the bundle IDs and executable names of various JetBrains IDEs with specific ports on the local machine. It uses this mapping to send commands to the IDE via HTTP requests.  The IDEs have a plugin, Voice Code Idea, installed that listens for these requests on its configured port and executes the desired actions.  A nonce is used to authenticate the requests, and the script attempts to find the nonce file in the temp directory or the user's home directory, using the port number as a suffix. The <code>send_idea_command</code> function is used to send the commands over HTTP and return the result.  The file also defines Talon actions for various IDE commands, including:</p> <ul> <li><code>idea(commands: str)</code>: Sends a comma-separated list of commands to the active JetBrains application.</li> <li><code>idea_grab(times: int)</code>: Copies the specified number of words to the left of the cursor, which can be useful for refactoring and code manipulation.</li> </ul> <p>The <code>jetbrains.py</code> file also sets up Talon contexts that match JetBrains applications, and defines Talon actions that are available within those contexts. These actions include:</p> <ul> <li><code>tab_next</code>, <code>tab_previous</code>, <code>tab_close</code>, <code>tab_reopen</code>: Actions for working with editor tabs.</li> <li><code>toggle_comment</code>: Toggles line comments in the editor.</li> <li><code>copy</code>, <code>cut</code>, <code>delete</code>, <code>paste</code>: Standard edit actions.</li> <li><code>find_next</code>, <code>find_previous</code>, <code>find</code>: Actions for searching in the editor.</li> <li><code>line_clone</code>, <code>line_swap_down</code>, <code>line_swap_up</code>: Actions for manipulating lines of code.</li> <li><code>indent_more</code>, <code>indent_less</code>: Actions for indenting and unindenting lines of code.</li> <li><code>select_line</code>, <code>select_word</code>, <code>select_all</code>: Actions for making selections in the editor.</li> <li><code>file_start</code>, <code>file_end</code>, <code>extend_file_start</code>, <code>extend_file_end</code>: Actions for moving the cursor to the start or end of the file.</li> <li><code>extend_word_left</code>, <code>extend_word_right</code>: Actions for extending the selection by words.</li> <li><code>jump_line(n: int)</code>: Jumps to a specific line number in the editor.</li> <li><code>filename() -&gt; str</code>: Returns the filename of the active file.</li> <li><code>tab_jump(number: int)</code>: Jumps to a specific tab number.</li> <li><code>extend_until_line(line: int)</code>: Extends the selection to the specified line.</li> <li><code>select_range(line_start: int, line_end: int)</code>: Selects a range of lines.</li> <li><code>extend_camel_left()</code>, <code>extend_camel_right()</code>, <code>camel_left()</code>, <code>camel_right()</code>: Actions for moving and extending selections by camel case words.</li> <li><code>command_search(command: str = \"\")</code>: Opens the command search popup.</li> <li><code>line_clone(line: int)</code>: Clones a specific line.</li> <li><code>multi_cursor_enable()</code>, <code>multi_cursor_disable()</code>, <code>multi_cursor_add_above()</code>, <code>multi_cursor_add_below()</code>, <code>multi_cursor_select_fewer_occurrences()</code>, <code>multi_cursor_select_more_occurrences()</code>, <code>multi_cursor_select_all_occurrences()</code>, <code>multi_cursor_add_to_line_ends()</code>: Actions for working with multiple cursors.</li> <li><code>split_window_vertically()</code>, <code>split_window_horizontally()</code>, <code>split_flip()</code>, <code>split_maximize()</code>, <code>split_reset()</code>, <code>split_clear()</code>, <code>split_clear_all()</code>, <code>split_next()</code>: Actions for splitting and managing the editor windows.</li> </ul> <p>The <code>jetbrains.talon</code> file defines Talon commands for various JetBrains IDE actions. It imports several tags (<code>user.line_commands</code>, <code>user.multiple_cursors</code>, <code>user.splits</code>, <code>user.tabs</code>, <code>user.command_search</code>) to enable the functionality in these categories. These commands leverage the actions defined in <code>jetbrains.py</code>. Here are some notable commands:</p> <ul> <li>Code Completion: <code>complete</code>, <code>perfect</code>, <code>smart</code> commands use the IDE's code completion features.</li> <li>Refactoring: Commands like <code>refactor</code>, <code>extract variable</code>, <code>extract method</code>, <code>refactor in line</code>, <code>refactor rename</code>, and <code>rename file</code> provide quick access to refactoring actions.</li> <li>Navigation: <code>go declaration</code>, <code>go implementation</code>, <code>go usage</code>, <code>go type</code>, <code>go test</code>, <code>go back</code>, and <code>go forward</code> enable easy navigation within the code.</li> <li>Search: <code>find (everywhere | all)</code>, <code>(search | find) class</code>, <code>(search | find) file</code>, <code>(search | find) path</code>, <code>(search | find) symbol</code>, and <code>recent</code> provide various ways to search for code.</li> <li>Surround and Templates: The <code>surround with</code> command wraps code with a template, and commands like <code>insert generated</code> and <code>insert template</code> insert generated code and templates, respectively.</li> <li>Recording: Commands like <code>toggle recording</code>, <code>change recordings</code>, and <code>play recording</code> allow recording and replaying macros.</li> <li>Bookmarks: Commands like <code>go mark</code>, <code>toggle mark</code>, <code>go next mark</code>, <code>go last mark</code> and the numbered versions of these are used to manipulate bookmarks.</li> <li>Folding: <code>expand deep</code>, <code>expand all</code>, <code>collapse deep</code>, and <code>collapse all</code> provide code folding actions.</li> <li>Miscellaneous: <code>go next (method | function)</code> and <code>go last (method | function)</code> allow navigation between methods/functions.  <code>clippings</code>, <code>copy path</code>, <code>copy reference</code>, and <code>copy pretty</code> provide ways to copy information to the clipboard.</li> <li>File Creation: <code>create sibling</code>, and <code>create file</code> provide ways to create new files.</li> <li>Task Management: Commands like <code>go task</code>, <code>go browser task</code>, <code>switch task</code>, <code>clear task</code>, and <code>configure servers</code> manage tasks within the IDE.</li> <li>Git / Github: Commands such as <code>git pull</code>, <code>git commit</code>, <code>git push</code>, <code>git log</code>, <code>git browse</code>, <code>git (gets | gist)</code>, <code>git (pull request | request)</code>, <code>git (view | show | list) (requests | request)</code>, <code>git (annotate | blame)</code>, and <code>git menu</code> provide Git and GitHub integration.</li> <li>Tool Windows: Commands like <code>toggle project</code>, <code>toggle find</code>, <code>toggle run</code>, <code>toggle debug</code>, <code>toggle events</code>, <code>toggle terminal</code>, <code>toggle git</code>, <code>toggle structure</code>, <code>toggle database</code>, <code>toggle database changes</code>, <code>toggle make</code>, <code>toggle to do</code>, <code>toggle docker</code>, <code>toggle favorites</code>, and <code>toggle last</code> manage tool window visibility.</li> <li>Pin/dock/float: Commands like <code>toggle pinned</code>, <code>toggle docked</code>, <code>toggle floating</code>, <code>toggle windowed</code>, and <code>toggle split</code> manage the layout of tool windows.</li> <li>Settings, not windows: Commands like <code>toggle tool buttons</code>, <code>toggle toolbar</code>, <code>toggle status [bar]</code>, and <code>toggle navigation [bar]</code> manage the IDE's UI.</li> <li>Active editor settings: Commands such as <code>toggle power save</code>, <code>toggle whitespace</code>, <code>toggle indents</code>, <code>toggle line numbers</code>, <code>toggle (bread crumbs | breadcrumbs)</code>, <code>toggle gutter icons</code>, <code>toggle wrap</code>, and <code>toggle parameters</code> manage editor-specific settings.</li> <li>Toggleable views: Commands such as <code>toggle fullscreen</code>, <code>toggle distraction [free mode]</code>, and <code>toggle presentation [mode]</code> toggle different IDE views.</li> <li>Additional toggles: <code>toggle comment</code> comments out code.</li> <li>Quick popups: <code>change scheme</code> opens the theme selection window.</li> <li>Javadoc/Definitions/Parameters: Commands like <code>(toggle | pop) (doc | documentation)</code>, <code>(pop deaf | toggle definition)</code>, <code>pop type</code>, and <code>pop parameters</code> open quick popups with related information.</li> <li>Debugging: Commands like <code>go breakpoints</code>, <code>toggle [line] breakpoint</code>, <code>toggle method breakpoint</code>, <code>run menu</code>, <code>run test</code>, <code>run test again</code>, <code>debug test</code>, <code>step over</code>, <code>step into</code>, <code>step smart</code>, <code>step to line</code>, and <code>continue</code> control the debugger.</li> <li>Grow/Shrink: <code>(grow | shrink) window right</code>, <code>(grow | shrink) window left</code>, <code>(grow | shrink) window up</code>, and <code>(grow | shrink) window down</code> resize tool windows.</li> <li>Error/Warning Navigation: <code>go next (error | air)</code>, <code>go last (error | air)</code>, <code>fix next (error | air)</code>, and <code>fix last (error | air)</code> provide ways to navigate and fix errors/warnings.</li> <li>Special Selects: <code>select less</code>, <code>select (more | this)</code> provide ways to adjust selection size.</li> <li>Line-Specific Commands: The <code>expand &lt;number&gt; until &lt;number&gt;</code>, <code>collapse &lt;number&gt; until &lt;number&gt;</code>, <code>paste &lt;number&gt; until &lt;number&gt;</code>, <code>refactor &lt;number&gt; until &lt;number&gt;</code>, and <code>clone &lt;number&gt;</code> commands use line numbers to specify the scope of the command.</li> <li>Find/Replace Commands: There are several find/replace commands that use line numbers or the currently selected text: <code>clear last &lt;user.text&gt;</code>, <code>clear next &lt;user.text&gt;</code>, <code>comment last &lt;user.text&gt;</code>, <code>comment next &lt;user.text&gt;</code>, <code>go last &lt;user.text&gt;</code>, <code>go next &lt;user.text&gt;</code>, <code>go &lt;number&gt; &lt;user.text&gt;</code>, <code>paste last &lt;user.text&gt;</code>, <code>paste next &lt;user.text&gt;</code>, <code>refactor &lt;number&gt; &lt;user.text&gt;</code>, <code>refactor last &lt;user.text&gt;</code>, <code>refactor next &lt;user.text&gt;</code>, <code>rename &lt;number&gt; &lt;user.text&gt;</code>, <code>rename next &lt;user.text&gt;</code>, <code>rename last &lt;user.text&gt;</code>, <code>complete &lt;number&gt; &lt;user.text&gt;</code>, <code>complete next &lt;user.text&gt;</code>, <code>complete last &lt;user.text&gt;</code>, <code>quick fix &lt;number&gt; &lt;user.text&gt;</code>, <code>quick fix next &lt;user.text&gt;</code>, <code>quick fix last &lt;user.text&gt;</code>, <code>replace last &lt;user.text&gt;</code>, <code>replace next &lt;user.text&gt;</code>, <code>follow &lt;number&gt; &lt;user.text&gt;</code>, <code>follow next &lt;user.text&gt;</code>, <code>follow last &lt;user.text&gt;</code>, <code>reference &lt;number&gt; &lt;user.text&gt;</code>, <code>reference next &lt;user.text&gt;</code>, <code>reference last &lt;user.text&gt;</code>, <code>select last &lt;user.text&gt;</code>, <code>select next &lt;user.text&gt;</code>, and <code>select &lt;number&gt; &lt;user.text&gt;</code>.</li> <li>Camel Case Navigation: <code>select camel left</code>, <code>select camel right</code>, <code>go camel left</code>, and <code>go camel right</code> allow navigation by camel case words.</li> <li>Blacken: The <code>blacken</code> command formats code using the <code>black</code> plugin.</li> </ul> <p>In summary, <code>jetbrains.py</code> provides the core logic for communication with JetBrains IDEs, while <code>jetbrains.talon</code> defines the specific voice commands that users can use to interact with the IDEs. Together, they enable comprehensive voice control of JetBrains IDEs.</p>"},{"location":"apps/kde_konsole/","title":"kde_konsole","text":"<p>The <code>community/apps/kde_konsole</code> directory contains files that provide Talon support for the KDE Konsole terminal application on Linux.</p> <p>The file <code>kde_konsole.py</code> defines the core logic for interacting with Konsole. It does the following:</p> <ul> <li>It establishes a Talon context that is active when the application name is \"konsole\".</li> <li>It defines actions in the <code>user</code> namespace, specifically <code>tab_jump(number)</code>, which allows the user to jump to a specific tab using <code>alt-number</code>.</li> <li>It defines actions in the <code>app</code> namespace, including <code>tab_open</code>, <code>tab_previous</code>, <code>tab_next</code>, and <code>tab_close</code> which provide basic tab management. It also defines <code>window_open</code> to open a new Konsole window.</li> <li>It overrides some default <code>edit</code> actions to match the keyboard shortcuts used by Konsole. For example, <code>paste</code> is mapped to <code>ctrl-shift-v</code>, and <code>copy</code> is mapped to <code>ctrl-shift-c</code>. It also remaps page up and page down to use shift.</li> </ul> <p>The file <code>kde_konsole.talon</code> is a Talon script that activates the functionality defined in <code>kde_konsole.py</code> and imports other relevant tags. Specifically:</p> <ul> <li>It sets up the context to only apply when the OS is Linux and the application name is \"konsole\".</li> <li>It activates the <code>terminal</code> tag, which enables commands defined in <code>terminal.talon</code>.</li> <li>It activates the <code>user.generic_unix_shell</code> tag, which provides generic Unix shell commands.</li> <li>It activates tags for specific command-line applications, such as <code>user.git</code> and <code>user.anaconda</code>. It also includes a commented-out tag for <code>user.kubectl</code>, that can be uncommented if that application is needed.</li> <li>It activates the <code>user.tabs</code> tag, which enables tab-related commands.</li> <li>It includes a comment about future support for file manager commands.</li> </ul> <p>These two files work together to provide a comprehensive set of commands for interacting with KDE Konsole using Talon. The <code>.py</code> file defines the actions and the <code>.talon</code> file specifies the context in which those actions are available.</p>"},{"location":"apps/keepassx/","title":"keepassx","text":"<p>The <code>community/apps/keepassx</code> directory contains configuration for the KeePassX password manager application.</p> <p>The file <code>keepassx_linux.talon</code> provides voice commands for common KeePassX actions. It is designed for use on Linux, as indicated by the file name. The commands are grouped into \"Database\" and \"Entries\" sections, reflecting the common usage of the application.</p> <p>Here is a breakdown of the commands:</p> <ul> <li> <p>Database:</p> <ul> <li><code>open database</code>: Opens a KeePassX database file (Ctrl+O).</li> <li><code>save database</code>: Saves the current database (Ctrl+S).</li> <li><code>close database</code>: Closes the current database (Ctrl+W).</li> <li><code>lock database</code>: Locks the database (Ctrl+L).</li> <li><code>quit</code>: Quits the application (Ctrl+Q).</li> </ul> </li> <li> <p>Entries:</p> <ul> <li><code>[add] new entry</code>: Creates a new entry (Ctrl+N). The \"add\" is optional.</li> <li><code>clone entry</code>: Clones the selected entry (Ctrl+K).</li> <li><code>(view | edit) entry</code>: Opens the view/edit window for the selected entry (Ctrl+E).</li> <li><code>delete entry</code>: Deletes the selected entry (Ctrl+D).</li> <li><code>copy user [name]</code>: Copies the username of the selected entry to the clipboard (Ctrl+B).</li> <li><code>copy password</code>: Copies the password of the selected entry to the clipboard (Ctrl+C).</li> <li><code>open (earl | url | link)</code>: Opens the URL of the selected entry in a browser (Ctrl+U).</li> <li><code>copy (earl | url | link)</code>: Copies the URL of the selected entry to the clipboard (Ctrl+Alt+U).</li> <li><code>find</code>: Opens the find dialog (Ctrl+F).</li> <li><code>find &lt;user.text&gt;</code>: Opens the find dialog and inserts the spoken text into the find field.</li> </ul> </li> </ul> <p>The file allows users to manage a KeePassX database and its entries using voice commands, improving accessibility and speed of use for this application.</p>"},{"location":"apps/kindle/","title":"kindle","text":"<p>The <code>community/apps/kindle</code> directory contains files that add support for controlling the Kindle application using Talon.</p> <p>The key files are:</p> <ul> <li> <p><code>kindle.talon</code>: This file defines the Talon app tag that is used to activate the Kindle context. It sets the <code>user.pages</code> tag, which is used by other files to implement actions for page navigation.</p> </li> <li> <p><code>kindle_win.py</code>: This file defines the Windows-specific context for the Kindle application. It implements actions for page navigation using <code>actions.key</code>, such as <code>page_next</code>, <code>page_previous</code>, and <code>page_jump</code>. These actions rely on the <code>user.pages</code> tag defined in <code>kindle.talon</code>.</p> </li> <li> <p><code>kindle.py</code>: This file defines the application definition for Kindle, specifying the criteria that Talon uses to recognize the Kindle application. This includes matching on the app name <code>Kindle</code> and the executable <code>kindle.exe</code> on Windows. A comment indicates that a macOS context is planned.</p> </li> </ul> <p>These files work together to provide a cohesive experience: <code>kindle.py</code> defines the application, <code>kindle.talon</code> sets the necessary tag, and <code>kindle_win.py</code> provides the actual implementation of the actions. The tag allows for a separation of concerns. For example, if the keyboard shortcuts for navigating pages in Kindle on macOS are different, a <code>kindle_mac.py</code> file could be created that also has the <code>user.pages</code> context, but different implementations for each action.</p>"},{"location":"apps/kubectl/","title":"kubectl","text":"<p>The <code>community/apps/kubectl</code> directory contains files that add voice control for the <code>kubectl</code> command-line tool.</p> <p>The main file is <code>kubectl.talon</code>, which defines the voice commands for interacting with <code>kubectl</code>. Most of the commands are straightforward mappings, for example saying \"cube get\" will insert <code>kubectl get</code>. Some commands like \"cube shell\" insert more complex text like <code>kubectl exec -it  -- /bin/bash</code>. A few commands are also mapped to keyboard shortcuts, like \"cube detach\" which is mapped to <code>ctrl-p ctrl-q</code>. Some commands use the lists defined in <code>kubectl.py</code>, for example \"cube {user.kubectl_action} [{user.kubectl_object}]\" will insert a command like <code>kubectl get pods</code>, where <code>{user.kubectl_action}</code> and <code>{user.kubectl_object}</code> are values from the lists.</p> <p><code>kubectl.py</code> defines the <code>user.kubectl</code> tag, which is used to enable these commands when the user is working in a terminal. It also defines two lists: <code>kubectl_action</code> and <code>kubectl_object</code>. These lists provide the possible values for the commands mentioned above that take user input. The <code>kubectl_action</code> list includes <code>get</code>, <code>delete</code>, <code>describe</code>, and <code>label</code>. The <code>kubectl_object</code> list includes common Kubernetes objects like <code>nodes</code>, <code>jobs</code>, <code>pods</code>, <code>namespaces</code>, <code>services</code>, <code>events</code>, <code>deployments</code>, <code>replicasets</code>, and <code>daemonsets</code>.</p>"},{"location":"apps/meld/","title":"meld","text":"<p>The <code>community/apps/meld</code> directory contains files that provide support for the Meld visual diff and merge tool.</p> <p>The file <code>meld.py</code> defines the application context and actions for Meld. It defines the app as matching the application name \"Visual diff and merge tool\" and executable <code>meld.exe</code> on Windows. It also defines Talon actions for:</p> <ul> <li><code>tab_open</code>: Opens a new tab (Ctrl+N).</li> <li><code>tab_previous</code>: Switches to the previous tab (Ctrl+Alt+PageUp).</li> <li><code>tab_next</code>: Switches to the next tab (Ctrl+Alt+PageDown).</li> <li><code>tab_jump(number)</code>: Jumps to a tab by number (Alt+number), if the number is less than 10.</li> </ul> <p>The file <code>meld.talon</code> defines Talon commands specific to Meld. It activates the <code>user.tabs</code> tag, enabling generic tab navigation commands from the user.tabs context.  It adds specific commands for:</p> <ul> <li>\"change next\":  Moves to the next change (Alt+Down).</li> <li>\"change (previous | last)\":  Moves to the previous change (Alt+Up).</li> </ul> <p>These files work together to provide a more natural and efficient way to use Meld with Talon. <code>meld.py</code> defines the application context and implements some basic tab actions, while <code>meld.talon</code> activates a tab tag and provides specific commands for navigating changes within the application.</p>"},{"location":"apps/mintty/","title":"mintty","text":"<p>The <code>community/apps/mintty</code> directory contains configuration for the Mintty terminal application on Windows.</p> <p>The primary file in this directory is <code>mintty_win.py</code>. This file defines a Talon context that is active when the application name is \"Terminal\" or \"mintty.exe\" on Windows. It adds several tags to the context: <code>terminal</code>, <code>user.generic_unix_shell</code>, <code>user.file_manager</code>, <code>user.git</code>, and <code>user.kubectl</code>. This suggests that this configuration is intended to provide a common set of actions for use when using Mintty as a terminal emulator or file manager.</p> <p>The file defines a setting <code>cygpath</code> that is used to convert between Cygwin paths and Windows paths. The <code>get_win_path</code> function uses this setting to call the <code>cygpath.exe</code> to perform the conversion. This is likely used to allow talon scripts to interact with the Windows filesystem using its native paths. This is important because the paths used in the terminal emulator itself are often different from Windows paths.</p> <p>The <code>EditActions</code> class remaps some of the common editing actions. This includes <code>paste</code> which is mapped to <code>shift-insert</code> and <code>copy</code> which is mapped to <code>ctrl-insert</code>. <code>delete_line</code> is mapped to <code>ctrl-u</code>.</p> <p>The <code>UserActions</code> class defines a number of user actions:</p> <ul> <li><code>file_manager_open_parent</code>: Inserts the command to change to the parent directory.</li> <li><code>file_manager_current_path</code>: Attempts to return the current path based on the window title by calling <code>get_win_path</code>.</li> <li><code>file_manager_show_properties</code>: This action is present, but does nothing in this context.</li> <li><code>file_manager_open_directory</code>: Inserts the command to open a specific directory.</li> <li><code>file_manager_select_directory</code>: Inserts the specified directory path.</li> <li><code>file_manager_new_folder</code>: Inserts the command to create a new folder.</li> <li><code>file_manager_open_file</code>: Inserts the command to open a file</li> <li><code>file_manager_select_file</code>: Inserts the specified file path.</li> <li><code>file_manager_open_volume</code>: Opens a directory by calling the <code>file_manager_open_directory</code> user action.</li> <li><code>terminal_list_directories</code>: Inserts the command to list the current directory.</li> <li><code>terminal_list_all_directories</code>: Inserts the command to list all the directories, including hidden ones.</li> <li><code>terminal_change_directory</code>: Inserts the command to change to a specific directory.</li> <li><code>terminal_change_directory_root</code>: Inserts the command to change to the root directory.</li> <li><code>terminal_clear_screen</code>: Clears the terminal screen.</li> <li><code>terminal_run_last</code>: Re-runs the last command.</li> <li><code>terminal_kill_all</code>: Sends a cancel signal to the terminal.</li> </ul> <p>Together, these actions provide a common way of interacting with the Mintty terminal as a command line interface, and as a way to navigate the file system.</p>"},{"location":"apps/nautilus/","title":"nautilus","text":"<p>The <code>community/apps/nautilus</code> directory contains configuration files for the Nautilus file manager on Linux. It provides Talon voice commands for common file management tasks.</p> <p>The core logic is in <code>nautilus.py</code>. It defines the app and context matching rules for Nautilus. It then implements several actions:</p> <ul> <li><code>app.tab_next</code> and <code>app.tab_previous</code>: Navigate between tabs using <code>ctrl-pagedown</code> and <code>ctrl-pageup</code> respectively.</li> <li><code>user.tab_jump</code>: Jump to a specific tab using <code>alt-number</code>.</li> <li><code>user.go_back</code> and <code>user.go_forward</code>: Navigate backward and forward in the file system using <code>alt-left</code> and <code>alt-right</code>.</li> <li><code>user.file_manager_open_parent</code>: Go to the parent directory using <code>alt-up</code>.</li> <li><code>user.file_manager_show_properties</code>: Display the properties dialog using <code>ctrl-i</code>.</li> <li><code>user.file_manager_open_directory</code>: Opens a specific directory by typing the path into the location bar using <code>ctrl-l</code> and then pressing enter.</li> <li><code>user.file_manager_new_folder</code>: Creates a new folder using <code>ctrl-shift-n</code> and optionally provides a name for the new folder.</li> <li><code>user.file_manager_terminal_here</code>: Opens a new terminal in the current directory, by copying the current path, and using that to launch the terminal.</li> </ul> <p>The file <code>nautilus.talon</code> enables the <code>user.tabs</code> and <code>user.file_manager</code> tags when the Nautilus app is active, allowing the actions in <code>nautilus.py</code> to be called by voice commands.</p>"},{"location":"apps/nitro_reader/","title":"nitro_reader","text":"<p>The <code>community/apps/nitro_reader</code> directory contains files that provide support for interacting with the Nitro Reader 5 application using Talon.</p> <p>The core functionality is split between two files: <code>nitro_reader_5.talon</code> and <code>nitro_reader_5.py</code>.</p> <p><code>nitro_reader_5.talon</code> is a Talon file that defines the application tag. This file is responsible for activating the <code>user.pages</code> and <code>user.tabs</code> tags when the Nitro Reader 5 application is active.</p> <pre><code>app: nitro_reader_five\n-\n# Set tags\ntag(): user.pages\ntag(): user.tabs\n</code></pre> <p><code>nitro_reader_5.py</code> is a Python file that defines the application definition and actions.</p> <p>The module defines the <code>nitro_reader_five</code> app using a combination of matching on the application name \"Nitro Reader 5\" and the executable name <code>nitropdfreader.exe</code>.</p> <pre><code>mod.apps.nitro_reader_five = \"\"\"\nos: windows\nand app.name: Nitro Reader 5\nos: windows\nand app.exe: /^nitropdfreader\\.exe$/i\n\"\"\"\n</code></pre> <p>A context is created that matches when the <code>nitro_reader_five</code> app is active.</p> <pre><code>ctx.matches = \"\"\"\napp: nitro_reader_five\n\"\"\"\n</code></pre> <p>The file also defines actions within the <code>app</code> and <code>user</code> action classes. The <code>app</code> actions include: *   <code>tab_open()</code> which simulates <code>ctrl-shift-o</code>, opening a new tab.</p> <p>The <code>user</code> actions include the following functions that implement page navigation: *   <code>page_next()</code> which simulates the <code>right</code> arrow key for next page. *  <code>page_previous()</code> which simulates the <code>left</code> arrow key for previous page. *  <code>page_jump(number: int)</code> which simulates <code>ctrl-g</code> to bring up the \"go to page\" dialog, inserts the target page number, and then simulates <code>enter alt:2</code> to activate it. * <code>page_final()</code> which simulates the <code>end</code> key to go to the last page.</p>"},{"location":"apps/notepad/","title":"notepad","text":"<p>The <code>community/apps/notepad</code> directory contains the Talon files for controlling the Windows Notepad application.</p> <p>The file <code>notepad.talon</code> defines the application tag, <code>app: notepad</code>, which is used to activate the context defined in <code>notepad.py</code>. It also tags the context with <code>user.tabs</code> and <code>user.find_and_replace</code>. These tags enable other user-defined features that are associated with these tags, including tab management and the find-and-replace UI.</p> <p>The file <code>notepad.py</code> sets up the Talon context for the Notepad application. It defines the application using the <code>mod.apps.notepad</code> setting, which is matched on Windows when <code>app.exe</code> is <code>notepad.exe</code>. The context uses <code>ctx.matches</code> to match the <code>app: notepad</code> tag, and then defines a <code>win_actions</code> class. The <code>filename()</code> function extracts the filename from the window title, returning an empty string if there is no filename (i.e. it's a new, unsaved file).</p>"},{"location":"apps/notepad%2B%2B/","title":"notepad++","text":"<p>The <code>community/apps/notepad++</code> directory contains configuration for the Notepad++ application.</p> <p>The file <code>notepad++_win.py</code> defines Talon bindings for Notepad++ on Windows.</p> <p>It starts by defining an application context that matches when the application name is \"Notepad++ : a free (GNU) source code editor\", \"Notepad++ : a free (GPL) source code editor\" or the executable is <code>notepad++.exe</code>. It then applies the tags <code>user.find_and_replace</code>, <code>user.line_commands</code>, and <code>user.tabs</code> to this context. These tags enable functionality in other files such as <code>find_and_replace.py</code> and <code>line_commands.py</code>.</p> <p>This file defines several actions, most of which emulate default Notepad++ keyboard shortcuts: *   <code>tab_previous</code> and <code>tab_next</code> navigate between tabs using <code>ctrl-pageup</code> and <code>ctrl-pagedown</code> respectively. *   <code>toggle_comment</code> comments or uncomments a line or selection using <code>ctrl-q</code>. *   <code>line_clone</code> duplicates the current line using <code>ctrl-d</code>. *   <code>line_swap_up</code> and <code>line_swap_down</code> move the current line up or down using <code>ctrl-shift-up</code> and <code>ctrl-shift-down</code> respectively. *   <code>indent_more</code> and <code>indent_less</code> indent or outdent the current line or selection with <code>tab</code> and <code>shift-tab</code>. *   <code>jump_line</code> opens the \"Go To Line\" dialog, inserts the given line number, and presses enter, effectively jumping to that line. *   <code>find_next</code> and <code>find_previous</code> will find the next or previous occurrence of the search term with <code>enter</code> and <code>shift-enter</code> respectively. *   <code>filename</code> extracts the filename from the window title. *   <code>select_next_occurrence</code> and <code>select_previous_occurrence</code> find a given term, select it, and find the next or previous occurrence. *   <code>tab_jump</code> jumps to a specific tab by pressing ctrl-keypad followed by the number of the tab. *  <code>tab_final</code> is defined, but it doesn't actually work in Notepad++. *  <code>find_everywhere</code>, <code>find_toggle_match_by_case</code>, <code>find_toggle_match_by_word</code>, <code>find_toggle_match_by_regex</code>, <code>replace</code>, <code>replace_everywhere</code>, <code>replace_confirm</code>, <code>replace_confirm_all</code> emulate the equivalent functionality of the Notepad++ find and replace dialog.</p>"},{"location":"apps/obsidian/","title":"obsidian","text":"<p>The <code>community/apps/obsidian</code> directory contains files that configure Talon for use with the Obsidian application.</p> <p>The file <code>obsidian.py</code> defines an application context for Obsidian, which is identified by the application name \"Obsidian\". It also sets the default code language to \"markdown\" when the Obsidian app is active and the <code>user.code_language_forced</code> tag is not set. This ensures that code-related commands use markdown syntax, and it can be overridden when needed.</p> <p>The file <code>obsidian.talon</code> activates the <code>user.tabs</code> tag when the Obsidian app is active. This indicates that commands related to tab management should be available in the Obsidian context.</p>"},{"location":"apps/okular/","title":"okular","text":"<p>The <code>community/apps/okular</code> directory contains files to support the Okular document viewer application.</p> <p>The file <code>okular.talon</code> is a Talon file that sets the <code>user.pages</code> tag when Okular is the active application.</p> <p>The file <code>okular.py</code> defines the Okular application and implements the <code>user.pages</code> actions. It defines the application for Windows and Linux based on the application's name. The <code>UserActions</code> class provides implementations for the following actions:</p> <ul> <li><code>page_current()</code>: Gets the current page number using <code>ctrl-g</code> to open the page number dialog, extracting the selected text, and dismissing the dialog.</li> <li><code>page_next()</code>: Navigates to the next page by pressing <code>l</code>.</li> <li><code>page_previous()</code>: Navigates to the previous page by pressing <code>h</code>.</li> <li><code>page_jump(number: int)</code>: Navigates to a specific page by opening the jump to page dialog with <code>ctrl-g</code>, inserting the page number, and pressing <code>enter</code>.</li> <li><code>page_final()</code>: Jumps to the last page using <code>ctrl-end</code>.</li> </ul>"},{"location":"apps/opera/","title":"opera","text":"<p>The <code>community/apps/opera</code> directory contains files that add support for the Opera web browser to Talon. This support is implemented through a combination of <code>.py</code> files that define actions for the application, and a <code>.talon</code> file that activates those actions in the correct context.</p> <p>The <code>opera.py</code> file defines the application matchers for Opera. These matchers are used by Talon to determine when the following actions should be activated. It specifies that the following actions should be active when the app name is \"Opera\" or \"Opera Internet Browser\" on all platforms, when the app bundle is <code>com.operasoftware.Opera</code> on macOS, when the app executable matches <code>opera.exe</code> on Windows, and when the app executable is <code>opera</code> on Linux.</p> <p>The <code>opera.talon</code> file enables the <code>browser</code> and <code>user.tabs</code> tags when the active application is Opera. This allows the user to use browser navigation commands and tab-related commands when using Opera.</p> <p>The <code>opera_mac.py</code> file defines the actions specific to Opera on macOS. It defines a set of actions in the <code>UserActions</code> class, such as <code>tab_duplicate</code>, <code>tab_final</code>, and <code>tab_close_wrapper</code>. Additionally it defines some actions in the <code>AppActions</code> class, specifically <code>tab_next</code> and <code>tab_previous</code> which use keyboard shortcuts for tab navigation. There are also some overridden <code>BrowserActions</code> such as <code>go_back</code>, <code>go_forward</code>, <code>show_downloads</code>, <code>show_extensions</code>, <code>show_history</code>, <code>focus_page</code> and <code>reload_hard</code> which call built-in Talon actions or call keyboard shortcuts.  Note that some actions such as <code>bookmark_tabs</code> and <code>go_home</code> are not implemented.</p> <p>The <code>opera_win_linux.py</code> file defines the actions specific to Opera on Windows and Linux. Like the macOS version, it defines a set of actions in the <code>UserActions</code> class, such as <code>tab_duplicate</code>, <code>tab_jump</code>, <code>tab_final</code>, and <code>tab_close_wrapper</code>. The <code>AppActions</code> class includes actions for <code>tab_next</code> and <code>tab_previous</code> with platform specific keyboard shortcuts. It also overrides some <code>BrowserActions</code>, such as <code>go_back</code>, <code>go_forward</code>, <code>bookmarks</code>, <code>show_downloads</code>, <code>show_extensions</code>, <code>focus_page</code> and <code>reload_hard</code>. Note that some actions such as <code>bookmarks_bar</code>, <code>bookmark_tabs</code> and <code>go_home</code> are not implemented.</p> <p>The <code>tab_duplicate</code> action in both <code>opera_mac.py</code> and <code>opera_win_linux.py</code> works by focusing the address bar, copying the URL, opening a new tab, pasting the URL, and pressing enter. This approach ensures that the current tab's URL is duplicated, even if it was manually edited in the address bar before the command was called.</p>"},{"location":"apps/orion/","title":"orion","text":"<p>The <code>community/apps/orion</code> directory contains configuration files to support the Orion browser in Talon.</p> <p>The <code>orion.py</code> file defines the Talon context, module, and actions specific to the Orion browser on macOS. It specifies that the context is active when the application with the bundle ID <code>com.kagi.kagimacOS</code> is running.  It defines the following actions:</p> <ul> <li><code>user.browser_open_address_in_new_tab()</code>: Opens the current address in a new tab, mapped to <code>cmd-enter</code>.</li> <li><code>browser.bookmark_tabs()</code>: This action is not implemented because there is no default shortcut for this in Orion.</li> <li><code>browser.show_clear_cache()</code>: Opens the clear cache menu using <code>cmd-alt-e</code>.</li> <li><code>browser.reload_hard()</code>: Performs a hard reload using <code>cmd-alt-r</code>.</li> <li><code>browser.show_downloads()</code>: Opens the downloads using <code>cmd-alt-l</code>.</li> <li><code>browser.show_extensions()</code>: Opens the extensions using <code>cmd-shift-x</code>.</li> <li><code>actions.overview_tabs()</code>: Toggles the tab overview using <code>cmd-shift-\\</code>.</li> </ul> <p>The <code>orion.talon</code> file defines the Talon grammar for the Orion browser. It activates the <code>browser</code> and <code>user.tabs</code> tags when the Orion application is active. It also adds a voice command: <code>tab overview [open | close]</code> which triggers the <code>user.overview_tabs()</code> action defined in <code>orion.py</code>.</p>"},{"location":"apps/outlook/","title":"outlook","text":"<p>The <code>community/apps/outlook</code> directory contains Talon scripts for interacting with Outlook, Microsoft's email and calendaring application. There are two files in this directory, each designed for a specific operating system.</p> <ul> <li> <p><code>outlook_web.talon</code> provides commands for the web version of Outlook. It is triggered when the window title contains \"Outlook\" and the OS is Linux, using the tag <code>browser</code>. It includes commands for writing, sending, and managing emails, as well as navigating different parts of the Outlook web interface using keyboard shortcuts. For example, \"new message\" triggers <code>key(n)</code>, and \"send this message\" triggers <code>key(alt-s)</code>. This file provides a very complete set of shortcuts based on the official Outlook keyboard shortcuts.</p> </li> <li> <p><code>outlook_win.talon</code> provides commands for the Windows desktop application. It is triggered when the application name is \"Outlook\" and the OS is Windows. It has a shorter list of commands than <code>outlook_web.talon</code>, covering basic actions like archiving, creating new emails, accessing the calendar, and replying to messages.  For example, \"archive\" triggers <code>key(alt h o 1)</code>, and \"new e-mail\" triggers <code>key(ctrl-n)</code>.</p> </li> </ul>"},{"location":"apps/powershell/","title":"powershell","text":"<p>The <code>community/apps/powershell</code> directory contains files that integrate Talon with the Windows PowerShell, enabling voice control for common terminal and file management tasks.</p> <p>The file <code>README.md</code> explains how to configure PowerShell to display the current path in the window title. It provides a PowerShell function that can be added to your PowerShell profile to achieve this. This is important because the Talon script <code>powershell_win.py</code> uses the window title to determine the current directory. The <code>README.md</code> also mentions a setting, <code>user.powershell_always_refresh_title</code>, that controls whether the window title is updated after every directory change.</p> <p>The core logic for Talon integration is in <code>powershell_win.py</code>. This file defines a Talon context that activates when the application is Windows PowerShell or Windows Terminal and the window title contains \"PowerShell\". It maps Talon commands to actions:</p> <ul> <li><code>edit.delete_line</code>: bound to the escape key.</li> <li><code>user.file_manager_refresh_title</code>: Inserts the PowerShell command to update the window title to show the current path and executes the command.</li> <li><code>user.file_manager_open_parent</code>: Changes the directory to the parent directory using <code>cd ..</code> and updates the title if <code>user.powershell_always_refresh_title</code> is true.</li> <li><code>user.file_manager_current_path</code>: Extracts the current path from the window title, removing prefixes such as \"Administrator: \" or \"Windows PowerShell: \". It also handles path remapping and exclusion based on <code>directories_to_remap</code> and <code>directories_to_exclude</code> variables (which are not populated in this file).</li> <li><code>user.file_manager_open_directory</code>: Navigates to the given directory using <code>cd</code> and updates the title if <code>user.powershell_always_refresh_title</code> is true.</li> <li><code>user.file_manager_select_directory</code>: Inserts the given directory path.</li> <li><code>user.file_manager_new_folder</code>: Inserts the command to create a new folder using <code>mkdir</code>.</li> <li><code>user.file_manager_open_file</code>: Inserts the command to execute the given file using <code>./</code>.</li> <li><code>user.file_manager_select_file</code>: Inserts the given file path.</li> <li><code>user.file_manager_open_volume</code>: Navigates to the given volume using <code>cd</code>.</li> </ul> <p>The file <code>powershell_win.talon</code> defines the Talon tags that activate the functionality in <code>powershell_win.py</code>, as well as making other commands available. It specifies that the code should activate on Windows when the application is either \"Windows PowerShell\" or \"powershell.exe\". It then activates the <code>terminal</code>, <code>user.generic_windows_shell</code>, <code>user.git</code>, <code>user.anaconda</code>, and <code>user.file_manager</code> tags, providing access to commands defined in other parts of the Talon configuration.</p>"},{"location":"apps/protonmail/","title":"protonmail","text":"<p>This directory contains Talon scripts for interacting with the ProtonMail web application.</p> <p>The file <code>protonmail.talon</code> defines a variety of commands for navigating and managing emails, as well as interacting with the composer, contacts, and general application functions. </p> <p>The script is triggered when the active window title contains \"ProtonMail\". It provides commands for:</p> <ul> <li>General application actions: Opening help, focusing on the search bar, confirming active elements, closing active elements, and opening the command palette.</li> <li>Composer actions: Creating a new message, sending, and saving messages.</li> <li>Mail navigation: Jumping to different inboxes (inbox, drafts, sent, starred, archive, spam, trash). It also includes commands for navigating between messages (previous, next, newer, older) and exiting or entering a message.</li> <li>Threadlist actions: Selecting and deselecting messages, marking messages as read or unread, starring messages, and moving messages to various folders (inbox, trash, archive, spam).</li> <li>Mail actions: Replying, replying all, and forwarding.</li> <li>Contact list actions: Navigating contacts, entering a contact, and deleting a contact.</li> <li>Contact detail actions: Exiting and saving contact details.</li> </ul> <p>The script uses common Talon commands, such as <code>key()</code> to send keystrokes to the application. Many commands use a sequence of keys to accomplish an action; for example, the command to \"jump to inbox\" sends <code>key(g)</code> followed by <code>key(i)</code>.</p>"},{"location":"apps/rstudio/","title":"rstudio","text":"<p>The <code>community/apps/rstudio</code> directory contains files that provide support for the RStudio application.</p> <p>The most important file is <code>rstudio_mac.talon</code>. This Talon file defines a variety of commands for interacting with the RStudio IDE on macOS. It includes commands for running code, navigating the interface, formatting code, and other actions commonly performed while working in RStudio. The file provides a comprehensive set of keyboard shortcuts that are mapped to voice commands using Talon.</p> <p>Here's a breakdown of the functionality provided in <code>rstudio_mac.talon</code>:</p> <ul> <li>Code Execution: Commands for running code such as <code>run that</code>, <code>run document</code>, <code>run from top</code>, etc. These map to keyboard shortcuts for executing code within the RStudio environment.</li> <li>Navigation and Formatting: Commands like <code>jump back</code>, <code>close all tabs</code>, <code>indent lines</code>, <code>toggle comment</code>, etc., are provided for navigating the editor and formatting code quickly.</li> <li>Folding: Commands for collapsing and expanding code sections such as <code>fold that</code> and <code>unfold all</code>.</li> <li>Find and Replace: Commands for searching and replacing text within the editor such as <code>find and replace</code>, <code>find next</code>, and <code>run replace</code>.</li> <li>Navigation of Panels: Commands to navigate to different RStudio panels such as <code>go to console</code>, <code>go to help</code>, <code>go to git</code>, and many others.</li> <li>Devtools and Package Management: Commands for building, loading, testing and documenting R packages using <code>dev tools build</code>, <code>dev tools load all</code>, <code>dev tools document</code>, etc.</li> <li>Debugging: Commands to aid in debugging code, like <code>toggle breakpoint</code>, <code>debug next</code>, <code>debug step into (function | funk)</code>, etc.</li> <li>Git/SVN: Commands for interacting with Git, such as <code>run git diff</code> and <code>run git commit</code>.</li> <li>Other Shortcuts: The file also includes a collection of commented-out keyboard shortcuts that could be enabled if desired.</li> </ul> <p>In summary, <code>rstudio_mac.talon</code> provides a set of voice commands that mirror the keyboard shortcuts that RStudio users frequently employ. This allows users to control the IDE with their voice, speeding up their workflows.</p>"},{"location":"apps/safari/","title":"safari","text":"<p>The <code>community/apps/safari</code> directory contains files that add support for the Safari browser to Talon.</p> <p>The core logic is in <code>safari.py</code>. This file defines a Talon module and context for Safari. It specifies that the module applies to the Safari app using its bundle identifiers. The <code>UserActions</code> class defines the <code>browser_open_address_in_new_tab()</code> action which opens the current address in a new tab. The <code>BrowserActions</code> class defines several browser-specific actions, including:</p> <ul> <li><code>address()</code>: Retrieves the current address from the address bar. It attempts to get the address via the accessibility API first, and falls back to AppleScript if that fails.</li> <li><code>bookmark_tabs()</code>: Raises a <code>NotImplementedError</code> because Safari does not have a default shortcut.</li> <li><code>show_clear_cache()</code>: Raises a <code>NotImplementedError</code> because Safari does not have a shortcut.</li> <li><code>reload_hard()</code>: Performs a hard reload using <code>cmd-alt-r</code>.</li> <li><code>show_downloads()</code>: Opens the downloads window using <code>cmd-alt-l</code>.</li> <li><code>show_extensions()</code>: Opens the extensions settings using <code>cmd-, tab:8 space</code>.</li> </ul> <p><code>safari.talon</code> is a simple Talon file that applies the <code>browser</code> and <code>user.tabs</code> tags when Safari is the active application. These tags likely enable other parts of the Talon configuration.</p>"},{"location":"apps/signal/","title":"signal","text":"<p>The <code>community/apps/signal</code> directory contains configuration for the Signal application, specifically for Linux.</p> <p>The file <code>signal_linux.talon</code> provides voice commands for the Signal application on Linux. It maps spoken phrases to keyboard shortcuts, enabling hands-free control.</p> <p>Here's a breakdown of the commands:</p> <ul> <li> <p>Navigation: These commands allow the user to navigate through the Signal application.  Examples include moving between sections, conversations, and unread messages, as well as opening preferences or the search function.</p> </li> <li> <p>Messages: This group of commands lets the user interact with messages, such as sending replies, reacting, saving attachments, and deleting messages.</p> </li> <li> <p>Composer: These commands relate to the message composition area, enabling actions such as sending a message, attaching files, removing link previews or attachments, and expanding the chat window.</p> </li> </ul> <p>In summary, this file provides a comprehensive set of voice commands to control the Signal application on Linux.</p>"},{"location":"apps/slack/","title":"slack","text":"<p>The <code>community/apps/slack</code> directory contains files that provide Talon voice control for the Slack application. It includes platform-specific configurations for macOS, Windows, and Linux.</p> <p>The core logic for identifying and activating the Slack application is in <code>slack.py</code>. This file defines the application context for Slack, specifying its names and bundle identifiers across different operating systems. It also provides a basic <code>line_insert_down</code> action for all platforms.</p> <p>The remaining files in this directory define actions and commands specific to each operating system. <code>slack_win.py</code> and <code>slack_mac.py</code> contain Python code that define actions based on the <code>user</code> action class to manipulate Slack. <code>slack_win.talon</code> and <code>slack_mac.talon</code> provide the voice commands that will trigger those actions.</p> <p>Here is a summary of the files and how they work together:</p> <ul> <li> <p><code>slack.py</code>: This file defines the application context for Slack and provides a basic <code>line_insert_down</code> action.</p> </li> <li> <p><code>slack_win.py</code>: Defines the <code>user</code> action class for Windows and Linux, providing actions to navigate workspaces, channels, and messaging features. These actions are invoked by voice commands in <code>slack_win.talon</code>.</p> </li> <li> <p><code>slack_mac.talon</code>: Contains Talon commands for macOS, utilizing the <code>user</code> actions defined in <code>slack_mac.py</code>, and also defines many more commands, such as for formatting, calls, and sidebar navigation. It defines a <code>messaging</code> tag for use in other files.</p> </li> <li> <p><code>slack_win.talon</code>:  Contains Talon commands for Windows and Linux, utilizing the <code>user</code> actions defined in <code>slack_win.py</code>. It is similar to <code>slack_mac.talon</code> and defines a <code>messaging</code> tag for use in other files.</p> </li> <li> <p><code>slack_mac.py</code>: Defines the <code>user</code> action class for macOS, providing actions to navigate workspaces, channels, and messaging features. These actions are invoked by voice commands in <code>slack_mac.talon</code>.</p> </li> </ul> <p>In summary, these files provide a complete set of tools to control Slack through voice commands on macOS, Windows, and Linux. The <code>.py</code> files define the actions, while the <code>.talon</code> files provide the voice commands to trigger those actions. The <code>messaging</code> tag is used in both the <code>slack_win.talon</code> and <code>slack_mac.talon</code> files, indicating that many of the commands are related to messaging.</p>"},{"location":"apps/stata/","title":"stata","text":"<p>The <code>community/apps/stata</code> directory contains files that add support for the Stata application in Talon.</p> <p><code>stata.py</code> defines the application and provides a way to set the language for code contexts. It defines the <code>stata</code> application using <code>mod.apps.stata</code> by matching the application name and executable on Windows. It also defines a <code>code</code> action that returns the language \"stata\".</p> <p><code>stata_do_file_editor.talon</code> defines Talon commands specific to the Stata Do-file editor. These commands use the <code>win.title</code> to match the Do-file editor window. The commands include <code>do this</code>, <code>do line</code>, <code>do (all | file)</code>, <code>do way up</code>, and <code>do way down</code>, all of which execute the selected or edited text by sending the <code>ctrl-d</code> hotkey to Stata. These commands rely on standard Talon commands like <code>edit.select_line()</code>, <code>edit.select_all()</code>, <code>edit.copy()</code>, <code>edit.extend_file_start()</code>, and <code>edit.extend_file_end()</code>.</p>"},{"location":"apps/sumatrapdf/","title":"sumatrapdf","text":"<p>This directory contains configuration files for the SumatraPDF application, enabling users to control it with voice commands via Talon.</p> <p>The file sumatrapdf.talon defines the application and the tags that should be enabled when the application is active. This file specifies that the <code>user.pages</code> and <code>user.tabs</code> tags should be enabled.</p> <p>The file sumatrapdf.py defines the application context and the actions that can be performed when SumatraPDF is the active application.  This file defines the application using <code>mod.apps.sumatrapdf</code> which matches when the window title is \"SumatraPDF\" and the executable is <code>sumatrapdf.exe</code>.</p> <p>It implements the following actions:</p> <ul> <li><code>app.tab_open</code>: Opens a new tab using <code>ctrl-o</code>.</li> <li><code>edit.zoom_in</code>: Zooms in using the <code>+</code> key.</li> <li><code>edit.zoom_out</code>: Zooms out using the <code>-</code> key.</li> <li><code>user.page_current</code>: Gets the current page number by opening the go to page dialog, copying the current page from the dialog, closing the dialog and returning the page number as an integer.</li> <li><code>user.page_next</code>: Navigates to the next page using the <code>n</code> key.</li> <li><code>user.page_previous</code>: Navigates to the previous page using the <code>p</code> key.</li> <li><code>user.page_jump</code>: Jumps to a specific page by opening the go to page dialog, inserting the number, and pressing <code>enter</code>.</li> <li><code>user.page_final</code>: Navigates to the final page using the <code>end</code> key.</li> <li><code>user.page_rotate_right</code>: Rotates the page to the right using <code>shift-ctrl-keypad_plus</code>.</li> <li><code>user.page_rotate_left</code>: Rotates the page to the left using <code>shift-ctrl-keypad_minus</code>.</li> <li><code>user.tab_jump</code>: Jumps to a specific tab (1-8) using <code>alt-{number}</code>.</li> <li><code>user.tab_final</code>: Jumps to the final tab using <code>alt-9</code>.</li> </ul> <p>These files together allow the user to control SumatraPDF through voice commands by implementing actions for the <code>app</code>, <code>edit</code>, and <code>user</code> namespaces. They are enabled when SumatraPDF is the active application.</p>"},{"location":"apps/talon/","title":"talon","text":"<p>The <code>community/apps/talon</code> directory contains applications that provide additional functionality when interacting with Talon.</p> <p>The <code>talon_repl</code> subdirectory provides functionality for interacting with the Talon REPL (Read-Eval-Print Loop). The <code>talon_repl.py</code> file defines a Talon application that is matched when a window title contains either \"Talon - REPL\" or \".talon/bin/repl\". This file also sets the code language to Python for this application. The <code>talon_repl.talon</code> file defines voice commands available within the <code>talon_repl</code> application, and adds the tags <code>user.talon_python</code> and <code>user.readline</code>. Notably, it includes a number of debugging commands that can be used to inspect the state of the Talon runtime, such as commands to print details about Talon actions, lists, tags, settings, modes, scopes, running apps, and windows. These commands use the <code>sim</code> command to send commands to the REPL and the <code>user.talon_pretty_print</code> action to format the output.</p> <p>The <code>talon_debug_window</code> subdirectory contains files that enable specific functionality within the Talon debug window. The <code>talon_debug_window.py</code> file defines a Talon application that is matched by the title \"Talon Debug\". This allows Talon to understand when the debug window is active, so that the commands defined in <code>talon_debug_window.talon</code> can be used. The <code>talon_debug_window.talon</code> file defines voice commands that are specifically available when the Talon debug window is in focus. These commands enable dictation of key combinations and interaction with various Talon internal structures, including actions, lists, captures, settings, and applications. This file also refers to the <code>user.talon_populate_lists</code> tag, which populates lists related to Talon internals. This tag is disabled by default, because of performance concerns.</p>"},{"location":"apps/talon/talon_debug_window/","title":"talon_debug_window","text":"<p>The <code>community/apps/talon/talon_debug_window</code> directory contains files that enable specific functionality within the Talon debug window. This window is part of the Talon beta and is used for advanced debugging and exploration of the Talon environment.</p> <p>The file <code>talon_debug_window.py</code> defines the app for use in Talon. It specifies that the window can be identified by its title \"Talon Debug\" and the Talon app itself. It also uses different criteria to identify the app on macOS vs Windows. This definition allows Talon to understand when the debug window is active, so that the commands defined in <code>talon_debug_window.talon</code> can be used.</p> <p>The file <code>talon_debug_window.talon</code> contains Talon commands that are specifically available when the Talon debug window is in focus. These commands enable dictation of key combinations and interaction with various Talon internal structures (actions, lists, captures, settings, and applications). The file also refers to the <code>user.talon_populate_lists</code> tag, which is disabled by default, because of performance concerns. When enabled, this tag populates lists related to Talon internals, which makes them available for use via the commands defined in this file. However, the comments warn that it may introduce latency, particularly with Dragon or less powerful hardware.</p>"},{"location":"apps/talon/talon_repl/","title":"talon_repl","text":"<p>The <code>community/apps/talon/talon_repl</code> directory provides functionality for interacting with the Talon REPL (Read-Eval-Print Loop). It defines a Talon application, and a set of commands for inspecting and manipulating the Talon runtime environment.</p> <p>The file <code>talon_repl.py</code> defines a Talon application named <code>talon_repl</code>. This application is matched when a window title contains either \"Talon - REPL\" or \".talon/bin/repl\". Additionally, this file sets the code language for this application to Python.</p> <p>The file <code>talon_repl.talon</code> defines the voice commands available within the <code>talon_repl</code> application. It also adds the tags <code>user.talon_python</code> and <code>user.readline</code>, which are used to enable Python-specific and readline-specific features. Notably, it includes a number of debugging commands which can be used to inspect the state of the Talon runtime. These commands use the <code>sim</code> command to send commands to the REPL and the <code>user.talon_pretty_print</code> action to format the output. The debug commands are:</p> <ul> <li><code>test last</code>: Repeats the last command.</li> <li><code>test &lt;phrase&gt;</code>: Repeats a given phrase.</li> <li><code>test numb &lt;number_small&gt;</code>: Repeats a command from history by index.</li> <li><code>debug action {user.talon_actions}</code>: Prints details about a given Talon action. Note: this command and the following commands depend on the <code>user.talon_populate_lists</code> tag, which is commented out by default.</li> <li><code>debug list {user.talon_lists}</code>: Prints the contents of a given Talon list.</li> <li><code>debug tags</code>: Prints all active tags.</li> <li><code>debug settings</code>: Prints all Talon settings.</li> <li><code>debug modes</code>: Prints the current Talon modes.</li> <li><code>debug scope {user.talon_scopes}</code>: Prints a given scope.</li> <li><code>debug running apps</code>: Prints a list of currently running apps.</li> <li><code>debug all windows</code>: Prints a list of all windows.</li> <li><code>debug {user.running} windows</code>: Prints debug information about windows belonging to a given app.</li> </ul>"},{"location":"apps/taskwarrior/","title":"taskwarrior","text":"<p>The <code>community/apps/taskwarrior</code> directory contains a single file, <code>taskwarrior_linux.talon</code>, which provides voice commands for interacting with the Taskwarrior command-line task management application on Linux. </p> <p>The file defines a series of voice commands that map to Taskwarrior commands. Here is a breakdown of the most important commands:</p> <ul> <li><code>task version</code>: Executes <code>task --version</code> and returns the version of Taskwarrior installed.</li> <li><code>task commands</code>: Executes <code>task commands</code> and returns a list of all Taskwarrior commands.</li> <li><code>task help</code>: Executes <code>task help</code> and displays the Taskwarrior help information.</li> <li><code>task list</code>: Executes <code>task list</code> and shows the list of tasks. There are several variants:<ul> <li><code>task list orphans</code>: Executes <code>task project: list</code> and shows a list of tasks that don't belong to a project.</li> <li><code>task list untagged</code>: Executes <code>task tags.none: list</code> and shows a list of tasks that don't have tags.</li> <li><code>task list &lt;user.text&gt;</code>: Executes <code>task list {text}</code> where <code>{text}</code> is a spoken word or phrase, allowing users to filter the task list.</li> <li><code>task list project</code>: Executes <code>task list project:</code> which allows a user to say the project to list.</li> <li><code>task list project &lt;user.text&gt;</code>: Executes <code>task list project:{text}</code> where <code>{text}</code> is a spoken project name to list.</li> </ul> </li> <li><code>task add</code>: Executes <code>task add</code> to prepare for adding a new task.</li> <li><code>task add &lt;user.text&gt;</code>: Executes <code>task add {text}</code> where <code>{text}</code> is a spoken description of the new task.</li> <li><code>task undo</code>: Executes <code>task undo</code> to undo the last change.</li> <li><code>(tasks | task next)</code>: Executes <code>task next</code> to show the next task in the list.</li> <li><code>task &lt;number&gt; edit$</code>: Executes <code>task {number} edit</code> where <code>{number}</code> is a spoken number, allowing the user to edit the task of that ID.</li> <li><code>task &lt;number&gt; done$</code>: Executes <code>task {number} done</code> where <code>{number}</code> is a spoken number, marking that task complete.</li> <li><code>task &lt;number&gt; delete$</code>: Executes <code>task {number} delete</code> where <code>{number}</code> is a spoken number, deleting the given task.</li> </ul> <p>In summary, this file provides a set of voice commands to manage tasks with Taskwarrior, covering common operations like listing, adding, editing, completing and deleting tasks. The user can perform these operations using voice control.</p>"},{"location":"apps/teams/","title":"teams","text":"<p>The <code>community/apps/teams</code> directory contains files that provide support for controlling the Microsoft Teams application using Talon. It includes platform-specific configurations and general commands.</p> <ul> <li> <p><code>teams_linux.py</code> defines context-specific actions for the Linux operating system when the Microsoft Teams application is active. It implements <code>zoom_in</code>, <code>zoom_out</code>, and <code>zoom_reset</code> actions, mapping them to the standard Teams keyboard shortcuts for zooming.</p> </li> <li> <p><code>teams.py</code> defines the application tag <code>microsoft_teams</code>, which is used to activate context-specific commands defined in other files. It declares that <code>microsoft_teams</code> is active on Linux when the application name contains \"teams\" or \"Teams\".</p> </li> <li> <p><code>teams.talon</code> contains the main set of Talon commands for Microsoft Teams. It includes commands for navigation, messaging, and managing meetings and calls. These commands are active on Windows and Linux. The comments in this file reference the Microsoft Teams keyboard shortcuts, which many of the commands emulate.</p> </li> <li> <p><code>teams_mac.talon</code> is the macOS specific version of <code>teams.talon</code>. It is specific to macOS and defines equivalent commands using the \"super\" (command) key instead of the control key where appropriate. It also adds some macOS-specific functionality, like <code>reset</code> to escape out of dialogs.</p> </li> </ul>"},{"location":"apps/terminator/","title":"terminator","text":"<p>The <code>community/apps/terminator</code> directory contains configuration for the Terminator terminal emulator on Linux.</p> <p>The most important file here is <code>terminator_linux.py</code>, which defines Talon bindings for Terminator. It works by defining a Talon <code>Module</code> named <code>terminator</code> and a <code>Context</code> that activates when the current application is Terminator. The context applies the following tags:</p> <ul> <li><code>terminal</code>: Generic terminal functionality.</li> <li><code>user.tabs</code>: Tab management.</li> <li><code>user.splits</code>: Window splitting.</li> <li><code>user.generic_unix_shell</code>: Generic unix shell functionality.</li> <li><code>user.git</code>: Git commands.</li> <li><code>user.kubectl</code>: Kubectl commands.</li> </ul> <p>The file implements actions in several action classes.</p> <ul> <li>The <code>user</code> action class implements actions that typically start with <code>user.</code>. These actions are custom actions defined in the user's configuration, and here they are implementing split window actions using the keyboard shortcuts that Terminator provides. For example, <code>split_window_right</code> executes <code>alt-right</code>.</li> <li>The <code>app</code> action class implements actions that typically start with <code>app.</code>.  These implement tab management actions, such as <code>tab_open</code> which executes <code>ctrl-shift-t</code>. It also overwrites the <code>window_open</code> and <code>window_close</code> actions from <code>linux/app.py</code>.</li> <li>The <code>edit</code> action class implements actions that typically start with <code>edit.</code>, such as the <code>paste</code> command that executes <code>ctrl-shift-v</code>. These actions overwrite the <code>edit</code> actions from <code>linux/edit.py</code>.</li> </ul>"},{"location":"apps/termite/","title":"termite","text":"<p>The <code>community/apps/termite</code> directory contains configuration for the <code>termite</code> terminal application within the Talon voice control system.</p> <p>The file <code>termite.talon</code> defines how Talon interacts with the <code>termite</code> terminal. It begins by specifying that these configurations should only apply to the <code>termite</code> application and specifically not if the window title contains <code>VIM</code>, as <code>VIM</code> is a terminal based text editor with its own commands.</p> <p>It then assigns several tags which enable other functionality in the user's Talon configuration. In particular, it adds <code>user.kubectl</code>, <code>user.git</code>, <code>user.taskwarrior</code>, and <code>terminal</code> tags. This allows other configuration files to define voice commands that interact with these tools when running inside <code>termite</code>.</p> <p>Finally, it adds some command overrides, specifically for selection mode within <code>termite</code> that mirror vim selection commands.</p>"},{"location":"apps/terraform/","title":"terraform","text":"<p>The <code>community/apps/terraform</code> directory provides Talon voice commands for interacting with the Terraform CLI.</p> <p>The most important files are:</p> <ul> <li><code>terraform.talon</code>: This file contains the core voice commands for interacting with Terraform. It defines commands such as \"terraform apply\", \"terraform destroy\", \"terraform plan\", \"terraform init\", and more. These commands are available when the \"terminal\" and \"user.terraform_client\" tags are both active.</li> <li><code>terraform.py</code>: This Python file defines the <code>user.terraform_client</code> tag, which enables the commands defined in <code>terraform.talon</code>.</li> </ul>"},{"location":"apps/thunderbird/","title":"thunderbird","text":"<p>This directory contains files that add support for the Thunderbird email client to Talon. It uses a combination of <code>.talon</code> files to define voice commands and <code>.py</code> files to implement the underlying logic, including platform specific differences.</p> <p>The core functionality is split across several files:</p> <ul> <li> <p><code>thunderbird.py</code>: Defines the different applications that will be used to determine the context of the user, including <code>thunderbird</code>, <code>thunderbird_inbox</code>, <code>thunderbird_calendar</code>, <code>thunderbird_tasks</code>, <code>thunderbird_composer</code>, and <code>thunderbird_contacts</code>. It also defines the <code>thunderbird_mod</code> and <code>thunderbird_calendar_view</code> actions.</p> </li> <li> <p><code>thunderbird.talon</code>: This file defines global commands available in Thunderbird, including commands to navigate to different tabs and open windows. Note that it explicitly excludes the contexts defined by <code>thunderbird_contacts</code> and <code>thunderbird_composer</code>.</p> </li> <li> <p><code>thunderbird_inbox.talon</code>: This file defines commands for navigating, marking, and sending emails in the inbox view. For example, \"mail up\" is mapped to the <code>b</code> key and \"mail delete\" is mapped to the <code>delete</code> key.</p> </li> <li> <p><code>thunderbird_composer.talon</code>: This file defines commands for composing emails such as saving, printing, and sending. It also includes commands for pasting and navigation.</p> </li> <li> <p><code>thunderbird_contacts.talon</code>: This file defines commands for managing contacts, such as creating, editing, and deleting contacts.</p> </li> <li> <p><code>thunderbird_calendar.talon</code>: This file defines commands for managing the calendar, including creating new events, deleting events, and changing the view.</p> </li> <li> <p><code>thunderbird_tasks.talon</code>: This file defines commands for managing tasks, including creating new tasks and deleting tasks.</p> </li> </ul> <p>The <code>.py</code> files provide platform-specific implementations of the actions defined in <code>thunderbird.py</code>:</p> <ul> <li> <p><code>thunderbird_linux.py</code>: Implements the <code>tab_reopen</code>, <code>tab_jump</code>, <code>tab_final</code>, <code>thunderbird_mod</code>, and <code>thunderbird_calendar_view</code> actions for Linux, using <code>ctrl</code> as the modifier key for most actions.</p> </li> <li> <p><code>thunderbird_win.py</code>: Implements the same actions for Windows, using <code>ctrl</code> as the modifier key for most actions.</p> </li> <li> <p><code>thunderbird_mac.py</code>: Implements the same actions for macOS, using <code>cmd</code> as the modifier key for most actions.</p> </li> </ul> <p>These files work together to provide a comprehensive set of voice commands for interacting with Thunderbird. The <code>.talon</code> files define the commands, the <code>.py</code> files implement them, and <code>thunderbird.py</code> provides common definitions and actions. The separation of concerns into contexts allows users to have different commands available to them based on the area of the app they are currently using, and the separation by OS makes it possible for this extension to work across platforms.</p>"},{"location":"apps/tmux/","title":"tmux","text":"<p>The <code>community/apps/tmux</code> directory contains files to enable Talon voice control of <code>tmux</code>. It provides commands for controlling <code>tmux</code> sessions, windows, and panes.</p> <p>The core functionality is defined in these files:</p> <ul> <li> <p><code>tmux.talon</code>: This file contains Talon commands for pane management, using the <code>user.splits</code> and <code>user.tabs</code> tags. It also contains a note about a required configuration file for detecting when <code>tmux</code> is active. The commands in this file rely on actions defined in <code>tmux.py</code>. For example, <code>go split &lt;user.arrow_key&gt;</code> will use the <code>user.tmux_keybind</code> action to send the appropriate keys to move between panes, while <code>go split</code> will display the panes.</p> </li> <li> <p><code>tmux.py</code>: This file defines the core Python logic for <code>tmux</code> control. It sets up the <code>tmux</code> app context, and defines the actions that are used by the commands in <code>tmux.talon</code> and <code>tmux_linux.talon</code>. These actions include:</p> <ul> <li><code>tmux_prefix</code>: Sends the <code>tmux</code> prefix key (default <code>ctrl-b</code>).</li> <li><code>tmux_keybind</code>: Sends the prefix key followed by another key.</li> <li><code>tmux_enter_command</code>: Enters <code>tmux</code> command mode, and optionally enters a command (without executing it).</li> <li><code>tmux_execute_command</code>: Enters <code>tmux</code> command mode, enters a command and executes it.</li> <li><code>tmux_execute_command_with_confirmation</code>: Executes a <code>tmux</code> command that requires confirmation.</li> <li>Overrides of <code>app.tab_open</code>, <code>app.tab_next</code>, and <code>app.tab_previous</code>, to control <code>tmux</code> windows as though they were tabs.</li> <li>Overrides of <code>user</code> actions to control <code>tmux</code> splits and switch between panes. For example, <code>split_window_right</code> creates a split to the right, and then swaps the new pane to the bottom of the pane stack, effectively moving it to the right of the active pane.</li> </ul> </li> <li> <p><code>tmux_linux.talon</code>: This file defines commands for Linux that use a more traditional method for controlling <code>tmux</code> using direct keybinds and <code>tmux</code> commands. It provides a <code>mux</code> command prefix which can be used to execute a variety of <code>tmux</code> actions, such as creating new sessions or windows, switching between panes, renaming sessions, or killing windows or panes. The <code>mux</code> command prefix also has variations that insert the equivalent <code>tmux</code> command into the terminal rather than sending keybinds. For example, <code>mux new session</code> inserts <code>tmux new</code> into the terminal, so that the user can enter the rest of the command.</p> </li> </ul> <p>The <code>tmux.py</code> file defines a context which applies only when the active app is <code>tmux</code>. This allows overriding the default actions defined in Talon (for example, the behavior of tab switching). The <code>tmux.talon</code> file provides a basic set of commands for controlling panes, while the <code>tmux_linux.talon</code> provides a more comprehensive set of commands for controlling all aspects of <code>tmux</code> when running on Linux. All of the commands in these <code>.talon</code> files rely on the actions defined in <code>tmux.py</code>.</p> <p>In summary, these files provide a comprehensive set of tools for controlling <code>tmux</code> with Talon. They provide basic pane control, tab control, and session control functionality. The <code>tmux.py</code> file is the most important, as it defines the underlying actions for all of the commands.</p>"},{"location":"apps/twitter/","title":"twitter","text":"<p>This directory contains the Talon configuration for interacting with Twitter in a web browser.</p> <p>The file twitter.talon defines a set of voice commands for navigating and interacting with the Twitter website. It uses the <code>browser</code> tag to indicate that it applies to the browser. It activates when the browser's host is <code>twitter.com</code>, matching any Twitter page, and can optionally be limited to windows with <code>Twitter</code> in the title.</p> <p>The file provides commands for common Twitter actions, such as:</p> <ul> <li>Navigating the timeline: <code>next tweet</code>, <code>previous tweet</code>, <code>page down</code>, <code>load new tweet</code></li> <li>Navigating to specific pages: <code>go home</code>, <code>go explore</code>, <code>go notifications</code>, <code>go mentions</code>, <code>go profile</code>, <code>go likes</code>, <code>go lists</code>, <code>go direct messages</code>, <code>go settings</code>, <code>go bookmarks</code></li> <li>Performing actions: <code>new tweet</code>, <code>send tweet</code>, <code>new direct message</code>, <code>search</code>, <code>like message</code>, <code>reply message</code>, <code>re tweet</code>, <code>share tweet</code>, <code>bookmark</code>, <code>mute account</code>, <code>block account</code>, <code>open details</code>, <code>expand photo</code></li> </ul> <p>These commands are implemented using <code>key()</code> calls, which simulate keyboard presses, or <code>insert()</code> calls, which simulate typing. For example, <code>next tweet</code> is implemented by simulating the <code>j</code> keypress.</p>"},{"location":"apps/visualstudio/","title":"visualstudio","text":"<p>The <code>community/apps/visualstudio</code> directory contains files that provide Talon voice control for the Visual Studio IDE on Windows.</p> <p>The most important files in this directory are:</p> <ul> <li> <p><code>visual_studio_win.py</code>: This file defines the core functionality for Visual Studio on Windows. It defines Talon actions for <code>app</code>, <code>code</code>, <code>edit</code>, and <code>user</code> contexts. It includes actions like closing tabs, navigating between tabs, toggling comments, indenting code, saving all files, and working with multiple cursors (using the MultiCaretBooster extension). The actions are defined in a context that matches when the operating system is Windows and the application is Visual Studio.</p> </li> <li> <p><code>visual_studio.py</code>: This file defines the application definition for Visual Studio on Windows, and adds additional actions for <code>app</code>, <code>code</code>, <code>edit</code>, <code>win</code>, and <code>user</code> contexts. Many of the same actions are repeated as in <code>visual_studio_win.py</code>, but there are also actions for jumping to a specific line, and interacting with the \"find\" and \"replace\" dialogs in visual studio. It defines the <code>app.visual_studio</code> that is used in other files in the <code>apps/visualstudio</code> directory. It also defines a <code>win.filename()</code> action that attempts to extract the file name from the window title using string manipulation. It also contains actions for finding text and replacing text, including the ability to perform project wide search and replace.</p> </li> <li> <p><code>visual_studio.talon</code>: This file defines the voice commands for Visual Studio. It provides commands for common IDE actions such as opening panels, showing settings, toggling fullscreen, creating files, and debugging. It leverages the actions defined in the other python files to execute these commands via voice. It also includes tags to enable other Talon modules like <code>user.tabs</code>, <code>user.line_commands</code>, <code>user.find_and_replace</code>, and <code>user.multiple_cursors</code>. This allows for a more modular approach to voice control.</p> </li> </ul> <p>These files work together to provide a comprehensive voice control solution for Visual Studio. The <code>.py</code> files define the actions, and the <code>.talon</code> file defines the voice commands that trigger those actions. The context matching ensures that actions are only available when Visual Studio is the active application on Windows.</p>"},{"location":"apps/vivaldi/","title":"vivaldi","text":"<p>The files in the <code>community/apps/vivaldi</code> directory provide support for controlling the Vivaldi browser with Talon.</p> <p>The core functionality is implemented in <code>vivaldi.py</code>. This file defines the application context for Vivaldi and provides actions for interacting with the browser, including:</p> <ul> <li>Toggling various panels such as history, bookmarks, downloads, and notes using the <code>vivaldi_history_panel</code>, <code>vivaldi_bookmarks_panel</code>, <code>vivaldi_downloads_panel</code>, and <code>vivaldi_notes_panel</code> actions.</li> <li>Overriding default <code>tab_close</code> behavior with a short sleep delay using <code>tab_close_wrapper</code>.</li> <li>Jumping to a specific tab using <code>tab_jump</code>.</li> <li>Opening Vivaldi's command search with <code>command_search</code>, optionally including a search term.</li> <li>Actions for common browser functions such as <code>show_extensions</code>, <code>focus_address</code>, <code>focus_page</code>, <code>bookmarks</code>, <code>show_downloads</code>, and <code>go</code>.<ul> <li>Note that <code>bookmark_tabs</code> is marked as <code>NotImplementedError</code> since it is not natively supported by Vivaldi.</li> <li>The <code>show_downloads</code> action opens a new tab and navigates to <code>vivaldi://downloads</code>.</li> </ul> </li> </ul> <p><code>vivaldi.talon</code> defines the Talon voice commands for Vivaldi. It uses tags for browser, tabs, and command search support. It also defines voice commands to toggle the history, downloads, bookmarks, and notes panels by using the actions defined in <code>vivaldi.py</code>. For example, saying \"sidebar history\" will call the <code>user.vivaldi_history_panel()</code> action.</p> <p><code>vivaldi_mac.py</code> provides overrides for macOS. This file defines platform specific keybindings for macOS by implementing the same actions as in <code>vivaldi.py</code>, such as:</p> <ul> <li>Using command-based shortcuts for toggling panels such as <code>vivaldi_history_panel</code>, <code>vivaldi_downloads_panel</code>, and <code>vivaldi_notes_panel</code> as well as <code>vivaldi_toggle_quick_commands</code>.</li> <li>Jumping to a specific tab with <code>tab_jump</code>.</li> <li>macOS-specific implementations for <code>tab_next</code> and <code>tab_previous</code>.</li> <li>Platform specific overrides for common browser actions like <code>show_extensions</code>, <code>bookmarks</code>, and <code>focus_address</code>.</li> </ul> <p>The files work together to provide a cross-platform experience for controlling Vivaldi with Talon. The <code>vivaldi.py</code> file provides the core functionality, while the <code>vivaldi_mac.py</code> file provides macOS-specific overrides. Finally, the <code>vivaldi.talon</code> file provides the voice commands that trigger the actions.</p>"},{"location":"apps/vscode/","title":"vscode","text":"<p>The <code>community/apps/vscode</code> directory contains files that integrate Talon with VS Code, providing enhanced control and automation. It includes the following important components:</p> <ul> <li> <p>The <code>command_client</code> subdirectory provides a mechanism for Talon to communicate with VS Code using a file-based RPC (Remote Procedure Call) system. It contains its own documentation, but the high-level idea is that Talon can send commands to VS Code and receive responses, even if VS Code doesn't have a direct API for Talon to interact with.</p> <ul> <li>The <code>rpc_client</code> subdirectory contains the generic RPC client. It provides actions for writing requests to files, reading responses from files, and handling potential race conditions and errors. The main entry point is the <code>rpc_client_run_command</code> action, which takes a command id and up to five optional arguments.</li> <li>The files directly within the <code>command_client</code> directory provide the user-facing interface to the RPC system, and provide application-specific configurations. <code>command_client.py</code> provides actions that call <code>rpc_client_run_command</code> from <code>rpc_client</code>, and also defines an OS-specific action to trigger the command server. <code>vscode.py</code> and <code>visual_studio.py</code> set the <code>user.command_client</code> tag for their respective applications, and they provide the <code>command_server_directory</code> action, pointing to their communication directories. <code>vscode.py</code> also defines convenient actions for calling VS Code commands, and it falls back to the command palette if the command server isn't available.</li> <li><code>vscode_terminal.talon</code> defines a tag, <code>terminal</code>, that is enabled when the VS Code terminal is focused. It uses a special string in the window title to determine this. The <code>README.md</code> in this directory explains how to configure VS Code to include the special string in the title, and how to add tags when the terminal tag is active, which can be used to enable additional terminal commands.</li> <li><code>README.md</code> provides a general overview of the VS Code support, including instructions for installing the VSCode talon extension pack and setting up Cursorless. It also provides instructions for enabling terminal commands via the window title, as described above.</li> <li><code>vscode.talon</code> provides a large number of custom commands for VS Code. It defines tags for features such as find and replace, line commands, multiple cursors, splits, tabs, and command search. It defines convenient actions for navigating the UI, working with files, and using language features. It provides commands for common tasks such as going to symbol, showing settings, working with snippets, and navigating code. It has many commands for working with git, testing, debugging, the terminal, tasks, and more. Many of these actions use the <code>user.vscode</code> command, which uses the command palette. Some actions use the new command server, via <code>user.vscode_and_wait</code>. It also provides actions to copy a file's name, path, or local path.</li> <li><code>vscode.py</code> defines the VS Code application context for Talon, and sets up bindings to various Talon actions. It also contains actions that are used by <code>vscode.talon</code>, such as <code>user.vscode_terminal</code>, which is used to switch between different terminal windows by number. It also contains implementations of generic Talon app actions such as <code>tab_open</code>, <code>tab_close</code>, <code>tab_next</code>, <code>tab_previous</code>, and <code>window_close</code>. Additionally, it provides implementations for <code>code.toggle_comment</code>, <code>edit.indent_more</code>, <code>edit.indent_less</code>, <code>edit.save_all</code>, and <code>find_next</code>, <code>find_previous</code>, and many more. This file also defines implementations of split windowing actions, and also provides multi-cursor support by leveraging VS Code's built-in functionality. It provides implementations for tab management (jumping to specific tabs), and actions for find and replace. It also allows <code>user.insert_snippet</code> to send an RPC command to VS Code to insert a snippet.</li> </ul> </li> </ul> <p>These files work together to provide a comprehensive set of tools for interacting with VS Code. The <code>command_client</code> allows for powerful and robust RPC calls, while <code>vscode.talon</code> provides a user-friendly interface to VS Code's commands, and also defines convenient actions for doing things that would normally be done using the command palette.  <code>vscode.py</code> provides the glue between these different systems and also provides implementations for generic Talon actions.</p>"},{"location":"apps/vscode/command_client/","title":"command_client","text":"<p>The <code>community/apps/vscode/command_client</code> directory provides a mechanism for Talon to communicate with VS Code using a file-based RPC (Remote Procedure Call) system. This allows Talon to send commands to VS Code and receive responses, even if VS Code doesn't have a direct API for Talon to interact with. It handles potential conflicts between multiple Talon instances or the same instance starting a new phrase. The system is designed to be robust even if the command server is unavailable.</p> <p>The core functionality resides in the <code>rpc_client</code> subdirectory, which has its own detailed explanation. However, the files in this directory provide the user-facing interface to that RPC system, and also provide application-specific configurations.</p> <p>Here's a breakdown of the key files:</p> <ul> <li> <p><code>command_client_tag.py</code>: This file defines the <code>command_client</code> tag, which is used to enable the command client functionality for a given application. It also defines the <code>command_server_directory</code> action that must be implemented by each application that wishes to use the command client.</p> </li> <li> <p><code>visual_studio.py</code>: This file configures the command client for Visual Studio. It sets the <code>user.command_client</code> tag when the application is <code>visual_studio</code>, and it implements the <code>command_server_directory</code> action, returning <code>\"visual-studio-command-server\"</code>.</p> </li> <li> <p><code>command_client.py</code>: This file provides the main interface for running RPC commands. It defines actions like <code>run_rpc_command</code>, <code>run_rpc_command_and_wait</code>, and <code>run_rpc_command_get</code>. These actions take a command ID and up to 5 optional arguments. They call the <code>rpc_client_run_command</code> action from the <code>rpc_client</code> subdirectory, which handles the actual communication. This file also handles emitting a pre-phrase signal, allowing for Cursorless and other code to know when a command phrase is beginning. It also defines the <code>trigger_command_server_command_execution</code> action, which is a keystroke to trigger the command server to execute the command. This action is OS-specific.</p> </li> <li> <p><code>vscode.py</code>: This file configures the command client specifically for VS Code. It sets the <code>user.command_client</code> tag when the application is <code>vscode</code> and provides the <code>command_server_directory</code> action implementation, returning <code>\"vscode-command-server\"</code>. It also provides actions like <code>vscode</code> and <code>vscode_and_wait</code>, that provide a user-friendly way to run VS Code commands using the command server. If the command server is not available, these actions fall back to the command palette. Finally, it also defines actions for backwards compatibility, which call the new actions in <code>command_client.py</code>.</p> </li> <li> <p><code>README.md</code>: This file provides a high-level overview of the command client and instructions for contributing to the repository. Note that the code is maintained in two repos (the community repo and a dedicated one), and it gives instructions for keeping both in sync.</p> </li> </ul> <p>In summary, the files in this directory provide the glue between the generic RPC client in the <code>rpc_client</code> subdirectory and specific applications like VS Code. The <code>command_client.py</code> provides a generic way to run RPC commands through actions, while the <code>vscode.py</code> and <code>visual_studio.py</code> files provide app-specific configurations. They use the <code>command_client</code> tag, the <code>command_server_directory</code> action, and provide a user-friendly experience for calling commands, even if the server isn't available.</p>"},{"location":"apps/vscode/command_client/rpc_client/","title":"rpc_client","text":"<p>The <code>rpc_client</code> directory provides a mechanism for Talon to communicate with an external application (like VS Code) using JSON files. This allows Talon to send commands to the application and receive responses, even if the application doesn't have a direct API for Talon to interact with. It is designed to be robust against multiple Talon instances trying to interact with the same application simultaneously.</p> <p>Here's a breakdown of the key files and how they work together:</p> <ul> <li> <p><code>types.py</code>: This file defines the <code>Request</code> dataclass, which represents a command to be sent to the external application, including the command ID, arguments, and a UUID for request-response matching. It also defines a custom exception, <code>NoFileServerException</code>, raised when the communication directory doesn't exist.</p> </li> <li> <p><code>write_request.py</code>: This file contains functions for writing a <code>Request</code> to a file. It handles situations where a request file already exists, likely due to another Talon instance or a previous incomplete run. If the existing file is stale (older than <code>STALE_TIMEOUT_MS</code>), it will be deleted and overwritten. This prevents issues with multiple processes colliding. The core function here is <code>write_json_exclusive</code>, which ensures that only one process can write the request at a time, by creating the file in exclusive mode.</p> </li> <li> <p><code>read_json_with_timeout.py</code>: This file contains a function <code>read_json_with_timeout</code> that reads a JSON file, waiting for the file to be completely written. It does this by looking for a trailing newline character, which is added only after the JSON is completely written. It uses an exponential backoff to check the file, up to a maximum timeout of <code>RPC_COMMAND_TIMEOUT_SECONDS</code>. If it doesn't see the newline before the timeout, it throws an exception. This prevents races when reading a file that is being written at the same time, while also preventing deadlocks.</p> </li> <li> <p><code>rpc_client.py</code>: This file defines the core action <code>rpc_client_run_command</code>. This is the function that Talon code will call to communicate with the external application. It constructs a <code>Request</code> object, writes it to a file using <code>write_request</code>, triggers the application to process the request, reads the response from a file using <code>read_json_with_timeout</code>, and returns the result. It also handles errors, warnings, and request-response UUID matching for sanity checks. The function ensures that no matter what the outcome of the interaction, both request and response files are deleted.</p> </li> <li> <p><code>get_communication_dir_path.py</code>: This file provides a function <code>get_communication_dir_path</code> to determine the location of the communication directory, which is a temporary directory based on the application name and the user ID. This helps avoid conflicts between different users or applications.</p> </li> <li> <p><code>robust_unlink.py</code>: This file contains the <code>robust_unlink</code> function, which is used to delete files. It handles cases where a file cannot be deleted on Windows because it is in use by moving it to a \"graveyard\" directory instead. This allows the system to function without crashing, even if files are locked by other processes.</p> </li> </ul> <p>In summary, this code provides a robust and reliable way for Talon to communicate with external applications using JSON files, handling potential conflicts and errors gracefully. The <code>rpc_client_run_command</code> action is the primary interface for sending commands and receiving responses. The other files handle details such as file writing, reading, and cleanup.</p>"},{"location":"apps/warp/","title":"warp","text":"<p>The <code>community/apps/warp</code> directory contains the Talon configuration for the Warp terminal application.</p> <ul> <li> <p><code>warp.talon</code> declares the tags that should be active when the Warp app is in focus. These tags activate various features like general terminal commands, git commands, kubctl commands, tab handling, file management commands, and readline shortcuts.</p> </li> <li> <p><code>warp.py</code> defines the app definition for Warp using its bundle identifier, <code>dev.warp.Warp-Stable</code>, which enables Talon to detect when the Warp application is in focus on macOS.</p> </li> </ul>"},{"location":"apps/windbg/","title":"windbg","text":"<p>The <code>community/apps/windbg</code> directory contains files for interacting with the WinDbg debugger.</p> <p>The primary files are:</p> <ul> <li><code>windbg.py</code>: This Python file defines the core logic and actions for the WinDbg integration. It defines a <code>user.windbg</code> tag, which is used to activate WinDbg-specific functionality. It also defines a number of actions such as <code>debugger_step_into</code>, <code>debugger_show_breakpoints</code>, <code>debugger_goto_address</code>, <code>debugger_backtrace</code>, <code>debugger_disassemble</code>, etc, that provide commands for interacting with the debugger. It defines a capture <code>windows_dlls</code> for use with the <code>windbg.talon</code> file.</li> <li><code>windbg.talon</code>: This Talon file defines the voice commands and keybindings for controlling WinDbg. It uses the <code>user.windbg</code> tag from <code>windbg.py</code> to enable the WinDbg commands. It provides commands to navigate the debugger UI, load symbols, show modules, and perform other useful actions. It uses the <code>windows_dlls</code> capture defined in <code>windbg.py</code>. It has a number of commands for inserting text into the debugger command line, as well as navigating the UI using hotkeys.</li> </ul> <p>The <code>windbg.py</code> file defines the logic and actions, while <code>windbg.talon</code> provides the voice commands for triggering the actions. Together, they enable users to control WinDbg using voice commands.</p>"},{"location":"apps/windows_command_processor/","title":"windows_command_processor","text":"<p>The <code>community/apps/windows_command_processor</code> directory contains files that provide Talon bindings for interacting with the Windows Command Prompt and Windows Terminal. These files enhance the command-line experience with features like directory navigation, file operations, and more.</p> <p>The core functionality is provided by two files:</p> <ul> <li> <p><code>command_processor_actions_win.py</code>: This file defines a context that matches the Windows Command Prompt and Windows Terminal applications with a title containing \"Command Prompt\". It assigns the <code>user.file_manager</code>, <code>user.git</code>, <code>user.kubectl</code>, and <code>terminal</code> tags, enabling more specific commands for these contexts.</p> <ul> <li>It implements actions to refresh the title (<code>file_manager_refresh_title</code>), navigate to the parent directory (<code>file_manager_open_parent</code>), and to delete a line (<code>delete_line</code>). The refresh title action updates the title of the window to display the current directory.</li> </ul> </li> <li> <p><code>command_processor_win.py</code>: This file expands on <code>command_processor_actions_win.py</code>, providing additional functionality for file management and terminal interactions. It defines a context similar to <code>command_processor_actions_win.py</code> and also assigns the same tags.</p> <ul> <li>It implements <code>file_manager_refresh_title</code> and <code>file_manager_open_parent</code> the same way as <code>command_processor_actions_win.py</code>.</li> <li>The <code>file_manager_current_path</code> action extracts the current path from the window title and cleans it up.</li> <li>The file implements various actions for interacting with the file system, including:<ul> <li><code>file_manager_open_directory</code>: Opens a specified directory.</li> <li><code>file_manager_select_directory</code>: Selects a directory.</li> <li><code>file_manager_new_folder</code>: Creates a new folder using <code>mkdir</code>.</li> <li><code>file_manager_open_file</code>: Opens a file.</li> <li><code>file_manager_select_file</code>: Selects a file.</li> <li><code>file_manager_open_volume</code>: Opens a volume.</li> </ul> </li> <li>It provides actions for terminal interactions, including:<ul> <li><code>terminal_list_directories</code>: Lists directories using <code>dir</code>.</li> <li><code>terminal_list_all_directories</code>: Lists all directories including hidden ones using <code>dir /a</code>.</li> <li><code>terminal_change_directory</code>: Changes the current directory using <code>cd</code>.</li> <li><code>terminal_change_directory_root</code>: Changes the directory to the root of the current drive using <code>cd /</code>.</li> <li><code>terminal_clear_screen</code>: Clears the screen using <code>cls</code>.</li> <li><code>terminal_run_last</code>: Executes the last command from the history.</li> <li><code>terminal_kill_all</code>: Kills the current process.</li> </ul> </li> </ul> </li> </ul> <p>These files work together to provide a comprehensive set of Talon actions for navigating and interacting with the Windows Command Prompt and Windows Terminal. The actions defined here can be invoked through voice commands, making it easier to perform common tasks on the command line.</p>"},{"location":"apps/windows_explorer/","title":"windows_explorer","text":"<p>The <code>community/apps/windows_explorer</code> directory contains files for controlling Windows Explorer and file dialogs using Talon.</p> <p>The most important files in this directory are:</p> <ul> <li> <p><code>windows_explorer.py</code>: This file contains the core logic for interacting with Windows Explorer and file dialogs. It defines a Talon module that matches the <code>windows_explorer</code> and <code>windows_file_browser</code> apps using their names and executable paths. It also defines a context that matches those apps to the user actions that will be available in those contexts. Most of the interesting logic is in the <code>UserActions</code> class, which defines the following user actions:</p> <ul> <li><code>file_manager_open_parent()</code>: Navigates to the parent directory by sending <code>alt-up</code>.</li> <li><code>file_manager_current_path()</code>: Returns the current path by getting the title of the active window.  It also handles remapping some common directories like \"Desktop\", \"Documents\", etc to their full path, and excluding some titles such as \"Run\", \"Task Switching\", etc.</li> <li><code>file_manager_terminal_here()</code>: Opens a command prompt in the current directory by sending <code>ctrl-l</code> to focus the address bar, inserting <code>cmd.exe</code>, and pressing enter.</li> <li><code>file_manager_show_properties()</code>: Opens the properties dialog for the selected file or folder by sending <code>alt-enter</code>.</li> <li><code>file_manager_open_directory(path: str)</code>: Opens the specified directory by focusing the address bar using <code>ctrl-l</code>, inserting the path, and pressing enter.</li> <li><code>file_manager_select_directory(path: str)</code>: Selects the directory by inserting the path.</li> <li><code>file_manager_new_folder(name: str)</code>: Creates a new folder by sending <code>ctrl-shift-n</code>, then inserts the specified name.</li> <li><code>file_manager_open_file(path: str)</code>: Opens the specified file by inserting the path, and pressing enter.</li> <li><code>file_manager_select_file(path: str)</code>: Selects the file by inserting the path.</li> <li><code>file_manager_open_volume(volume: str)</code>: Opens the specified volume by calling <code>file_manager_open_directory</code>.</li> <li><code>address_focus()</code>: Focuses the address bar by sending <code>ctrl-l</code>.</li> <li><code>address_copy_address()</code>: Copies the address bar content by focusing it with <code>ctrl-l</code> and then copying the content to the clipboard with <code>ctrl-c</code>.</li> <li><code>address_navigate(address: str)</code>: Navigates to the specified address by calling <code>file_manager_open_directory</code>.</li> </ul> </li> <li> <p><code>windows_explorer.talon</code>: This file defines the Talon commands that trigger the user actions defined in <code>windows_explorer.py</code>. It activates the <code>user.address</code>, <code>user.file_manager</code>, and <code>user.navigation</code> tags. It also defines some example commands such as <code>go &lt;user.letter&gt;</code> which opens a drive volume, <code>go app data</code> which opens the <code>%AppData%</code> directory and <code>go program files</code> which opens the <code>%programfiles%</code> directory.</p> </li> </ul> <p>These files work together to provide a set of voice commands for navigating and interacting with Windows Explorer and file dialogs. The python file handles the main logic while the talon file provides the commands that use the python logic.</p>"},{"location":"apps/windows_terminal/","title":"windows_terminal","text":"<p>This directory provides support for using Talon with the Windows Terminal application.</p> <p>The <code>windows_terminal.talon</code> file contains Talon code that activates the context for Windows Terminal, and makes several features available:</p> <ul> <li>It activates the <code>terminal</code>, <code>user.generic_windows_shell</code>, <code>user.git</code>, <code>user.anaconda</code>, <code>user.tabs</code>, and <code>user.splits</code> tags. This makes the commands defined in the corresponding files available in the Windows Terminal context.</li> <li>It defines some basic commands for interacting with the window, such as <code>settings open</code> (Ctrl+,), <code>focus left/right/up/down</code> (Ctrl+Alt+Shift+Arrows) and <code>term menu</code> (Ctrl+Shift+F1).</li> <li>It defines the <code>find it</code> command which uses <code>edit.find()</code> to find a string in the terminal. The <code>&lt;phrase&gt;$</code> variant can be used to find consecutive matches.</li> </ul> <p>The <code>windows_terminal.py</code> file contains Python code that defines the specific behavior for the Windows Terminal application. It includes:</p> <ul> <li>Mappings for basic app actions such as <code>tab_close</code> (Ctrl+Shift+W) and <code>tab_open</code> (Ctrl+Shift+T) in the <code>AppActions</code> class.</li> <li>Mappings for <code>paste</code> (Ctrl+Shift+V), <code>copy</code> (Ctrl+Shift+C), and <code>find</code> (Ctrl+Shift+F) in the <code>EditActions</code> class.</li> <li>Several implementations of user actions in the <code>UserActions</code> class including:<ul> <li><code>file_manager_current_path</code> which extracts the current path from the window title. It also allows for remapping and excluding certain paths.</li> <li><code>file_manager_open_directory</code>, <code>file_manager_select_directory</code>, <code>file_manager_new_folder</code>, <code>file_manager_open_file</code>, <code>file_manager_select_file</code>, <code>file_manager_open_volume</code> which implement file manager commands by inserting the appropriate command line arguments into the terminal.</li> <li><code>tab_jump</code> which jumps to a specific tab by using Ctrl-Alt-number.</li> <li><code>split_window_vertically</code> (Shift+Alt+Plus), <code>split_window_horizontally</code> (Shift+Alt+Minus), and several other split actions that are not directly supported by Windows Terminal. These show a notification that the user should use the provided split commands instead of the requested split command.</li> <li><code>tab_final</code> which goes to the last tab using Ctrl+Alt+9.</li> </ul> </li> </ul> <p>These two files work together to provide a comprehensive set of commands for interacting with Windows Terminal using Talon. The <code>.talon</code> file defines the context and some basic commands, while the <code>.py</code> file implements the specific logic for each action. The <code>user.splits</code> and <code>user.tabs</code> tags in <code>windows_terminal.talon</code> activate the corresponding actions defined in <code>windows_terminal.py</code>.</p>"},{"location":"apps/wsl/","title":"wsl","text":"<p>The <code>community/apps/wsl</code> directory provides support for using Talon with the Windows Subsystem for Linux (WSL). It allows you to navigate the file system and run commands within WSL using voice commands.</p> <p>The <code>wsl.talon</code> file at https://github.com/talonhub/community/blob/main/apps/wsl/wsl.talon contains the Talon script that defines the voice commands and their associated actions. It begins with a crucial note about activating the <code>user.wsl</code> tag in the appropriate contexts. This tag is how these voice commands are enabled when you're using WSL. It is recommended to activate the <code>user.wsl</code> tag by matching on the <code>app: windows_terminal</code> and the title matching <code>^WSL:</code>. An example of how to configure your <code>.bashrc</code> file to achieve this is also provided. </p> <p>The file also defines the following voice commands: *   <code>go &lt;user.letter&gt;</code>: Opens a directory within the <code>/mnt</code> directory using the given letter (e.g., \"go c\" opens <code>/mnt/c</code>). *   <code>wsl reset path detection</code>: Executes the <code>user.wsl_reset_path_detection()</code> action, which re-enables WSL path detection. *    <code>wsl speak</code>: Executes the <code>user.wsl_speak()</code> action, which sends a message to each of the configured WSL distros that is printed to the log.</p> <p>This script also applies the <code>terminal</code>, <code>user.file_manager</code>, <code>user.generic_unix_shell</code>, <code>user.git</code>, and <code>user.kubectl</code> tags.</p> <p>The <code>wsl.py</code> file at https://github.com/talonhub/community/blob/main/apps/wsl/wsl.py contains the Python code that implements the actions defined in <code>wsl.talon</code>. It does the following: *   Sets up a Talon context that activates when the <code>windows_terminal</code> app is in focus and the <code>user.wsl</code> tag is active. *   It defines a regular expression <code>wsl_title_regex</code> used to parse the window title to extract the WSL distro and current path. *   Uses the Windows registry to determine which WSL distros are installed and can be interacted with. *   Provides a <code>run_wslpath</code> function that translates paths between Windows and WSL, ensuring the correct path is used in file manager operations. *   Defines <code>run_wsl</code> to run wsl commands, and to provide proper error handling for <code>The Windows Subsystem for Linux instance has terminated.</code> *   Implements a set of actions for <code>user.file_manager</code>, and <code>user.terminal</code>.</p> <p>The most important part of this code is how it gets and translates paths. The <code>_parse_win_title</code> function extracts the distro name and current path from the active window title. The <code>run_wslpath</code> function then uses the <code>wslpath</code> command to convert paths between Windows and WSL formats, and handles errors. The <code>user.file_manager_current_path</code> action uses these functions to return the current path in a format that the <code>user.file_manager</code> actions can understand.</p> <p>The <code>wsl.py</code> file also defines a <code>wsl_reset_path_detection</code> action that can be called from the <code>wsl.talon</code> file.  This is a failsafe for when the WSL subsystem has failed.  This reset is used in the <code>wsl.talon</code> file by the <code>wsl reset path detection</code> voice command.</p> <p>In summary, these two files work together to enable voice control of WSL within the Windows Terminal. The <code>wsl.talon</code> script provides the user-facing voice commands and tag activation context, while <code>wsl.py</code> implements the underlying logic for interacting with WSL and translating paths.</p>"},{"location":"core/","title":"core","text":"<p>The <code>community/core</code> directory contains the core functionality of the Talon community configuration. It includes a variety of subdirectories and files that manage aspects of Talon such as code snippets, vocabulary, key bindings, text formatting, and application switching.</p> <p>Here's a breakdown of the most important subdirectories and files, and how they work together:</p> <ul> <li> <p><code>abbreviate</code>: This directory contains <code>abbreviate.py</code>, which defines a system for expanding abbreviations in Talon. It uses a dictionary of abbreviations and their expansions, and it can be customized with a CSV file named <code>abbreviations.csv</code>.</p> </li> <li> <p><code>app_switcher</code>: This directory contains files that allow users to switch between and launch applications using voice commands. The core logic is in <code>app_switcher.py</code>, which uses platform-specific CSV files to manage application names and spoken overrides.</p> </li> <li> <p><code>edit</code>: This directory provides core editing functionality for Talon, including actions for navigating, selecting, and manipulating text. It includes platform-specific files (<code>edit_linux.py</code>, <code>edit_mac.py</code>, <code>edit_win.py</code>) and more advanced editing functionality in files such as <code>edit.py</code>, <code>edit_command.py</code>, <code>edit_command_modifiers.py</code>, <code>edit_command_actions.py</code>, <code>edit_navigation_steps.py</code>, and <code>edit_paragraph.py</code>.  It also includes files for managing delimiter pairs (<code>delimiter_pair.py</code>) and inserting text between two points (<code>insert_between.py</code>). These are all used by the rules defined in <code>edit.talon</code>.</p> </li> <li> <p><code>file_extension</code>: This directory contains the files for speaking file extensions using Talon. The core logic is in <code>file_extension.py</code>, which defines a Talon list <code>user.file_extension</code> that is populated by a CSV file named <code>file_extensions.csv</code>. This list is used in the rule defined in <code>file_extension.talon</code>.</p> </li> <li> <p><code>formatters</code>: This directory contains files for formatting text within Talon. The core logic is in <code>formatters.py</code>, which defines various text formatters, like <code>CodeFormatter</code>, <code>TitleFormatter</code>, <code>CapitalizeFormatter</code>, and <code>SentenceFormatter</code>. The formatters are used by the <code>word_formatter</code>, <code>code_formatter</code>, <code>prose_formatter</code>, and <code>reformatter</code> lists defined in the <code>.talon-list</code> files in this directory.</p> </li> <li> <p><code>help</code>: This directory provides a help system for Talon. It includes <code>help.py</code>, which manages the display of help information in an ImGui window and <code>help_scope.py</code>, which displays the current Talon scope. It also includes Talon files to trigger the help system and to navigate the help window: <code>help.talon</code>, <code>help_open.talon</code>, and <code>help_scope_open.talon</code>.</p> </li> <li> <p><code>homophones</code>: This directory contains files that allow for the selection of homophones using a GUI. The core logic is in <code>homophones.py</code>, which parses <code>homophones.csv</code> and creates a GUI for selecting homophones. The <code>homophones.talon</code> file provides the commands for triggering the functionality, and <code>homophones_open.talon</code> provides commands for using the open GUI.</p> </li> <li> <p><code>keys</code>: This directory provides configuration files for mapping spoken words to keyboard keys. It includes platform-specific subdirectories (<code>mac</code> and <code>win</code>), as well as several key definition files (e.g., <code>arrow_key.talon-list</code>, <code>number_key.talon-list</code>, <code>function_key.talon-list</code>, <code>letter.talon-list</code>). These lists are used by the core files in this directory: <code>keys.talon</code>, which defines grammar rules for using the keys, and <code>keys.py</code>, which defines the lists and capture rules.</p> </li> <li> <p><code>menu_choose</code>: This directory allows for selecting items from menus using voice commands. The actions <code>choose</code> and <code>choose_up</code> are defined in <code>menu_choose.py</code> and triggered with voice commands in <code>menu_choose.talon</code>.</p> </li> <li> <p><code>modes</code>: This directory defines and manages different modes of operation for Talon, such as \"sleep\", \"command\", \"dictation\", and language modes. The core logic is in <code>modes.py</code>. It also includes files such as <code>sleep_mode.talon</code>, <code>command_and_dictation_mode.talon</code>,  <code>modes_not_dragon.talon</code>, <code>language_modes.py</code>, and <code>code_languages.py</code>.  The directory also includes platform-specific files like <code>dragon_mode.talon</code>, and <code>modes_dragon.talon</code> for controlling Dragon, and <code>sleep_mode_wav2letter.talon</code> for the <code>wav2letter</code> speech engine.</p> </li> <li> <p><code>mouse_grid</code>: This directory contains the code for the mouse grid system. The core logic is in <code>mouse_grid.py</code>, which defines the <code>MouseSnapNine</code> class. The commands for interacting with the mouse grid are defined in <code>mouse_grid_always.talon</code> and <code>mouse_grid_open.talon</code>.</p> </li> <li> <p><code>navigation</code>: This directory contains files for navigating forward and backward, using different keybindings based on the context. It uses <code>navigation.py</code> to define the actions for each context, and <code>navigation.talon</code> to bind the commands.</p> </li> <li> <p><code>numbers</code>: This directory provides files for parsing and representing numbers using voice commands. The core logic is in <code>numbers.py</code>, which defines how numbers are parsed. It also includes <code>ordinals.py</code>, which defines lists of ordinal words. The Talon bindings for these files are provided by <code>numbers_unprefixed.talon</code> and <code>numbers_prefixed.talon</code>.</p> </li> <li> <p><code>screens</code>: This directory contains files for managing and displaying information about multiple screens. The core logic is in <code>screens.py</code>, which provides actions for showing screen numbers, and the command to use the actions is in <code>screens.talon</code>.</p> </li> <li> <p><code>snippets</code>: This directory contains the code for handling code snippets. It includes <code>snippets.py</code> for managing and using snippets, <code>snippets_parser.py</code> for parsing snippet files, <code>snippets_insert.py</code> for inserting snippets, <code>snippets_insert_raw_text.py</code> for inserting raw text, and <code>snippet_types.py</code> for defining dataclasses used in the other files. The snippets themselves are stored in the <code>snippets/snippets</code> subdirectory as <code>.snippet</code> files. The directory also includes <code>snippets.talon</code>, which defines the Talon commands for using the snippets.</p> </li> <li> <p><code>text</code>: This directory defines how Talon handles text input and formatting. It includes lists of words and phrases in files such as <code>currency.talon-list</code>, <code>prose_modifiers.talon-list</code>, <code>prose_snippets.talon-list</code>, and <code>phrase_ender.talon-list</code>. The commands for manipulating text are defined in <code>text.talon</code>. The core logic for text formatting and dictation is in <code>text_and_dictation.py</code>, which defines captures for words, phrases, and prose, and the <code>DictationFormat</code> class, which is used to format text. This directory also includes <code>phrase_history.py</code>, which manages a history of recently spoken phrases.</p> </li> <li> <p><code>vocabulary</code>: This directory contains files that manage custom vocabulary and word replacement for Talon. The core logic is in <code>vocabulary.py</code>, which defines how custom vocabulary is loaded, modified, and used. It uses <code>words_to_replace.csv</code> and <code>vocabulary.talon-list</code> to store the user's customizations.  The Talon commands to use the actions are defined in <code>edit_vocabulary.talon</code>.</p> </li> <li> <p><code>websites_and_search_engines</code>: This directory contains files that allow users to quickly navigate to websites and perform searches using voice commands. It uses lists in <code>website.talon-list</code> and <code>search_engine.talon-list</code> to store website and search engine URLs. The logic for the actions is in <code>websites_and_search_engines.py</code>, and the voice commands to use the actions are defined in <code>websites_and_search_engines.talon</code>.</p> </li> <li> <p><code>windows_and_tabs</code>: This directory contains files for managing windows and tabs across different operating systems. It includes <code>window_snap.py</code> for snapping windows to specific screen positions and platform-specific files (<code>windows_and_tabs_win.py</code>, <code>windows_and_tabs_mac.py</code>, and <code>windows_and_tabs_linux.py</code>) for common window and tab actions. Generic tab actions are in <code>tabs.py</code>, and cross-platform window cycling actions are in <code>windows_and_tabs.py</code>. The voice commands for using the actions are defined in <code>window_management.talon</code> and <code>tabs.talon</code>.</p> </li> </ul> <p>In addition to these subdirectories, the <code>community/core</code> directory also contains the following files:</p> <ul> <li><code>app_running.py</code>: This file defines a Talon scope that tracks running applications.</li> <li><code>dragon_engine.py</code>: This file defines actions for controlling the Dragon speech engine.</li> <li><code>README.md</code>: This file provides a high-level overview of the <code>community/core</code> directory.</li> <li><code>tags.py</code>: This file defines tags for loading various modules and plugins.</li> <li><code>system_command.py</code>: This file defines actions for executing system commands.</li> <li><code>deprecations.py</code>: This file defines actions for deprecating voice commands, actions, and captures.</li> <li><code>create_spoken_forms.py</code>: This file defines actions for creating spoken forms of strings.</li> <li><code>system_paths.py</code>: This file defines a list of system paths and a capture for using those paths.</li> <li><code>delayed_speech_off.py</code>: This file defines actions to enable and disable speech recognition.</li> <li><code>application_matches.py</code>: This file defines application matching patterns.</li> <li><code>noise.py</code>: This file defines actions that are triggered by noises.</li> <li><code>user_settings.py</code>: This file provides helper functions for managing user settings.</li> </ul> <p>These files and subdirectories work together to provide a comprehensive set of features and functionality for the Talon voice control system.</p>"},{"location":"core/abbreviate/","title":"abbreviate","text":"<p>The <code>community/core/abbreviate</code> directory contains a single file, <code>abbreviate.py</code>. This file defines a system for expanding abbreviations in Talon. It works by defining a list of common abbreviations and their expansions, and then creating a Talon list that can be used in voice commands.</p> <p>Here's a breakdown of how it works:</p> <ul> <li>Abbreviations List: The core of this file is the <code>abbreviations</code> dictionary, which maps spoken forms (e.g., \"application\") to their abbreviated forms (e.g., \"app\"). This dictionary is quite extensive, covering common terms from programming, technology, and general usage.</li> <li>Talon Module and Context:  The file sets up a Talon module and context. This allows the definitions in the file to be used by Talon voice commands. The line <code>mod.list(\"abbreviation\", desc=\"Common abbreviation\")</code> declares a list that can be referenced in other Talon files.</li> <li><code>track_csv_list</code> Decorator: The <code>@track_csv_list</code> decorator loads abbreviations from a CSV file named <code>abbreviations.csv</code>. This CSV file allows users to customize the abbreviations. The decorator takes a default dictionary, which is the <code>abbreviations</code> dictionary defined in the file.</li> <li>Loading Abbreviations: The <code>on_abbreviations</code> function is called when the CSV file is loaded or changed. It updates a global dictionary <code>abbreviations_list</code>, and adds both the spoken and abbreviated forms to the Talon list <code>user.abbreviation</code>.</li> <li>Capture Rule: The file defines a capture rule <code>brief {user.abbreviation}</code> that allows any abbreviation in the user.abbreviation list to be captured by a voice command that uses the term \"brief.\"</li> <li>Usage: With this configuration, a Talon user can say \"brief app\" and it would expand to \"app\", or \"brief application\" which would also expand to \"app\". Similarly \"brief address\" would be \"addr\" and \"brief addresses\" would be \"addrs\".</li> </ul> <p>In short, <code>abbreviate.py</code> provides a system for creating and using short forms for common words and phrases, which can speed up dictation by requiring less verbal communication from the user.</p>"},{"location":"core/app_switcher/","title":"app_switcher","text":"<p>The <code>community/core/app_switcher</code> directory contains files that enable users to switch between and launch applications using voice commands. It also includes a basic UI for viewing running applications. The core logic for this functionality resides in <code>app_switcher.py</code>, with platform-specific overrides for application names defined in CSV files.</p> <p>The application switching logic is implemented in the <code>app_switcher.py</code> file, which defines the following:</p> <ul> <li>Lists: The module defines two lists: <code>running</code>, which represents all currently running applications, and <code>launch</code>, which represents all launchable applications.</li> <li>Overrides: Spoken forms for application names can be overridden via CSV files. These overrides are stored in the <code>overrides</code> dictionary. There is also an <code>excludes</code> set of app names that should not be included in the running list.</li> <li>Application Lists: The <code>get_apps()</code> function is platform-specific and is responsible for generating the list of launchable applications. On Windows, it uses the <code>shell:AppsFolder</code> to retrieve all applications, including \"modern\" apps. On Linux, it parses <code>.desktop</code> files in common application directories. On MacOS, it lists all <code>.app</code> directories in common application directories.</li> <li>Update Functions: The <code>update_running_list()</code> function updates the list of running applications, and the <code>update_overrides()</code> function updates the overrides and excludes lists by reading the platform-specific CSV file. The <code>update_launch_list()</code> function uses <code>get_apps()</code> to update the list of launchable apps.</li> <li>Actions: The module defines a variety of actions:<ul> <li><code>get_running_app(name: str)</code> retrieves the application object for the running app with the provided name.</li> <li><code>switcher_focus(name: str)</code> focuses the application given by the provided name.</li> <li><code>switcher_focus_app(app: ui.App)</code> focuses the provided application.</li> <li><code>switcher_focus_window(window: ui.Window)</code> focuses the provided window.</li> <li><code>switcher_launch(path: str)</code> launches the application at the provided path.</li> <li><code>switcher_menu()</code> opens a menu of running apps (platform-specific).</li> <li><code>switcher_toggle_running()</code> shows/hides a list of running applications.</li> <li><code>switcher_hide_running()</code> hides the list of running applications.</li> </ul> </li> <li>GUI: The module includes a simple ImGui based GUI to show the running applications with their associated spoken forms.</li> <li>Events: The <code>ui_event</code> function updates the running list on application launch and close events.</li> <li>Startup: The <code>on_ready</code> function is called when Talon is ready. It initializes the overrides, starts watching the override directory for changes, updates the launch and running lists and registers the <code>ui_event</code> callback function.</li> </ul> <p>The directory also contains three CSV files that define platform-specific spoken form overrides: *   <code>app_name_overrides.linux.csv</code> *   <code>app_name_overrides.windows.csv</code> *   <code>app_name_overrides.mac.csv</code></p> <p>These files contain comma-separated values.  The first column is the spoken form, and the second column is the application name or <code>.exe</code> (on Windows).  If a line contains only one value, the application specified will be excluded from the running list. These files are used by the <code>update_overrides</code> function in <code>app_switcher.py</code> to update the <code>overrides</code> and <code>excludes</code> lists.</p> <p>In summary, the <code>app_switcher</code> directory provides a robust mechanism for launching and switching between applications using voice commands, with platform-specific adjustments and overrides.</p>"},{"location":"core/edit/","title":"edit","text":"<p>The <code>community/core/edit</code> directory contains files that define core editing functionality for Talon. It provides actions for navigating, selecting, and manipulating text, as well as some higher-level editing commands. The files are designed to work together to provide a consistent and powerful editing experience across different operating systems.</p> <p>The core functionality is split across multiple files:</p> <ul> <li> <p><code>edit_linux.py</code>, <code>edit_mac.py</code>, and <code>edit_win.py</code>: These files define the basic edit actions for Linux, macOS, and Windows, respectively. They use the <code>Context</code> class from Talon to define actions that are specific to each operating system. These files are all structured similarly and define actions such as <code>copy</code>, <code>cut</code>, <code>delete</code>, navigation, and selection using native OS keyboard shortcuts. For example, <code>edit_linux.py</code> defines <code>copy</code> as <code>ctrl-c</code>, while <code>edit_mac.py</code> defines <code>copy</code> as <code>cmd-c</code>.</p> </li> <li> <p><code>edit.py</code>: This file provides more advanced actions that are not specific to any operating system. It defines things like <code>selected_text</code> to retrieve the currently selected text using the clipboard, <code>line_insert_down</code>, <code>selection_clone</code>, and <code>line_clone</code>, as well as more robust <code>select_word</code> functionality. It also contains actions such as <code>paste</code> which preserves the clipboard, <code>delete_right</code> which deletes a single character to the right of the cursor, and <code>words_left</code> and <code>words_right</code> which move the cursor by a given number of words. Finally, it also defines <code>cut_word_left</code>, <code>cut_word_right</code>, <code>copy_word_left</code>, <code>copy_word_right</code>, <code>select_line_start</code>, <code>select_line_end</code>, and <code>line_middle</code> to manipulate text at the word and line level.</p> </li> <li> <p><code>edit_command.py</code>: This file defines the <code>edit_command</code> action which is used to perform more complex editing commands that are composed of an action and a modifier (e.g. \"select line\", \"copy word\").  It maps combinations of actions and modifiers to Talon actions, including compound actions such as \"go before line\", \"go after line\", \"delete word\", and \"cut to clipboard line\".</p> </li> <li> <p><code>edit_command_modifiers.py</code>: This file defines the <code>EditModifier</code> class and a capture that is used to parse the modifier part of the edit command. It also provides callbacks for each type of modifier such as <code>document</code>, <code>paragraph</code>, <code>word</code>, and <code>line</code> for use in the <code>edit_command</code> action. The modifiers are defined in <code>edit_command_modifiers.talon-list</code>.</p> </li> <li> <p><code>edit_command_actions.py</code>: This file defines the <code>EditAction</code> dataclasses (<code>EditSimpleAction</code>, <code>EditInsertAction</code>, <code>EditWrapAction</code>, and <code>EditFormatAction</code>) and a capture that is used to parse the action part of the edit command. It also provides callbacks for each type of action such as <code>select</code>, <code>goBefore</code>, <code>copyToClipboard</code>, and <code>delete</code> for use in the <code>edit_command</code> action.  The simple actions are defined in <code>edit_command_actions.talon-list</code>.</p> </li> <li> <p><code>edit_navigation_steps.py</code>: This file provides support for relative navigation. The <code>navigation_step</code> capture parses a spoken form of navigation (e.g. \"go 2 words left\") into a <code>NavigationStep</code> dataclass, which is then used by <code>perform_navigation_steps</code> to execute the navigation.</p> </li> <li> <p><code>edit_paragraph.py</code>: This file provides actions for navigating and selecting paragraphs. It includes actions like <code>paragraph_start</code>, <code>paragraph_end</code>, <code>select_paragraph</code>, <code>delete_paragraph</code>, <code>cut_paragraph</code>, <code>copy_paragraph</code>, and <code>paste_paragraph</code>. It also implements the helper functions <code>is_line_empty</code>, <code>extend_paragraph_start_with_success</code>, and <code>extend_paragraph_end_with_success</code> that are used to manipulate paragraphs.</p> </li> <li> <p><code>delimiter_pair.py</code>: This file defines actions for inserting and wrapping text with delimiter pairs. It introduces the <code>delimiter_pair</code> capture which parses a delimiter pair and the <code>delimiter_pair_insert</code> and <code>delimiter_pair_wrap_selection</code> actions that use the capture. The delimiter pairs are defined in <code>delimiter_pair.talon-list</code>.</p> </li> <li> <p><code>insert_between.py</code>: This file defines a helper action <code>insert_between</code> that can be used to insert text with the cursor in between.</p> </li> <li> <p><code>edit.talon</code>: This file contains the Talon code that binds spoken commands to the actions defined in the other files. It implements commands such as \"select line\", \"clear all\", \"zoom in\", \"find it\", \"go left\", \"select left\", \"indent\", \"clear right\", \"copy that\", \"cut that\", \"paste that\", \"clone that\", \"new line above\", \"padding\", and \"undo that\". It also includes a rule that maps <code>&lt;user.edit_action&gt; &lt;user.edit_modifier&gt;</code> to <code>user.edit_command</code>.</p> </li> </ul> <p>In summary, these files work together to provide a comprehensive and extensible editing framework. The OS-specific files define the basic actions, while the other files provide more advanced features and abstractions for use in <code>edit.talon</code>.</p> <p>The lists used are: *   <code>edit_command_modifiers.talon-list</code> defines the list of modifiers used by <code>edit_command.py</code>. *   <code>edit_command_actions.talon-list</code> defines the list of actions used by <code>edit_command.py</code>. *  <code>delimiter_pair.talon-list</code> defines the list of delimiter pairs used by <code>delimiter_pair.py</code>.</p>"},{"location":"core/edit_text_file/","title":"edit_text_file","text":"<p>This directory provides functionality for opening commonly edited files with a user's preferred text editor. It consists of a few key files that work together:</p> <ul> <li> <p><code>edit_text_file.talon</code> defines a user command <code>user.edit_text_file</code> that takes the name of a file as an argument, passes that to the <code>user.edit_text_file</code> action defined in <code>edit_text_file.py</code>, waits 500ms, and then moves the cursor to the end of the file. This command is meant to be triggered using Talon voice commands.</p> </li> <li> <p><code>edit_text_file.py</code> implements the <code>user.edit_text_file</code> action, which opens the given file in the user's preferred text editor. It uses a platform-specific approach to open the file:</p> <ul> <li>Windows: Uses <code>os.startfile</code> with the <code>\"edit\"</code> argument which attempts to open the file in the associated text editor, and if that fails, it uses <code>\"open\"</code> which opens a dialog to let the user choose an editor.</li> <li>macOS: Uses <code>/usr/bin/open -t</code> which attempts to open the file in a text editor.</li> <li>Linux: Uses <code>xdg-open</code>, which may or may not open a text editor. If <code>xdg-open</code> isn't found, it will notify the user. It is important to note that this will fail if the user's <code>$EDITOR</code> is set to a terminal editor such as <code>nano</code> or <code>vim</code>.</li> </ul> <p>The <code>edit_text_file.py</code> file also defines the <code>get_full_path</code> function. If the given file argument is not an absolute path, it will resolve it as being relative to the root of the repository.</p> </li> <li> <p><code>edit_text_file_list.talon-list</code> defines the <code>user.edit_text_file</code> list. This list is used by Talon to provide a set of suggestions when using the <code>user.edit_text_file</code> command. It contains a number of common talon files and other files that a user might want to quickly edit, including some that are outside the current directory. This is why the <code>get_full_path</code> function is so important.</p> </li> </ul>"},{"location":"core/file_extension/","title":"file_extension","text":"<p>The <code>community/core/file_extension</code> directory provides a way to speak file extensions using Talon. It defines a list of file extensions that can be used in other Talon scripts.</p> <p>The core logic is in <code>file_extension.py</code>. This file defines a Talon module that declares a list named <code>file_extension</code>. This list is populated with key-value pairs read from <code>file_extensions.csv</code> or, if that file does not exist, default values specified in the <code>_file_extensions_defaults</code> dictionary. The keys in the dictionary are the spoken forms of the file extensions, and the values are the actual file extensions themselves. The <code>@track_csv_list</code> decorator automatically creates a <code>file_extensions.csv</code> to allow users to add or change the file extensions.</p> <p>The <code>file_extension.talon</code> file defines a simple Talon rule that allows users to speak the file extension. The rule <code>{user.file_extension}: \"{file_extension}\"</code> states that when a user speaks a phrase from the <code>user.file_extension</code> list, the corresponding file extension will be inserted into the text field. The <code>user.file_extension</code> list is populated by the <code>file_extension.py</code> script.</p>"},{"location":"core/formatters/","title":"formatters","text":"<p>The <code>community/core/formatters</code> directory contains the core logic and configuration for text formatting within the Talon system. This system allows users to transform dictated text into various formats, such as camel case, snake case, or quoted strings.</p> <p>The primary component is <code>formatters.py</code>, which defines several classes that perform the actual formatting:</p> <ul> <li><code>Formatter</code>: An abstract base class for all formatters, defining the <code>format</code> and <code>unformat</code> methods.</li> <li><code>CustomFormatter</code>: A formatter that takes format and unformat functions as arguments.</li> <li><code>CodeFormatter</code>: A formatter that splits text into words, applies a format to the first word and the rest of the words, and adds delimiters between the words.</li> <li><code>TitleFormatter</code>: A formatter that transforms text into title case.</li> <li><code>CapitalizeFormatter</code>: A formatter that capitalizes the first word of a text.</li> <li><code>SentenceFormatter</code>: A formatter that capitalizes the first word of a text if it's not already capitalized.</li> </ul> <p>The <code>formatters.py</code> file also defines helper functions for capitalization, lowercasing, and removing code formatting.  It includes a list of formatters called <code>formatter_list</code> that is used to initialize a <code>formatters_dict</code>. It also defines Talon actions for formatting text and reformatting the last phrase and selection. The most important functions for formatting text are <code>format_phrase</code> and <code>format_text_without_adding_to_history</code>, which are used to apply a chain of formatters to a text.</p> <p>The other files in this directory are Talon lists that are used to define how users will activate each formatter:</p> <ul> <li><code>word_formatter.talon-list</code>: Defines a list <code>user.word_formatter</code> containing NOOP, TRAILING_SPACE, CAPITALIZE_FIRST_WORD, and TRAILING_SPACE,CAPITALIZE_FIRST_WORD.</li> <li><code>code_formatter.talon-list</code>: Defines a list <code>user.code_formatter</code> containing words that map to a comma separated list of formatters in formatters.py. For example, the word \"camel\" will apply the <code>PRIVATE_CAMEL_CASE</code> formatter. These formatters are typically used for code.</li> <li><code>prose_formatter.talon-list</code>: Defines a list <code>user.prose_formatter</code> containing words that map to a comma separated list of formatters in formatters.py. For example, the word \"sentence\" will apply the <code>CAPITALIZE_FIRST_WORD</code> formatter. These formatters are typically used for prose.</li> <li><code>reformatter.talon-list</code>: Defines a list <code>user.reformatter</code> containing words that map to a comma separated list of formatters in formatters.py. For example, the word \"unformat\" will apply the <code>REMOVE_FORMATTING</code> formatter. These formatters are typically used for reformatting.</li> </ul> <p>These files work together to provide a flexible and extensible system for formatting text in Talon. The Python code defines the logic of the formatters, while the Talon lists allow users to easily apply those formatters to their dictated text.</p>"},{"location":"core/help/","title":"help","text":"<p>The <code>community/core/help</code> directory contains files that implement a help system for Talon. This system provides information about available commands, contexts, and other aspects of the Talon configuration.</p> <p>The most important files are:</p> <ul> <li> <p><code>help.talon</code>: This file defines the voice commands to trigger the help system. It contains commands to display help for various elements like the alphabet, symbols, numbers, punctuation, modifiers, special keys, function keys, and arrows. It also includes commands to toggle the scope display, search for commands, display help for specific contexts, formatters and reformatters and to open the main help window.</p> </li> <li> <p><code>help_open.talon</code>: This file defines the voice commands that are available when the help window is open. It includes commands to navigate through help pages, select a specific context by index, refresh, and close the help window.</p> </li> <li> <p><code>help_scope_open.talon</code>: This file defines the voice command to toggle the scope display.</p> </li> <li> <p><code>help.py</code>: This Python file contains the core logic for the help system. It manages the display of help information in an ImGui window, including:</p> <ul> <li>Fetching and organizing data about contexts, commands, and lists.</li> <li>Displaying paginated lists of contexts and commands.</li> <li>Filtering and searching commands.</li> <li>Handling navigation, selection, and display of help information.</li> <li>Managing the formatting and display of information.</li> <li>Provides actions to trigger the display of help information in various formats, such as the list of available formatters, or active contexts only.</li> </ul> </li> <li> <p><code>help_scope.py</code>: This Python file implements a window to display the current Talon scope, including active modes, tags, and other relevant information. It allows the user to view the current state of Talon and is useful for debugging and understanding the system's behavior.</p> </li> </ul> <p>These files work together to provide a comprehensive help system:</p> <ol> <li>The user triggers a help command defined in <code>help.talon</code>.</li> <li>The <code>help.py</code> script opens an ImGui window and renders the requested information.</li> <li>The user can navigate through the help system using commands defined in <code>help_open.talon</code>.</li> <li>The user can toggle the scope display using a command defined in <code>help_scope_open.talon</code>, which is rendered by <code>help_scope.py</code>.</li> </ol> <p>The system allows users to discover and understand the available commands, contexts, and settings in their Talon configuration.</p>"},{"location":"core/homophones/","title":"homophones","text":"<p>The <code>community/core/homophones</code> directory contains files that enable the selection of homophones (words that sound alike but have different spellings and meanings) using Talon. This functionality is triggered by voice commands and displays the options in a GUI.</p> <p>Here's a breakdown of the key files:</p> <ul> <li> <p><code>homophones.talon</code>: This file contains the Talon commands for interacting with the homophone functionality. It defines the following commands:</p> <ul> <li><code>phones &lt;user.homophones_canonical&gt;</code>: Shows the homophones for a word, using a list of canonical homophones defined in <code>homophones.py</code>.</li> <li><code>phones that</code>: Shows homophones for the currently selected word or the word under the cursor.</li> <li><code>phones force &lt;user.homophones_canonical&gt;</code>: Forces the homophone GUI to appear, even if a quick replacement would normally occur.</li> <li><code>phones force</code>: Forces the homophone GUI to appear for the current selection.</li> <li><code>phones hide</code>: Hides the homophone GUI.</li> <li><code>phones word</code>: Selects the current word and shows its homophones.</li> <li><code>phones [&lt;user.ordinals&gt;] word left</code>: Selects one or more words to the left and shows their homophones.</li> <li><code>phones [&lt;user.ordinals&gt;] word right</code>: Selects one or more words to the right and shows their homophones.</li> </ul> </li> <li> <p><code>homophones_open.talon</code>: This file defines actions to perform when the homophone GUI is open.</p> <ul> <li><code>choose &lt;user.formatters&gt; &lt;number_small&gt;</code>: Selects a homophone from the open GUI by number and inserts it into the text. This action is triggered by <code>user.choose()</code> (defined elsewhere, commonly in <code>formatters.talon</code>).</li> </ul> </li> <li> <p><code>homophones.csv</code>: This file contains the list of homophones. Each line represents a group of homophones, with words separated by commas. The first word in each line is considered the canonical word, which is used by the <code>&lt;user.homophones_canonical&gt;</code> list.</p> </li> <li> <p><code>homophones.py</code>: This Python file defines the logic behind the homophone functionality. It does the following:</p> <ul> <li>Parses the <code>homophones.csv</code> file and creates a dictionary where keys are words and values are the list of their homophones. It updates this on every change to the file, allowing you to update homophones without restarting Talon.</li> <li>Provides an <code>imgui</code> GUI for displaying homophone choices.</li> <li>Handles the logic for showing and hiding the homophone GUI.</li> <li>Implements quick replacement logic when a word has only one homophone, unless forced.</li> <li>Provides actions for showing and selecting homophones.</li> <li>It utilizes an <code>imgui</code> to generate the user interface.</li> </ul> </li> </ul> <p>These files work together to provide a comprehensive homophone selection system. The user triggers the functionality with voice commands from <code>homophones.talon</code>, which then calls functions in <code>homophones.py</code> to present the choices from <code>homophones.csv</code> in a GUI, which is then interacted with by the <code>choose</code> command from <code>homophones_open.talon</code> to make the selection.</p>"},{"location":"core/keys/","title":"keys","text":"<p>The <code>community/core/keys</code> directory provides a set of configuration files for mapping spoken words to keyboard keys in the Talon voice control system. It includes definitions for letters, numbers, symbols, function keys, special keys, modifier keys, and keypad keys, organized in <code>.talon-list</code> files and used in <code>keys.talon</code> and <code>keys.py</code>.</p> <p>The <code>mac</code> subdirectory contains macOS-specific configurations. It includes: *   <code>special_key.talon-list</code>, which maps names such as \"end\", \"home\", and \"minus\" to their respective key equivalents on macOS. *   <code>modifier_key.talon-list</code>, which defines mappings for modifier keys like \"control\" (to \"ctrl\"), \"super\" and \"command\" (to \"cmd\"), and \"option\" (to \"alt\").</p> <p>The <code>win</code> subdirectory contains Windows and Linux configurations, which are largely similar. It includes: *   <code>special_key.talon-list</code>, which maps names such as \"end\", \"wipe\", and \"delete\" to their corresponding keys on Windows and Linux. *   <code>modifier_key.talon-list</code>, which defines mappings for modifier keys like \"alt\", \"control\", \"shift\", and \"super\" and aliases from other operating systems.</p> <p>The directory contains several key definition files that are not specific to any operating system:</p> <ul> <li><code>arrow_key.talon-list</code> defines the basic arrow keys, mapping words like \"down\", \"left\", \"right\", and \"up\" to their corresponding key values.</li> <li><code>number_key.talon-list</code> defines number keys, mapping words like \"zero\", \"one\", \"two\", etc., to their number key equivalents.</li> <li><code>function_key.talon-list</code> defines function keys (F1-F20), mapping phrases like \"f one\", \"f two\" etc. to their function key equivalents.</li> <li><code>letter.talon-list</code> defines a phonetic alphabet, mapping words like \"air\", \"bat\", and \"cap\" to their letter key equivalents. This improves the recognition accuracy when speaking letters.</li> <li><code>keypad_key.talon-list</code> defines the keys on a numerical keypad, mapping phrases like \"key pad zero\", \"key pad one\", etc. to their keypad equivalents.</li> </ul> <p>These lists are used by the core files in this directory:</p> <ul> <li><code>keys.talon</code> contains Talon code that defines grammar rules for using the keys defined in the <code>.talon-list</code> files. It enables the spoken triggering of keys, letter combinations, and modified key combinations, and includes support for capitalization.</li> <li><code>keys.py</code> defines the lists used in the other files, and also the <code>modifiers</code>, <code>key</code>, and <code>keys</code> capture rules that the <code>keys.talon</code> file uses. It also defines a mapping for symbol and punctuation keys, which are available for use both in dictation and command mode.</li> </ul> <p>In summary, the files in this directory provide a comprehensive set of tools for defining and using keyboard keys in Talon, allowing users to control their computer with spoken commands. The directory provides both platform-specific and platform-agnostic key mappings, and it includes definitions for letters, numbers, symbols, function keys, special keys, modifier keys, and keypad keys. These files are used by <code>keys.talon</code> to create rules for spoken key combinations, and <code>keys.py</code> to define the lists and capture rules.</p>"},{"location":"core/keys/mac/","title":"mac","text":"<p>The <code>community/core/keys/mac</code> directory contains configuration files that define special and modifier keys for macOS. These files are used by the Talon voice control system.</p> <ul> <li> <p><code>special_key.talon-list</code> defines a list of special keys and their corresponding Talon commands. This file maps user-friendly names (e.g., \"end\", \"home\", \"minus\") to their respective key equivalents for macOS. For example, saying \"wipe\" or \"delete\" will trigger the backspace key, and saying \"forward delete\" will trigger the delete key.</p> </li> <li> <p><code>modifier_key.talon-list</code> defines a list of modifier keys for macOS. This file provides a mapping between common modifier key names and their Talon equivalents. For example, \"control\" maps to \"ctrl\", \"super\" and \"command\" map to \"cmd\", \"option\" maps to \"alt\", and \"globe\" maps to \"fn\".</p> </li> </ul> <p>These files work together to provide a user-friendly way to trigger keys and modifier keys on macOS using Talon voice commands.</p>"},{"location":"core/keys/win/","title":"win","text":"<p>The <code>community/core/keys/win</code> directory contains configuration files for keys on Windows and Linux.</p> <p>The <code>special_key.talon-list</code> file defines a list of special keys. This list is used to map spoken words to specific keyboard keys. For instance, saying \"end\" will trigger the \"End\" key, and saying \"wipe\" or \"delete\" will trigger \"Backspace\". Some keys like \"menu\" and \"print screen\" are included as well.</p> <p>The <code>modifier_key.talon-list</code> file defines a list of modifier keys. This list maps words to modifier keys, like \"alt\", \"control\", \"shift\", and \"super\" (which is the Windows key). It also defines aliases for other operating systems; for example, \"command\" maps to \"ctrl\" on Windows and Linux, and \"option\" maps to \"alt\".</p>"},{"location":"core/menu_choose/","title":"menu_choose","text":"<p>The <code>community/core/menu_choose</code> directory provides functionality for selecting items from menus using voice commands.</p> <p>The core logic is in <code>menu_choose.py</code>, which defines two actions:   * <code>choose(number_small: int)</code>: This action moves down the menu the specified number of times (minus one) and then presses enter.   * <code>choose_up(number_small: int)</code>: This action moves up the menu the specified number of times and then presses enter.</p> <p><code>menu_choose.talon</code> defines the voice commands that trigger the actions:   *   <code>choose &lt;number_small&gt;</code>: Executes the <code>user.choose(number_small)</code> action, selecting the nth item in the menu.   *   <code>choose up &lt;number_small&gt;</code>: Executes the <code>user.choose_up(number_small)</code> action, selecting the nth item counting from the bottom of the menu.</p> <p>Together, these files allow a user to navigate and select items from menus using simple voice commands.</p>"},{"location":"core/modes/","title":"modes","text":"<p>The <code>community/core/modes</code> directory contains files that define and manage different modes of operation for Talon, the voice control system. These modes allow for context-specific behavior and enable or disable certain features, commands, and actions.</p> <p>Here's a breakdown of the key files and how they work together:</p> <ul> <li><code>modes.py</code>: This file defines the core logic for managing modes, including the \"sleep\" mode. It sets up contexts for when Talon is in and out of sleep mode and provides actions to enable and disable Talon's speech recognition, as well as Dragon's command mode, if it's being used.</li> <li><code>sleep_mode.talon</code>: This file defines the behavior of Talon when in \"sleep\" mode. It disables mouse pop actions and sets up specific, strict wake commands that must be spoken with silence before and after, to prevent accidental activation, and it uses repeaters to handle the case where the user may repeat the wake command before the speech timeout is hit.</li> <li><code>sleep_mode_wav2letter.talon</code>: This file is specific to the <code>wav2letter</code> speech engine. It is designed to prevent Talon from waking up too easily in sleep mode when using <code>wav2letter</code>, and it is best not to have any other commands here.</li> <li><code>command_and_dictation_mode.talon</code>: This file manages the \"command\" and \"dictation\" modes. It defines commands to switch between these modes and disables the \"sleep\" mode when entering either of the other modes. It also disables GDB commands when entering dictation mode and clears the language mode.</li> <li><code>modes_not_dragon.talon</code>: This file defines common commands for speech engines other than Dragon. It includes commands to wake and sleep Talon, as well as a command to sleep all (which disables various other features such as the switcher, history, homophones, and help windows, and also puts the mouse to sleep). These commands allow for more flexibility in waking and sleeping Talon when not using Dragon, because they allow an optional phrase after the command, to avoid waiting for the speech timeout before talking to a human.</li> <li><code>language_modes.py</code>: This file defines how Talon handles different programming language modes. It maps spoken forms and file extensions to language IDs and allows users to force a language mode, overriding the automatic detection based on file extensions.</li> <li><code>code_languages.py</code>: This file contains a list of supported code languages, including their IDs, spoken forms, and file extensions. It also includes a map of specific filenames to language identifiers. These are used by <code>language_modes.py</code> to determine the appropriate code language.</li> <li><code>dictation_mode.talon</code>: This file defines the behavior of Talon in \"dictation\" mode. It includes commands for inserting text, navigating the cursor, selecting and deleting text, formatting text, and correcting dictation errors. The commands here generally use <code>user.dictation_insert()</code> to properly handle auto-capitalization and spacing.</li> <li><code>dragon_mode.talon</code>: This file defines commands specific to the Dragon speech engine. It includes commands to switch between \"dragon mode\" and \"talon mode\", and to activate or deactivate Dragon's command mode.</li> <li><code>modes_dragon.talon</code>: This file defines commands for putting Talon to sleep and waking it up when using Dragon. It also includes a \"sleep all\" command which also puts Dragon to sleep. These commands are similar to those in <code>modes_not_dragon.talon</code>, but they also control Dragon's state. Like the corresponding commands in <code>modes_not_dragon.talon</code>, they allow for an optional phrase after the command.</li> <li><code>sleep_mode_pop_twice_to_wake.py</code>: This file implements a feature where a double \"pop\" noise can wake Talon from sleep mode. It defines settings for the minimum and maximum time between two pops to be considered a double pop. It also checks if the zoom mouse is enabled before waking to prevent conflicts.</li> <li><code>language_modes.talon</code>: This file defines commands for forcing a particular language mode and showing the currently forced language mode, or clearing a forced mode.</li> </ul> <p>In summary, this directory provides a comprehensive system for managing different modes in Talon, including sleep, command, dictation, and language modes. These modes can be used to tailor Talon's behavior to specific contexts and use cases.</p>"},{"location":"core/mouse_grid/","title":"mouse_grid","text":"<p>The <code>community/core/mouse_grid</code> directory contains the code for a mouse grid system in Talon. This system allows users to quickly move the mouse cursor to specific locations on the screen using a grid-based approach. The core logic is in <code>mouse_grid.py</code>, with supporting Talon files for commands and tags.</p> <ul> <li> <p><code>mouse_grid_always.talon</code> defines commands that are always available for interacting with the mouse grid. These commands include:</p> <ul> <li><code>mouse grid</code>: Activates the grid on the primary screen.</li> <li><code>grid win</code>: Places the grid on the current window.</li> <li><code>grid &lt;user.number_key&gt;+</code>: Activates the grid and narrows it to the specified number.</li> <li><code>grid screen [&lt;number&gt;]</code>: Activates the grid on the specified screen number.</li> </ul> </li> <li> <p><code>mouse_grid.talon</code> defines a command <code>M grid</code> that is no longer recommended, and instead directs the user to use the <code>mouse grid</code> command. It also adds the <code>user.mouse_grid_enabled</code> tag, which is deprecated.</p> </li> <li> <p><code>mouse_grid_open.talon</code> contains commands that are available when the mouse grid is active, indicated by the <code>user.mouse_grid_showing</code> tag. These commands include:</p> <ul> <li><code>&lt;user.number_key&gt;</code>: Narrows the grid to the corresponding number.</li> <li><code>grid (off | close | hide)</code>: Closes the grid.</li> <li><code>grid reset</code>: Resets the grid to the full screen.</li> <li><code>grid back</code>: Moves the grid back to the previous state.</li> </ul> </li> <li> <p><code>mouse_grid.py</code> contains the core Python logic for the mouse grid. It defines the <code>MouseSnapNine</code> class, which handles the grid's state, drawing, and interaction. Key functions include:</p> <ul> <li><code>setup</code>: Initializes the grid, setting the screen and rect based on the arguments or defaults.</li> <li><code>show</code>: Activates the grid by registering the draw function with the canvas, and disabling tracking control if active.</li> <li><code>close</code>: Deactivates the grid, and re-enables tracking control.</li> <li><code>draw</code>: Draws the grid on the canvas, including lines, numbers, and an optional zoomed view.</li> <li><code>calc_narrow</code>: Calculates the new rectangle for a given grid number.</li> <li><code>narrow</code>: Narrows the grid to a specific section and moves the mouse cursor to the center of that section.</li> <li><code>update_screenshot</code>: Updates the image used for the zoom view.</li> <li><code>draw_zoom</code>: Draws the zoomed in view of the current selection.</li> <li><code>save_state</code>: Saves the current state so the user can go back to it.</li> <li><code>go_back</code>: Sets the grid back to a previous state. The <code>GridActions</code> class defines the actions called by the talon files to implement the features.</li> </ul> </li> </ul> <p>The files work together to provide a fully functional mouse grid system: <code>mouse_grid_always.talon</code> and <code>mouse_grid.talon</code> provide the initial commands to activate the grid, while <code>mouse_grid_open.talon</code> contains the commands for when the grid is showing.  The <code>mouse_grid.py</code> script handles the drawing and logic of the grid based on the commands from the .talon files. The files are set up to be easily customizable using user settings.</p>"},{"location":"core/navigation/","title":"navigation","text":"<p>The <code>community/core/navigation</code> directory contains files that define actions for navigating forward and backward, using different keybindings based on the context.</p> <p>The file navigation.talon defines a Talon tag <code>user.navigation</code> and maps the spoken commands \"go back\" and \"go forward\" to their corresponding user actions, which are defined in navigation.py.</p> <p>The file navigation.py defines the core logic for navigation, including the following:</p> <ul> <li>A <code>navigation</code> module tag is created.</li> <li>A browser context is defined, using the <code>browser</code> tag, and maps the \"go back\" and \"go forward\" user actions to the browser's native go back and go forward actions.</li> <li>A mac context is defined, using the <code>mac</code> os tag, and maps the \"go back\" and \"go forward\" user actions to the <code>cmd-[</code> and <code>cmd-]</code> keybindings.</li> <li>Default \"go back\" and \"go forward\" actions are defined using the <code>alt-left</code> and <code>alt-right</code> keybindings for contexts that do not match the browser or mac context.</li> </ul> <p>The overall purpose of the files in <code>community/core/navigation</code> is to provide a consistent set of voice commands for navigation with different keybindings based on the current context (e.g., when in a browser vs. on MacOS).</p>"},{"location":"core/numbers/","title":"numbers","text":"<p>The <code>community/core/numbers</code> directory contains files for parsing and representing numbers using voice commands in Talon. It includes both prefixed and unprefixed number input, as well as ordinal numbers.</p> <p>The core logic for parsing numbers is in <code>numbers.py</code>. This file defines functions to:</p> <ul> <li>Convert spoken number words (e.g., \"one\", \"twenty\", \"thousand\") to integers.</li> <li>Parse number phrases of mixed scales (e.g. \"one million five hundred thousand\") into numeric strings.</li> <li>Handle \"oh\" variants (e.g., \"oh five\" for \"05\") and double-digit variants (e.g., \"five one\" for \"51\").</li> <li>Parse decimal numbers (e.g., \"one dot two three\").</li> <li>Parse comma separated number sequences (e.g., \"one comma two\").</li> <li>Parse colon separated number sequences (e.g., \"one colon two\").</li> <li>Handle negative numbers (e.g., \"negative one\").</li> </ul> <p>It exposes several captures, including:</p> <ul> <li><code>digit_string</code>:  Parses a sequence of digits as a string.</li> <li><code>digits</code>: Parses a sequence of digits as an integer.</li> <li><code>number_string</code>: Parses a number phrase into a string.</li> <li><code>number</code>: Parses a number phrase into an integer.</li> <li><code>number_signed_string</code>: Parses a signed number phrase into a string.</li> <li><code>number_signed</code>: Parses a signed number phrase into an integer.</li> <li><code>number_prose_with_dot</code>, <code>number_prose_with_comma</code>, <code>number_prose_with_colon</code>: Parses number sequences with dots, commas, or colons.</li> <li><code>number_prose_unprefixed</code>: Parses a number with or without dot, comma or colon separated sequences into a string.</li> <li><code>number_prose_prefixed</code>: Parses a number with a \"numb\" or \"numeral\" prefix (e.g., \"numb one\").</li> <li><code>number_small</code>: Parses an integer between 0 and 99.</li> <li><code>number_signed_small</code>: Parses a signed integer between -99 and 99.</li> </ul> <p>The file also defines a list of small numbers (<code>number_small</code>) from 0 to 99, including common spoken variants, and a <code>unprefixed_numbers</code> tag.</p> <p>The file <code>ordinals.py</code> defines lists of ordinal words and provides captures for them. It includes:</p> <ul> <li><code>ordinals</code>: A list of ordinal words (e.g. \"first\", \"second\", \"twentieth\") from 1 to 99.</li> <li><code>ordinals_small</code>: A list of ordinal words from 1 to 20.</li> <li><code>ordinals</code>: A capture that returns an ordinal as an integer.</li> <li><code>ordinals_small</code>: A capture that returns a small ordinal as an integer.</li> </ul> <p>The files <code>numbers_unprefixed.talon</code> and <code>numbers_prefixed.talon</code> provide the Talon bindings for the captures defined in <code>numbers.py</code>.  <code>numbers_unprefixed.talon</code> tags the <code>number_prose_unprefixed</code> capture with the <code>user.unprefixed_numbers</code> tag, allowing number prose to be used without a prefix. <code>numbers_prefixed.talon</code> provides a rule for using <code>number_prose_prefixed</code> prefixed with \"numb\" or \"numeral\".</p> <p>In summary, this directory provides a comprehensive system for voice-based number input including both prefixed and unprefixed numbers, ordinal numbers, and support for various number formats.</p>"},{"location":"core/screens/","title":"screens","text":"<p>The <code>community/core/screens</code> directory contains files for managing and displaying information about multiple screens connected to a computer.</p> <p>The <code>screens.talon</code> file at https://github.com/talonhub/community/blob/main/core/screens/screens.talon provides a command for showing screen numbers using the <code>user.screens_show_numbering()</code> action.</p> <p>The <code>screens.py</code> file at https://github.com/talonhub/community/blob/main/core/screens/screens.py implements the actions used in <code>screens.talon</code> using the Talon API. It defines a number of functions and actions:</p> <ul> <li><code>screens_show_numbering()</code>: This action iterates through the available screens, then calls the <code>show_screen_number()</code> function to display a number on each one.</li> <li><code>screens_get_by_number(screen_number: int) -&gt; ui.Screen</code>: This action returns a <code>ui.Screen</code> object for a given screen number.</li> <li><code>screens_get_previous(screen: ui.Screen) -&gt; ui.Screen</code>: This action returns a <code>ui.Screen</code> object representing the screen before the one provided.</li> <li><code>screens_get_next(screen: ui.Screen) -&gt; ui.Screen</code>: This action returns a <code>ui.Screen</code> object representing the screen after the one provided.</li> <li><code>get_screen_by_offset(screen: ui.Screen, offset: int) -&gt; ui.Screen</code>: This helper function is used by <code>screens_get_previous()</code> and <code>screens_get_next()</code>, calculating the <code>ui.Screen</code> object that is offset by the given amount from the current one.</li> <li><code>show_screen_number(screen: ui.Screen, number: int)</code>: This helper function creates a <code>Canvas</code> on the specified screen and displays the number on it using the <code>on_draw()</code> callback. The canvas is displayed for three seconds before being closed.</li> </ul>"},{"location":"core/snippets/","title":"snippets","text":"<p>The <code>community/core/snippets</code> directory contains the code for handling code snippets in Talon. It includes the logic for parsing, inserting, and managing snippets.</p> <p>The <code>snippets</code> subdirectory contains a collection of <code>.snippet</code> files, each defining one or more code snippets. The README.md file provides a detailed explanation of the custom <code>.snippet</code> file format, which allows for multiple snippets per file, context-specific snippets, and variable tab stops within snippets.  The snippets are language-aware, meaning that the code inserted can vary based on the selected language when using the snippet. Most of the snippets have multiple language versions included in the same file. Some of the more interesting snippets include:</p> <ul> <li><code>tryStatement.snippet</code>: Inserts a <code>try</code> block for JavaScript, Java, and Python.</li> <li><code>global.snippet</code>: Inserts a code block. It uses markdown code fence.</li> <li><code>constructorDeclaration.snippet</code>: Inserts a constructor declaration for JavaScript, Java, and Python.</li> <li><code>commentBlock.snippet</code>: Inserts a multi-line comment block for C, Javascript, Java, Python, and HTML.</li> <li><code>typescript.snippet</code>: Contains a snippet for a Typescript interface declaration.</li> <li><code>javascript.snippet</code>: Contains multiple JavaScript specific snippets.</li> <li><code>lua.snippet</code>: Contains Lua specific snippets.</li> <li><code>python.snippet</code>: Contains multiple Python specific snippets.</li> <li><code>html.snippet</code>: Contains multiple HTML specific snippets.</li> <li><code>talon.snippet</code>: Contains a Talon specific snippet for a voice command declaration.</li> <li><code>markdown.snippet</code>: Contains a snippet for inserting a markdown link.</li> </ul> <p>The other files in the directory provide the functionality to use the snippets.</p> <ul> <li> <p><code>snippets_insert_raw_text.py</code> contains the logic for inserting a snippet as raw text without editor support. It parses the snippet body to identify tab stops and variables that can be populated or used for cursor placement.</p> </li> <li> <p><code>snippets.py</code> contains the core logic for managing and using snippets. It defines Talon lists of snippets and wrapper snippets, parses snippets from <code>.snippet</code> files, handles context matching based on code language, and provides actions for getting and inserting snippets. This file uses the <code>code_languages</code> module from <code>community/core/modes</code> to determine the active language. This file also watches the snippet directory for changes to update the available snippets. It groups snippets by language and sets up the appropriate Talon context for each language.</p> </li> <li> <p><code>snippet_types.py</code> defines dataclasses to represent a snippet, its variables, insertion snippets, and wrapper snippets.</p> </li> <li> <p><code>snippets_insert.py</code> defines the Talon actions for inserting snippets, including the ability to insert a snippet by name and to substitute variables within the snippet.</p> </li> <li> <p><code>snippets_parser.py</code> provides functionality for parsing the <code>.snippet</code> files, extracting contexts, variables, and snippet bodies. It handles the <code>---</code> delimiter to separate snippet documents, <code>-</code> to separate context and body, and <code>:</code> for key value pairs. It also handles tab stops, variables, and default values. It has error handling for invalid snippets.</p> </li> <li> <p><code>snippets.talon</code> defines the Talon commands for using the snippets, including <code>snip {user.snippet}</code> for inserting a snippet and <code>snip {user.snippet_with_phrase} &lt;user.text&gt;</code> for inserting a snippet that utilizes a phrase.</p> </li> </ul> <p>The files work together as follows:</p> <ol> <li><code>.snippet</code> files are stored in the <code>snippets</code> subdirectory, as well as in a user-defined directory. These files contain the raw text for snippets, as well as metadata like language, phrase, and insertion scope.</li> <li><code>snippets_parser.py</code> parses the <code>.snippet</code> files and extracts the individual snippets, storing them as <code>Snippet</code> objects (defined in <code>snippet_types.py</code>).</li> <li><code>snippets.py</code> watches the snippets directory for file changes. It groups the parsed snippets by language and stores them in Talon lists. This allows Talon to make available language-specific snippets in code editing contexts, via the <code>code_languages</code> module in <code>community/core/modes</code>.</li> <li>When a snippet is invoked by a Talon command (defined in <code>snippets.talon</code>),  <code>snippets_insert.py</code> uses the snippet metadata to substitute variables and insert the snippet text using <code>snippets_insert_raw_text.py</code>, which will handle cursor placement in tab stops.</li> </ol>"},{"location":"core/snippets/snippets/","title":"snippets","text":"<p>The <code>community/core/snippets/snippets</code> directory contains a collection of code snippets designed to be used with a text editor or IDE. These snippets are used to quickly insert common code structures. Each snippet is defined in its own file, named with a <code>.snippet</code> extension.</p> <p>The snippets are language-aware, meaning that the code inserted will vary based on the language selected when using the snippet. Most of the snippets have multiple language versions included in the same file.</p> <p>Here's a breakdown of some of the most interesting or important snippets:</p> <ul> <li> <p><code>tryStatement.snippet</code>: Inserts a <code>try</code> block for JavaScript, Java, and Python.</p> </li> <li> <p><code>global.snippet</code>: Inserts a code block. It uses markdown code fence.</p> </li> <li> <p><code>constructorDeclaration.snippet</code>: Inserts a constructor declaration for JavaScript, Java, and Python.</p> </li> <li> <p><code>formatString.snippet</code>: Inserts a formatted string for JavaScript, Java, and Python.</p> </li> <li> <p><code>throwException.snippet</code>: Inserts a statement to throw an exception in JavaScript, Python, and Java.</p> </li> <li> <p><code>commentBlock.snippet</code>: Inserts a multi-line comment block for C, Javascript, Java, Python, and HTML.</p> </li> <li> <p><code>ifStatement.snippet</code>: Inserts an <code>if</code> statement for JavaScript, Java, Python, and Lua.</p> </li> <li> <p><code>forLoopStatement.snippet</code>: Inserts a <code>for</code> loop for JavaScript, Java, and Python.</p> </li> <li> <p><code>functionDeclaration.snippet</code>: Inserts a function declaration for JavaScript, Java, and Python.</p> </li> <li> <p><code>elseIfStatement.snippet</code>: Inserts an <code>else if</code> statement for JavaScript, Java, Python, and Lua.</p> </li> <li> <p><code>typescript.snippet</code>: Contains a snippet for a Typescript interface declaration.</p> </li> <li> <p><code>javascript.snippet</code>: Contains multiple JavaScript specific snippets, including <code>forInLoopStatement</code>, <code>anonymousFunctionDeclarationAndCall</code>, <code>importStarStatement</code>, <code>importFromStatement</code>, <code>namedLambdaExpression</code>, <code>reactUseState</code>, and <code>reactUseEffect</code>.</p> </li> <li> <p><code>lua.snippet</code>: Contains Lua specific snippets, including <code>forInIPairs</code> and <code>forInPairs</code>.</p> </li> <li> <p><code>commentDocumentation.snippet</code>: Inserts a documentation comment for Javascript, Java, and Python.</p> </li> <li> <p><code>catchStatement.snippet</code>: Inserts a <code>catch</code> block for JavaScript, Java, and Python.</p> </li> <li> <p><code>elseStatement.snippet</code>: Inserts an <code>else</code> statement for JavaScript, Java, Python, and Lua.</p> </li> <li> <p><code>markdown.snippet</code>: Contains a snippet for inserting a markdown link.</p> </li> <li> <p><code>forEachStatement.snippet</code>: Inserts a <code>for each</code> loop for JavaScript, Java, and Python.</p> </li> <li> <p><code>whileLoopStatement.snippet</code>: Inserts a <code>while</code> loop for Javascript, Java, and Python.</p> </li> <li> <p><code>printStatement.snippet</code>: Inserts a print statement for Javascript, Java, Python, and Talon.</p> </li> <li> <p><code>switchStatement.snippet</code>: Inserts a <code>switch</code> statement for Javascript, Java, and Python.</p> </li> <li> <p><code>functionCall.snippet</code>: Inserts a function call for C, Javascript, Java, Python, and Talon.</p> </li> <li> <p><code>classDeclaration.snippet</code>: Inserts a class declaration for JavaScript, Java, and Python.</p> </li> <li> <p><code>talon.snippet</code>: Contains a Talon specific snippet for a voice command declaration.</p> </li> <li> <p><code>defaultStatement.snippet</code>: Inserts a default case for Javascript, Java, and Python.</p> </li> <li> <p><code>commentLine.snippet</code>: Inserts a single line comment for C, Javascript, Java, Json, Python, Talon, csv, HTML, and scm.</p> </li> <li> <p><code>tryCatchStatement.snippet</code>: Inserts a <code>try catch</code> block for JavaScript, Java, and Python.</p> </li> <li> <p><code>newInstance.snippet</code>: Inserts a statement to create a new instance for JavaScript, Java, and Python.</p> </li> <li> <p><code>item.snippet</code>: Inserts an item in a collection for Javascript and Python.</p> </li> <li> <p><code>python.snippet</code>: Contains multiple Python specific snippets, including <code>talonAppDeclaration</code>, <code>talonModuleClass</code>, <code>talonContextMatch</code>, <code>talonContextList</code>, and <code>talonContextClass</code>.</p> </li> <li> <p><code>html.snippet</code>: Contains multiple HTML specific snippets, including <code>element</code>, <code>attribute</code>, <code>table</code>, and <code>unorderedList</code>.</p> </li> <li> <p><code>finallyStatement.snippet</code>: Inserts a <code>finally</code> block for Javascript, Java, and Python.</p> </li> <li> <p><code>ternary.snippet</code>: Inserts a ternary operator for Javascript, Python, and Lua.</p> </li> <li> <p><code>doWhileLoopStatement.snippet</code>: Inserts a <code>do while</code> loop for Javascript and Java.</p> </li> <li> <p><code>methodDeclaration.snippet</code>: Inserts a method declaration for JavaScript.</p> </li> <li> <p><code>caseStatement.snippet</code>: Inserts a <code>case</code> statement for Javascript, Java, and Python.</p> </li> <li> <p><code>lambdaExpression.snippet</code>: Inserts a lambda expression for JavaScript, Java, and Python.</p> </li> </ul> <p>These snippets aim to increase development speed by providing easy access to common code structures. They are also designed to be language-aware, providing the appropriate syntax for a given language.</p>"},{"location":"core/text/","title":"text","text":"<p>The <code>community/core/text</code> directory contains files that define how Talon handles text input and formatting. It includes lists of words and phrases, as well as Python code to manipulate text. Here's a breakdown of the key files and how they work together:</p> <ul> <li> <p><code>currency.talon-list</code>: This file defines a list of currency symbols and their spoken forms, such as \"dollar\" and \"$\". This allows users to speak currency amounts and have them correctly inserted.</p> </li> <li> <p><code>prose_modifiers.talon-list</code>: This file lists modifiers that can be used within prose, such as \"cap\", \"no cap\", and \"no space\". These modifiers are used to change the formatting of text, for example to capitalize the next word, prevent capitalization, or remove spaces. These modifiers are referenced in <code>text_and_dictation.py</code>.</p> </li> <li> <p><code>prose_snippets.talon-list</code>: This file contains common text snippets like \"spacebar\", \"new line\", and \"open quote\". These snippets provide convenient ways to insert common text elements by voice.</p> </li> <li> <p><code>phrase_ender.talon-list</code>: This file defines a list of commands that can be used to end a phrase, such as \"over\". This is used in <code>text.talon</code> to provide both anchored and unanchored phrase commands.</p> </li> <li> <p><code>text.talon</code>: This is the main Talon script for text manipulation. It defines commands for inserting text, formatting prose, and working with the phrase history. It uses the lists defined in other files to provide functionality. Key features include:</p> <ul> <li>Inserting text with optional phrase enders.</li> <li>Formatting prose using <code>user.prose_formatter</code>.</li> <li>Inserting formatted code using <code>user.format_code</code>.</li> <li>Reformatting selections using <code>user.formatters</code>.</li> <li>Formatting individual words using <code>user.word_formatter</code>.</li> <li>Managing a phrase history with commands such as \"recent list\", \"recent repeat\", and \"recent copy.\"</li> <li>Selecting, deleting and reformatting the last phrase using \"select that\", \"nope that\", and \"nope that was\".</li> <li>Abbreviating words using \"abbreviate\" and <code>user.abbreviation</code>.</li> </ul> </li> <li> <p><code>text_and_dictation.py</code>: This Python file contains the core logic for text formatting and dictation. It defines captures for words, phrases, and prose, and handles auto-spacing and capitalization. It also provides the <code>DictationFormat</code> class, which is used to format text based on the surrounding context and applied modifiers. The <code>dictation_insert</code> action is used to insert formatted text, and <code>dictation_peek</code> peeks at surrounding text. The <code>DictationFormat</code> class is used by the various <code>prose</code> captures to provide auto spacing and capitalization. It is also used by the <code>dictation_insert</code> action for the same purpose. This file also defines the lists <code>user.hours_twelve</code>, <code>user.hours</code>, and <code>user.minutes</code>.</p> </li> <li> <p><code>phrase_history.py</code>: This Python file manages a history of recently spoken phrases. It provides actions for getting, clearing, and selecting the last phrase, as well as adding a new phrase to the history. It also provides a GUI for viewing the phrase history. The phrase history is used by commands such as \"recent repeat\", \"recent copy\", \"select that\" and \"nope that\".</p> </li> </ul> <p>In summary, these files work together to provide a comprehensive system for text input and manipulation in Talon. The <code>.talon-list</code> files define lists of words and phrases, the <code>text.talon</code> file defines commands, and the Python files contain the core logic for formatting and managing the phrase history. The <code>text_and_dictation.py</code> file is central, providing the <code>DictationFormat</code> class and the <code>dictation_insert</code> action, as well as many of the text captures used in <code>text.talon</code>.</p>"},{"location":"core/vocabulary/","title":"vocabulary","text":"<p>The <code>community/core/vocabulary</code> directory contains files that manage custom vocabulary and word replacement for Talon.</p> <p>The most important file is <code>vocabulary.py</code>, which defines how custom vocabulary is loaded, modified, and used by Talon. It provides actions to add words to the vocabulary, either as direct vocabulary entries or as replacements for other words or phrases. It uses two files to store the user's customizations: <code>words_to_replace.csv</code> (not included here) and <code>vocabulary.talon-list</code>.</p> <p><code>vocabulary.py</code> has these key features:</p> <ul> <li><code>PhraseReplacer</code>: This class handles the replacement of words and phrases. It stores phrases to be replaced in a way that prioritizes longer phrases, ensuring that <code>\"this is a test\"</code> is replaced before <code>\"this is\"</code>. It can be updated with a dictionary of phrases.</li> <li><code>on_word_map</code>: This function loads words from <code>words_to_replace.csv</code> using <code>@track_csv_list</code> and uses them to update both the <code>PhraseReplacer</code> and the <code>dictate.word_map</code> setting (used by Talon's built-in word replacement).</li> <li><code>dictate.replace_words</code>: This action is overridden to use the <code>PhraseReplacer</code> to replace words. If the phrase replacer fails, it falls back to Talon's default word replacement.</li> <li><code>_create_vocabulary_entries</code>: This helper function expands vocabulary entries to include possessives (e.g., <code>\"john\" -&gt; \"john's\"</code>) or plurals (e.g., <code>\"cat\" -&gt; \"cats\"</code>), which are added to vocabulary.</li> <li><code>_add_selection_to_file</code>: This helper adds selected text as new vocabulary entries to either <code>vocabulary.talon-list</code> or <code>words_to_replace.csv</code>. It skips adding entries that are identical to what they replace or that are already in the list.</li> <li><code>append_to_vocabulary</code>: This helper appends new vocabulary entries to <code>vocabulary.talon-list</code>, handling the different formats used in that file.</li> <li><code>get_vocabulary_file_path</code>: An action that returns the path to <code>vocabulary.talon-list</code>.</li> <li><code>add_selection_to_vocabulary</code> and <code>add_selection_to_words_to_replace</code>: These actions are used to add new vocabulary words or replacements to the appropriate files.</li> </ul> <p><code>vocabulary.talon-list</code> contains a list of custom vocabulary words and phrases. Each line is either a single word, or a colon-separated pair of a spoken form and a written form. The written form may be a quoted string.</p> <p><code>edit_vocabulary.talon</code> provides commands to add selected text to the vocabulary or to the word replacements. These commands use the actions defined in <code>vocabulary.py</code>, and allow you to optionally specify a spoken form for the new entry. The possessive and plural variants can be added automatically.</p> <p>In summary, <code>vocabulary.py</code> defines how custom vocabulary and word replacements are managed in Talon. <code>vocabulary.talon-list</code> stores custom vocabulary, and <code>edit_vocabulary.talon</code> provides the commands used to easily add new words and phrases to the vocabulary from Talon.</p>"},{"location":"core/websites_and_search_engines/","title":"websites_and_search_engines","text":"<p>The <code>community/core/websites_and_search_engines</code> directory contains files that allow users to quickly navigate to websites and perform searches using voice commands.</p> <ul> <li> <p><code>website.talon-list</code> defines a list of websites, mapping short names to URLs.  For example, \"talon home page\" maps to <code>http://talonvoice.com</code>. This list is used by voice commands to quickly navigate to the listed websites.</p> </li> <li> <p><code>search_engine.talon-list</code> defines a list of search engines, mapping short names to URLs containing the string <code>%s</code>. This string is later replaced with the user's search query. For example, \"google\" maps to <code>https://www.google.com/search?q=%s</code>.</p> </li> <li> <p><code>websites_and_search_engines.talon</code> defines the Talon voice commands for interacting with the lists defined in the <code>.talon-list</code> files. This file contains commands for opening websites by name, opening URLs from selected text or the clipboard, and searching using a specified search engine with a given query or using selected text or the clipboard as a query. For example, \"google hunt hello world\" would perform a Google search for \"hello world\".</p> </li> <li> <p><code>websites_and_search_engines.py</code> is the Python code that implements the actions used by the Talon commands. This file defines the <code>website</code> and <code>search_engine</code> lists as Talon module lists and defines functions such as <code>open_url</code> which opens a URL in the user's default browser, and <code>search_with_search_engine</code> which takes a search engine URL from the <code>search_engine</code> list, replaces the <code>%s</code> string with a URL-encoded version of the user's search query, and opens the resulting URL.</p> </li> </ul>"},{"location":"core/windows_and_tabs/","title":"windows_and_tabs","text":"<p>The <code>community/core/windows_and_tabs</code> directory contains files for managing windows and tabs across different operating systems using Talon. It includes functionality for moving, resizing, and switching between windows and tabs, as well as snapping windows to specific screen positions.</p> <p>Here's a breakdown of the key files and how they work together:</p> <ul> <li> <p><code>window_management.talon</code>: This file defines the core voice commands for window management. It uses actions defined in other files, particularly <code>window_snap.py</code>, to implement features like:</p> <ul> <li>Opening, closing, hiding, and focusing windows.</li> <li>Moving windows between screens.</li> <li>Snapping windows to predefined positions on the screen using the commands <code>snap &lt;user.window_snap_position&gt;</code>, <code>snap next [screen]</code>, <code>snap last [screen]</code>, and <code>snap screen &lt;number&gt;</code>.</li> <li>Snapping applications to specific positions or screens using the commands <code>snap &lt;user.running_applications&gt; &lt;user.window_snap_position&gt;</code>, <code>snap &lt;user.window_split_position&gt; &lt;user.running_applications&gt; &lt;user.running_applications&gt;+</code>, and <code>snap &lt;user.running_applications&gt; [screen] &lt;number&gt;</code>.</li> </ul> </li> <li> <p><code>window_snap.py</code>: This file contains the logic for snapping windows to various positions and moving windows between screens. It defines:</p> <ul> <li><code>RelativeScreenPos</code>: A class representing a window position as a fraction of the screen.</li> <li><code>_snap_positions</code>: A dictionary of predefined <code>RelativeScreenPos</code> objects with names such as \"left\", \"right\", \"top left\", and \"full\".</li> <li><code>_split_positions</code>: A dictionary of predefined layouts for splitting the screen between multiple applications.</li> <li>Actions for snapping the active window or a specific application to a predefined position, moving a window to the next or previous screen, and moving a window to a specific screen.</li> <li>An action for snapping multiple applications to the screen using a predefined layout.</li> <li>A setting <code>user.window_snap_screen</code> that defines how windows are positioned and sized when moving between different physical screens.</li> </ul> </li> <li> <p><code>windows_and_tabs_win.py</code>, <code>windows_and_tabs_mac.py</code>, and <code>windows_and_tabs_linux.py</code>: These files provide platform-specific implementations for common window and tab actions, such as closing, opening, and switching between windows and tabs. These files define <code>app</code> actions which are then used within the <code>window_management.talon</code> file.</p> <ul> <li>They define <code>app</code> actions like <code>tab_close</code>, <code>tab_next</code>, <code>window_close</code>, <code>window_hide</code>, <code>window_open</code> and platform specific actions like <code>window_hide_others</code> and <code>preferences</code>.</li> <li>They also implement <code>user</code> actions such as <code>switcher_focus_last</code> with platform-specific keybindings.</li> </ul> </li> <li> <p><code>tabs.py</code>: This file defines generic tab actions that can be used across different applications. It includes actions such as <code>tab_jump</code>, <code>tab_final</code>, <code>tab_close_wrapper</code>, and <code>tab_duplicate</code>. The <code>tab_close_wrapper</code> action is designed to allow apps to implement their own delays before closing a tab, to handle repetitions better.</p> </li> <li> <p><code>tabs.talon</code>: This file defines voice commands for tab management, utilizing the actions defined in <code>tabs.py</code> and the <code>app</code> actions defined in the platform-specific <code>windows_and_tabs</code> files.</p> </li> <li> <p><code>windows_and_tabs.py</code>: This file provides some cross-platform window cycling actions. The <code>window_next</code> and <code>window_previous</code> actions cycle through all valid windows of the active application. It defines a helper function <code>is_window_valid</code> to determine which windows to include in the cycling and a helper function <code>cycle_windows</code> which provides the window cycling logic.</p> </li> </ul> <p>In summary, these files work together to provide a comprehensive set of voice commands for managing windows and tabs across different operating systems. The <code>window_management.talon</code> file is the primary entry point, using actions defined in <code>window_snap.py</code>, the platform-specific <code>windows_and_tabs_*.py</code> files, and <code>tabs.py</code> to implement window and tab management features. The <code>windows_and_tabs.py</code> file provides some cross-platform window cycling actions to complement platform-specific actions.</p>"},{"location":"lang/","title":"lang","text":"<p>The <code>community/lang</code> directory contains a collection of subdirectories, each dedicated to providing support for a specific programming language or markup language within Talon. Each subdirectory typically includes a <code>.py</code> file for the core logic and a <code>.talon</code> file for defining voice commands.</p> <p>Here's a breakdown of the most important and interesting subdirectories:</p> <ul> <li><code>rust</code>: This directory provides support for the Rust programming language. The <code>rust.py</code> file defines the core logic, including lists of Rust keywords, types, and macros, as well as actions for inserting code structures, operators, and comments. The <code>rust.talon</code> file defines the voice commands that trigger these actions. Together, they allow users to write Rust code more easily with voice.</li> <li><code>lua</code>: This directory provides support for the Lua programming language. The <code>lua.talon</code> file defines the core Talon grammar for Lua, while the <code>lua.py</code> implements the actions, lists, and settings used by those commands. It also has a <code>stylua.talon</code> file to support the Stylua linter. These files enable voice control for writing Lua code with proper syntax and formatting.</li> <li><code>terraform</code>: This directory adds support for Terraform. The <code>terraform.talon</code> file contains the Talon commands for working with Terraform code, while <code>terraform.py</code> contains the Python implementation of the custom actions and lists used in the Talon file. This allows the user to insert Terraform blocks, properties, and operators using voice commands.</li> <li><code>r</code>: This directory provides support for the R programming language. The <code>r.py</code> file defines the core functionality for R support in Talon. The file includes lists of common R functions and libraries, and provides actions that are implemented by voice commands defined in <code>r.talon</code>. The files work together to provide voice control for R development.</li> <li><code>sql</code>: This directory contains files to add support for SQL in Talon. The <code>sql.talon</code> file defines voice commands for common SQL keywords and syntax, while <code>sql.py</code> defines the context for SQL, and adds actions for inserting operators, functions, and null values. This enables the user to write SQL using voice commands.</li> <li><code>python</code>: This directory provides comprehensive support for Python development. The <code>python.py</code> file defines lists of common Python functions, keywords, and exceptions, as well as actions for inserting code structures, operators, and comments. The <code>python.talon</code> file provides the voice commands and grammar for using these actions.</li> <li><code>scala</code>: This directory contains the Talon files for programming in Scala. The <code>scala.py</code> file defines the core functionality, including lists of Scala types and keywords, and actions for inserting code snippets. The <code>scala.talon</code> file configures the tags, settings, and phrases used when programming in Scala, and defines some simple voice commands.</li> <li><code>proto</code>: This directory adds support for Protocol Buffer language in Talon. The <code>proto.py</code> file defines a Talon context and the list of protobuf types. The <code>proto.talon</code> file defines the voice commands for interacting with protobuf code, including commands for specifying types.</li> <li><code>php</code>: This directory provides support for the PHP programming language. The <code>php.py</code> file defines actions for common PHP constructs like keywords, comments, operators, functions, and variables. The <code>php.talon</code> file defines the Talon grammar and settings for PHP, including tags and formatting options.</li> <li><code>stata</code>: This directory contains the files that add Stata language support to Talon. The <code>stata.py</code> file defines the core logic for Stata code, while the <code>stata.talon</code> file defines the voice commands that are used to insert Stata code.</li> <li><code>csharp</code>: This directory provides support for the C# programming language. The <code>csharp.py</code> file defines actions for common C# coding tasks, such as inserting operators, keywords, control flow statements, and functions. The <code>csharp.talon</code> file defines tags, settings, and some basic voice commands that activate functionality in the python file.</li> <li><code>css</code>: This directory contains the files to add CSS and SCSS support to Talon. The <code>css.py</code> file defines lists of CSS units, at-rules, and global values, as well as some basic actions. The <code>css.talon</code> file defines voice commands for inserting CSS properties, values, rules, and other syntax.</li> <li><code>tags</code>: This directory contains files that define tags, actions, and rules for various programming language constructs. The files in this directory are organized by concept, with each concept having a corresponding <code>.py</code> file that defines the actions and a corresponding <code>.talon</code> file that defines the voice commands. For example, the <code>operators_math.py</code> and <code>operators_math.talon</code> files enable the insertion of math operators using voice.</li> <li><code>html</code>: This directory provides support for HTML, JavaScript React, and TypeScript React. The <code>html.talon</code> file defines these three languages, indicating to Talon that files using these languages should be interpreted using the appropriate grammar.</li> <li><code>java</code>: This directory adds support for the Java programming language to Talon. The <code>java.py</code> file defines the context, lists of types and modifiers, and actions for inserting code snippets and operators. The <code>java.talon</code> file defines the voice commands for interacting with the code, and imports many tags from other locations.</li> <li><code>c</code>: This directory contains files that provide support for the C programming language. The <code>c.talon</code> file defines the core grammar for C, while the <code>c.py</code> file contains the Python code that supports the grammar, including lists of C elements, captures, and actions.</li> <li><code>batch</code>: This directory adds support for the Batch scripting language. The <code>batch.py</code> file defines the context, and the <code>batch.talon</code> file defines a set of voice commands for working with Batch files, including keywords, and a way to insert arguments.</li> <li><code>ruby</code>: This directory contains files that add support for the Ruby programming language. The <code>ruby.talon</code> file defines the language tag and basic tags, and the <code>ruby.py</code> file implements actions specific to Ruby code.</li> <li><code>elixir</code>: This directory provides support for the Elixir programming language. The <code>elixir.py</code> file defines the core functionality and actions, while the <code>elixir.talon</code> file defines the voice commands and language features specific to Elixir.</li> <li><code>kotlin</code>: This directory adds support for the Kotlin programming language. The <code>kotlin.talon</code> file defines the language tag and formatting rules, and <code>kotlin.py</code> defines the core functionality of the module with many methods to insert specific code elements and operators.</li> <li><code>typescript</code>: This directory contains files that add support for the TypeScript language. The <code>typescript.talon</code> file defines the voice commands for inserting type annotations and other constructs, and the <code>typescript.py</code> file defines the context, list of types, and actions.</li> <li><code>talon</code>: This directory provides extensions for editing and creating Talon code. It defines actions, lists, tags, and commands that aid in writing both <code>.talon</code> and <code>.talon-list</code> files. The <code>talon.py</code> file is the core, defining the logic and actions, while other files like <code>talon_common.talon</code> and <code>talon_context.talon</code> define voice commands for inserting specific Talon constructs.</li> <li><code>javascript</code>: This directory provides support for Javascript and Typescript development. The <code>javascript.py</code> file defines the core logic and actions for Javascript and Typescript, and the <code>javascript.talon</code> file provides the voice commands.</li> <li><code>vimscript</code>: This directory contains files that add support for the Vimscript language. The <code>vimscript.py</code> file defines the context, lists of functions and scopes, and actions for common tasks, while the <code>vimscript.talon</code> file defines the voice commands.</li> <li><code>markdown</code>: This directory provides support for the Markdown language in Talon. The <code>markdown.talon</code> file defines a set of voice commands for common markdown syntax, while <code>markdown.py</code> defines the context and list of supported languages for code blocks.</li> </ul> <p>These subdirectories showcase a wide range of language support, and a consistent pattern of using a Python file for the logic and a Talon file for voice commands. The <code>tags</code> directory provides a reusable set of rules that can be included in other language modules, making it easier to extend the functionality of Talon with voice commands for different languages.</p>"},{"location":"lang/batch/","title":"batch","text":"<p>The <code>community/lang/batch</code> directory contains files to support the Batch scripting language in Talon.</p> <p>The <code>batch.py</code> file (https://github.com/talonhub/community/blob/main/lang/batch/batch.py) defines a Talon context for the Batch language. It specifies that when the code language is set to \"batch\", the <code>code_comment_line_prefix</code> action should insert \"REM \".</p> <p>The <code>batch.talon</code> file (https://github.com/talonhub/community/blob/main/lang/batch/batch.talon) defines a set of voice commands for working with Batch files. It defines a <code>user.code_comment_line</code> tag, a number of commonly used keywords and commands with shortcuts such as <code>soft exit</code>, <code>hard exit</code>, <code>echo</code>, <code>call</code>, <code>if error</code> and <code>go to</code>, and a way to insert an argument via <code>&lt;number_small&gt;</code>.</p>"},{"location":"lang/c/","title":"c","text":"<p>The <code>community/lang/c</code> directory contains files that provide support for the C programming language in Talon.</p> <p>The <code>c.talon</code> file defines the core grammar for C. It includes: *   Tags for identifying C code, such as <code>user.code_imperative</code>, <code>user.code_block_c_like</code>, <code>user.code_comment_line</code>, etc. *   Settings for formatting C code, such as <code>user.code_private_function_formatter</code>, <code>user.code_public_variable_formatter</code>, etc. *   State commands for common C preprocessor directives such as <code>#include</code>, <code>typedef</code>, <code>#define</code>, <code>#ifdef</code>, <code>#if</code>, <code>#error</code>, <code>#pragma</code>, etc. *   A push command to insert braces. *   Commands for declaring variables with types and names, such as <code>&lt;user.c_variable&gt; &lt;phrase&gt;</code>. *   Commands for casting, types, keywords, and standard integer types like <code>cast to &lt;user.c_cast&gt;</code>, <code>standard cast to &lt;user.stdint_cast&gt;</code>, <code>&lt;user.c_types&gt;</code>, <code>&lt;user.c_pointers&gt;</code>, <code>&lt;user.c_keywords&gt;</code>, <code>&lt;user.c_signed&gt;</code>, <code>standard &lt;user.stdint_types&gt;</code>. *   A command <code>int main</code> to insert <code>int main()</code>. *   A command <code>include &lt;user.code_libraries&gt;</code> to insert a library include with the chosen library.</p> <p>The <code>c.py</code> file contains the Python code that supports the grammar defined in <code>c.talon</code>. It: *   Defines a Talon Context that matches when <code>code.language</code> is <code>c</code>. *   Defines lists for common C elements, such as:     *   <code>self.c_pointers</code>: <code>*</code>, <code>**</code>     *   <code>self.stdint_signed</code>: <code>signed</code>, <code>unsigned</code>     *  <code>self.c_signed</code>: <code>signed</code>, <code>unsigned</code>     *  <code>self.c_keywords</code>: <code>static</code>, <code>volatile</code>, <code>register</code>     *  <code>self.stdint_types</code>: <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>, <code>void</code>, <code>double</code>, etc.     *   <code>self.c_types</code>: <code>char</code>, <code>short</code>, <code>long</code>, <code>int</code>, <code>void</code>, <code>double</code>, etc.     *   <code>user.code_libraries</code>: <code>assert.h</code>, <code>ctype.h</code>, <code>errno.h</code>, <code>math.h</code>, <code>stdio.h</code>, <code>stdlib.h</code>, <code>string.h</code>, etc.     *   <code>user.code_common_function</code>: <code>memcpy</code>, <code>memset</code>, <code>strcat</code>, <code>strcmp</code>, <code>strlen</code>, <code>printf</code>, <code>malloc</code>, <code>free</code>, etc. *   Defines captures for those lists, such as <code>c_pointers</code>, <code>c_signed</code>, <code>c_keywords</code>, <code>c_types</code>, and <code>stdint_types</code>. *   Defines captures for C casts, such as <code>c_cast</code> and <code>stdint_cast</code>. *   Defines a capture for variables using the previously defined captures, <code>c_variable</code>. *   Implements actions for inserting common C operators such as <code>code_operator_indirection</code>, <code>code_operator_address_of</code>, <code>code_operator_structure_dereference</code>, <code>code_operator_subscript</code>, <code>code_operator_assignment</code>, and many more. *   Implements actions for inserting control flow statements such as <code>code_state_if</code>, <code>code_state_else</code>, <code>code_state_switch</code>, <code>code_state_for</code>, <code>code_state_while</code>, <code>code_state_return</code>, etc. *   Implements actions for inserting code snippets, including: <code>code_insert_null</code>, <code>code_insert_is_null</code>, <code>code_insert_is_not_null</code>, <code>code_comment_line_prefix</code>, <code>code_insert_function</code>, <code>code_private_function</code>, <code>code_private_static_function</code>, and <code>code_insert_library</code>.</p> <p>Together, <code>c.talon</code> and <code>c.py</code> provide a comprehensive set of tools for writing C code with Talon. <code>c.talon</code> defines the grammar and <code>c.py</code> implements the logic and provides the necessary data.</p>"},{"location":"lang/csharp/","title":"csharp","text":"<p>The <code>community/lang/csharp</code> directory contains files that provide support for the C# programming language in Talon.</p> <p>The file <code>csharp.py</code> defines a Talon context that activates when the current code language is C#. It defines several actions using the <code>@ctx.action_class(\"user\")</code> decorator that are used for common coding tasks:</p> <ul> <li>Inserting operators such as <code>*</code>, <code>&amp;</code>, <code>-&gt;</code>, <code>=&gt;</code>, <code>[]</code>, <code>=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>.</li> <li>Inserting keywords such as <code>this</code>, <code>null</code>, <code>true</code>, and <code>false</code>.</li> <li>Inserting common control flow statements such as <code>if</code>, <code>else if</code>, <code>else</code>, <code>switch</code>, <code>case</code>, <code>for</code>, <code>foreach</code>, <code>go to</code>, <code>while</code>, <code>return</code>, <code>break</code>, and <code>continue</code>.</li> <li>Defining and inserting functions with different visibility modifiers (private, protected, public) and static specifiers.</li> <li>Inserting comments.</li> <li>Inserting common C# functions like <code>int.TryParse</code> and <code>Console.WriteLine</code>.</li> </ul> <p>The file <code>csharp.talon</code> defines the following:</p> <ul> <li>Tags to mark this as an imperative and object-oriented language, as well as tags for C-like blocks, line and block comments, boolean data, null data, functions, common functions, libraries, array operators, assignment operators, bitwise operators, lambda operators, math operators, and pointer operators.</li> <li>Settings that define the format used when inserting private, protected, and public functions and variables.</li> </ul>"},{"location":"lang/css/","title":"css","text":"<p>The <code>community/lang/css</code> directory provides support for CSS and SCSS within Talon. It includes a Python file (<code>css.py</code>) that defines lists of common CSS keywords, and a Talon file (<code>css.talon</code>) that defines grammar for working with CSS.</p> <p><code>css.py</code> defines three lists of CSS-related values:</p> <ul> <li><code>css_unit</code>: A list of CSS units, like <code>em</code>, <code>px</code>, <code>deg</code>, and <code>s</code>.</li> <li><code>css_at_rule</code>: A list of CSS at-rules, such as <code>@media</code>, <code>@import</code>, and <code>@keyframes</code>.</li> <li><code>css_global_value</code>: A list of global CSS values, including <code>initial</code>, <code>inherit</code>, and <code>unset</code>.</li> </ul> <p>These lists are used in the <code>css.talon</code> file to provide easy access to these values. The file also defines a list of common functions (e.g. <code>rgb</code>, <code>calc</code>, <code>linear-gradient</code>) using the <code>user.code_common_function</code> list from the user namespace. These functions are accessible through the <code>code_insert_function</code> action defined in <code>css.py</code>. <code>css.py</code> also defines actions to insert common operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>and</code>, <code>or</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&lt;=</code>.</p> <p><code>css.talon</code> defines several rules for inserting CSS syntax:</p> <ul> <li><code>attribute [&lt;user.text&gt;]</code>: Inserts an attribute with the provided text formatted as dash-separated, enclosed in square brackets (e.g. <code>[my-attribute]</code>).</li> <li><code>prop &lt;user.text&gt;</code>: Inserts a CSS property with the provided text formatted as dash-separated, followed by a colon and a semicolon (e.g., <code>my-property: ;</code>).</li> <li><code>rule &lt;user.text&gt;</code>: Inserts a CSS rule with the provided text formatted as dash-separated, followed by a colon and a space (e.g. <code>my-rule:</code>).</li> <li><code>value &lt;user.number_string&gt; [{user.css_unit}]</code> and <code>value &lt;user.number_string&gt; point &lt;digit_string&gt; [{user.css_unit}]</code>: Inserts a numerical CSS value with an optional unit (e.g., <code>10px</code>, <code>1.5em</code>).</li> <li><code>(value | state) {user.css_global_value}</code>: Inserts a global CSS value (e.g. <code>initial</code>, <code>unset</code>).</li> <li><code>value &lt;user.text&gt;</code>: Inserts a dash separated value.</li> <li><code>variable &lt;user.text&gt;</code>: Inserts a CSS variable reference (e.g., <code>var(--my-variable)</code>).</li> <li><code>op var</code>: Inserts <code>var(--)</code> with the cursor in the parentheses.</li> <li><code>at {user.css_at_rule}</code>: Inserts a CSS at-rule (e.g., <code>@media</code>).</li> <li><code>unit {user.css_unit}</code>: Inserts a CSS unit (e.g. <code>em</code>, <code>px</code>).</li> <li><code>[value] current color</code>: Inserts <code>currentColor</code>.</li> <li><code>op important</code>: Inserts <code>!important</code>.</li> </ul> <p>The file also sets the <code>user.code_public_variable_formatter</code> to <code>DASH_SEPARATED</code> which is used for formatting the text in the <code>attribute</code>, <code>prop</code>, and <code>variable</code> rules.</p> <p>The <code>css.talon</code> file also includes tags: * <code>user.code_block_c_like</code> * <code>user.code_comment_block_c_like</code> * <code>user.code_functions_common</code> * <code>user.code_libraries</code> * <code>user.code_operators_math</code></p> <p>These tags allow the user to leverage existing functionality in other parts of the Talon configuration that use these tags. For instance <code>user.code_block_c_like</code> enables commands that insert code blocks using curly braces (<code>{}</code>), while <code>user.code_operators_math</code> enables math operator commands.</p> <p>In summary, <code>css.py</code> provides the basic lists of CSS keywords and operators, and <code>css.talon</code> provides the grammar for inserting those keywords, along with CSS properties, values, and other syntax, making it easier to write CSS with voice.</p>"},{"location":"lang/elixir/","title":"elixir","text":"<p>The <code>community/lang/elixir</code> directory contains files that provide support for the Elixir programming language in Talon.</p> <p>The core functionality is implemented in <code>elixir.py</code>. This file defines a Talon context that is active when the current code language is Elixir. It provides lists of keywords and implements custom actions for:</p> <ul> <li>Inserting code comments, operators, and common values (true, false, null).</li> <li>Inserting control flow statements like <code>if</code>, <code>else</code>, <code>case</code>, <code>for</code>, and <code>while</code> with proper formatting.</li> <li>Inserting function declarations (both public and private) using formatters.</li> <li>Importing, aliasing, requiring, and using modules.</li> </ul> <p>The <code>elixir.talon</code> file, found at <code>elixir.talon</code>, defines:</p> <ul> <li>Tags that activate various Talon features specific to functional and concurrent programming, commenting, working with booleans and null, using functions, keywords, libraries, array operators, assignment operators, math operators, and lambda operators.</li> <li>Settings for formatting private and public functions and variables using snake case.</li> <li>Basic grammars for keywords and states like <code>def</code>, <code>defp</code>, <code>if</code>, <code>else</code>, <code>case</code>, <code>cond</code>, <code>try</code>, <code>rescue</code>, <code>after</code>, and <code>end</code></li> <li>A grammar for inserting the pipe operator <code>|&gt;</code></li> <li>A grammar for inserting raise and rescue statements with custom <code>user.elixir_exception</code> grammar.</li> </ul> <p>These files work together to provide a cohesive experience when writing Elixir code using Talon. The <code>.py</code> file handles the insertion and formatting of code, while the <code>.talon</code> file sets up the context and enables common language features.</p>"},{"location":"lang/html/","title":"html","text":"<p>The <code>community/lang/html</code> directory contains language support for HTML, JavaScript React, and TypeScript React.</p> <p>The html.talon file defines these three languages, indicating to Talon that files using these languages should be interpreted using the appropriate grammar.</p>"},{"location":"lang/java/","title":"java","text":"<p>The <code>community/lang/java</code> directory contains files that add support for the Java programming language to Talon.</p> <p>The core functionality is implemented in <code>java.py</code>. This file defines a Talon context that activates when the current code language is Java. It defines lists of:</p> <ul> <li><code>java_primitive_types</code>: Primitive types like <code>int</code>, <code>boolean</code>, etc.</li> <li><code>java_boxed_types</code>: Boxed versions of primitive types like <code>Integer</code>, <code>Boolean</code>, etc.</li> <li><code>java_common_classes</code>: Common classes like <code>Object</code>, <code>String</code>, etc.</li> <li><code>java_generic_data_structures</code>: Generic data structures like <code>List</code>, <code>Map</code>, etc.</li> <li><code>java_modifiers</code>: Modifiers like <code>public</code>, <code>private</code>, <code>static</code>, etc.</li> </ul> <p>These lists are used in <code>java.talon</code> to create voice commands. The <code>java.py</code> file also defines a number of <code>UserActions</code> that are used to insert code snippets and operators using voice commands. These actions cover common operations such as:</p> <ul> <li>Operators like <code>+</code>, <code>-</code>, <code>==</code>, etc.</li> <li>Control flow structures like <code>if</code>, <code>else</code>, <code>for</code>, etc.</li> <li>Inserting <code>null</code>, <code>true</code>, <code>false</code>, and comments.</li> <li>Defining functions with various modifiers.</li> </ul> <p>The file <code>java.talon</code> defines the voice commands that are used to interact with the code. It imports several code tags that provide additional functionality (e.g. <code>user.code_imperative</code>, <code>user.code_operators_math</code>). It also sets several settings that control the formatting of function and variable names.</p> <p>The Talon file defines a number of commands for inserting code. For example:</p> <ul> <li><code>boxed [type] {user.java_boxed_type}</code>: Inserts a boxed type.</li> <li><code>generic [type] {user.java_generic_data_structure}</code>: Inserts a generic type with angle brackets.</li> <li><code>type {user.code_type} array</code>: Inserts a type followed by array brackets.</li> <li><code>[state] {user.java_modifier}</code>: Inserts a Java modifier.</li> <li><code>op array</code>: Inserts array brackets.</li> <li><code>op new</code>: Inserts <code>new</code> keyword.</li> </ul> <p>These files work together to provide a comprehensive set of voice commands for coding in Java. The <code>java.py</code> file defines the core logic and data structures, while the <code>java.talon</code> file provides the voice commands that users can use to interact with the code.</p>"},{"location":"lang/javascript/","title":"javascript","text":"<p>The <code>community/lang/javascript</code> directory provides Talon support for Javascript and Typescript development.</p> <p>The file <code>javascript.py</code> defines the core logic for the Javascript/Typescript language support. It sets up a Talon context that activates when the code language is set to Javascript, Typescript, JavascriptReact, or TypescriptReact. This file defines lists for common functions, member functions, and keywords, enabling users to easily insert them with voice commands. It also defines a wide variety of actions for common coding tasks, including inserting code constructs like <code>if</code>, <code>else</code>, <code>for</code>, and <code>while</code> statements, as well as inserting operators, comments, and functions. It includes actions for inserting null checks (<code>is null</code>, <code>is not null</code>), and provides configurable function formatting.</p> <p>The file <code>javascript.talon</code> provides the voice commands that tie into the python logic in <code>javascript.py</code>. It sets up tags to enable common code features like imperative and object oriented programming, C-like syntax, line and block comments, boolean and null values, functions, keywords, libraries, and common operators. The file also defines settings for formatting different types of variables and functions. There are voice commands for inserting code snippets like strict equality checks, null coalescing, variable declarations, and exports, plus <code>async</code> and <code>await</code> keywords. It includes voice commands for common member functions called in a dot chain, such as \"dot map\" or \"dot filter\".  The file also defines a command for a <code>from</code> import, inserting <code>from \"\"</code> with the cursor between the quotes.</p>"},{"location":"lang/kotlin/","title":"kotlin","text":"<p>The <code>community/lang/kotlin</code> directory contains files that provide support for the Kotlin programming language within the Talon voice control system.</p> <p>The <code>kotlin.talon</code> file (<code>kotlin.talon</code>) declares the language as Kotlin and assigns various tags related to code structure, comments, data types, functions, libraries, and operators. These tags enable language-specific features in Talon. It also sets formatting rules for different function and variable access modifiers (private, protected, and public) by setting corresponding settings to use the \"PRIVATE_CAMEL_CASE\" formatter.</p> <p>The <code>kotlin.py</code> file (<code>kotlin.py</code>) defines the core functionality for Kotlin within Talon. It establishes a context that activates when the code language is Kotlin. It defines a list of <code>user.code_keyword</code> that are common Kotlin keywords. It then defines a class <code>UserActions</code> with many methods. Most of these methods define actions for inserting specific code elements, such as operators, keywords, comments, and code structures. Here is a summary of the most interesting methods:</p> <ul> <li><code>code_comment_line_prefix()</code>: Inserts a line comment prefix (<code>//</code>).</li> <li><code>code_operator_lambda()</code>: Inserts the lambda operator (<code>-&gt;</code>).</li> <li><code>code_operator_subscript()</code>: Inserts square brackets <code>[]</code> for array access, placing the cursor in between them.</li> <li><code>code_operator_*()</code>: There are many methods for inserting various operators such as assignment (<code>=</code>), math (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>), comparison (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>), logical (<code>&amp;&amp;</code>, <code>||</code>), and bitwise (<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) operators. Each also has a corresponding assignment operator.</li> <li><code>code_self()</code>: Inserts the <code>this</code> keyword.</li> <li><code>code_insert_null()</code>, <code>code_insert_is_null()</code>, and <code>code_insert_is_not_null()</code>: Inserts <code>null</code>, <code>== null</code>, and <code>!= null</code> respectively.</li> <li><code>code_state_*()</code>: These methods insert code blocks for control flow statements, such as <code>if</code>, <code>else if</code>, <code>else</code>, <code>when</code>, <code>for</code>, and <code>while</code>, placing the cursor in the correct position. The <code>when</code> state is used because Kotlin uses <code>when</code> instead of <code>switch</code>.</li> <li><code>code_define_class()</code>: Inserts the <code>class</code> keyword.</li> <li><code>code_state_return()</code>: Inserts the <code>return</code> keyword.</li> <li><code>code_insert_function(text, selection)</code>: This inserts a function call with the specified text and selection.</li> <li><code>code_default_function(text)</code>, <code>code_public_function(text)</code>, <code>code_private_function(text)</code>: These methods insert function definitions with the specified text, applying formatting based on visibility (private, protected, or public) and inserting the cursor in the correct location. They use the formatters defined in <code>kotlin.talon</code>.</li> </ul>"},{"location":"lang/lua/","title":"lua","text":"<p>The <code>community/lang/lua</code> directory contains files that provide support for the Lua programming language in Talon. It defines a grammar, common functions, and operators.</p> <p>The file <code>lua.talon</code> defines the core Talon grammar for Lua. It includes:</p> <ul> <li>Tags: Assigns tags such as <code>user.code_imperative</code>, <code>user.code_comment_line</code>, <code>user.code_comment_block</code>, etc., which are used in the <code>lua.py</code> file to trigger actions.</li> <li>Settings: Configures formatting settings such as <code>user.code_private_function_formatter</code> to <code>SNAKE_CASE</code>.</li> <li>States: Defines keywords and common code snippets like <code>local</code>, <code>end</code>, <code>return nil</code>, etc., that can be inserted by voice. It also defines how to insert formatted text, including labels.</li> <li>Commands: Provides voice commands for common tasks such as requiring libraries, declaring variables, calling methods, and accessing array indices.</li> </ul> <p>The file <code>stylua.talon</code> provides commands related to the Stylua linter, such as inserting comments to ignore linting for a line, block, or section.</p> <p>The file <code>lua.py</code> implements the actions defined in <code>lua.talon</code>. It also defines a few settings, captures, lists, and actions:</p> <ul> <li>Settings: Defines <code>lua_version</code>, which dictates the usage of bitwise operators based on the Lua version.</li> <li>Tags: Defines the <code>stylua</code> tag, which is used to enable linting commands.</li> <li>Lists: Defines lists of common Lua functions and libraries, such as <code>string.sub</code>, <code>io.write</code>, <code>table</code>, <code>math</code>, etc. These lists are available for use in the <code>lua.talon</code> file to provide voice commands for inserting common functions.</li> <li>Capture: The <code>lua_functions</code> capture is used to identify and return a Lua function that has been dictated.</li> <li>Actions: Implements actions for inserting various code constructs, such as if/else blocks, for/while loops, comments, boolean/null values, private/public functions, libraries, array subscripts, operators, and more. These actions use the <code>user.formatted_text</code> and <code>actions.insert</code> functions to insert code in the correct format and position. Some actions change based on the <code>user.lua_version</code> setting.</li> </ul> <p>These files work together to provide a comprehensive Lua support for Talon. The <code>lua.talon</code> file defines the voice grammar, which uses tags, states, and commands to define the structure of the Lua code. The <code>lua.py</code> file implements the actual actions, lists, and settings used by the voice commands. Together, these files allow users to write Lua code using voice commands in Talon, using the appropriate syntax and formatting.</p>"},{"location":"lang/markdown/","title":"markdown","text":"<p>The <code>community/lang/markdown</code> directory provides support for the Markdown language in Talon. It contains two files that work together: <code>markdown.talon</code> and <code>markdown.py</code>.</p> <p><code>markdown.talon</code> defines a set of voice commands for common Markdown syntax. This includes commands for inserting headings of various levels (<code>level one</code>, <code>heading two</code>, etc.), creating lists (<code>list one</code>, <code>list two</code>, etc), inserting code blocks with a language (<code>typescript block</code>, <code>python block</code>, etc.), and creating links (<code>link</code>). These commands use Talon's <code>edit</code> commands to insert the appropriate Markdown syntax at the current cursor position.</p> <p><code>markdown.py</code> defines the context in which the <code>markdown.talon</code> commands are active, which is when the code language is set to markdown. It also defines the <code>markdown_code_block_language</code> list that is used by the <code>markdown.talon</code> file to provide options for specifying the language of a code block, such as typescript, python, or json. This list is accessible by the user as <code>user.markdown_code_block_language</code> in the <code>.talon</code> file.</p>"},{"location":"lang/php/","title":"php","text":"<p>The <code>community/lang/php</code> directory contains files to support the PHP programming language in Talon.</p> <p>The file <code>php.py</code> defines a Talon context for PHP. This file contains a variety of actions to make coding in PHP easier with voice commands. These include:</p> <ul> <li>Inserting keywords and common code constructs, such as <code>class</code>, <code>use</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>foreach</code>, <code>switch</code>, <code>case</code>, <code>do</code>, <code>goto</code>, and <code>return</code>.</li> <li>Inserting comments, including line comments, block comments, and documentation comments.</li> <li>Inserting common operators, such as <code>-&gt;</code>, <code>=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>===</code>, <code>!==</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&amp;&amp;</code>, and <code>||</code>.</li> <li>Inserting boolean (<code>true</code>, <code>false</code>) and null (<code>null</code>) values.</li> <li>Inserting functions to check null (<code>is_null()</code>, <code>isset()</code>)</li> <li>Defining public, private, and protected functions.</li> <li>Defining public, private, and protected static functions.</li> <li>Inserting return types into function declarations.</li> </ul> <p>The file <code>php.talon</code> defines the Talon grammar and settings for PHP. This file includes:</p> <ul> <li>Tagging the context with several useful tags: <code>user.code_imperative</code>, <code>user.code_object_oriented</code>, <code>user.code_libraries</code>, <code>user.code_block_c_like</code>, <code>user.code_comment_line</code>, <code>user.code_comment_block</code>, <code>user.code_comment_documentation</code>, <code>user.code_data_bool</code>, <code>user.code_data_null</code>, <code>user.code_operators_assignment</code>, <code>user.code_operators_math</code>, and <code>user.code_functions</code>.</li> <li>Setting formatters for private, protected, and public functions and variables to <code>PRIVATE_CAMEL_CASE</code>.</li> <li>Defining phrases to insert loose equality and loose inequality operators (<code>==</code> and <code>!=</code>).</li> <li>Defining phrases to insert try and catch blocks.</li> <li>Defining a phrase to insert a variable with a leading <code>$</code>.</li> </ul>"},{"location":"lang/proto/","title":"proto","text":"<p>The <code>community/lang/proto</code> directory contains files that provide support for the Protocol Buffer language in Talon.</p> <p>The file <code>proto.py</code> defines a Talon context that activates when the current code language is set to \"protobuf\". It defines the <code>user.code_type</code> list, which provides voice commands for the various types available in Protocol Buffers, such as <code>string</code>, <code>bytes</code>, <code>int32</code>, <code>bool</code>, <code>double</code>, etc.</p> <p>The file <code>proto.talon</code> defines the voice commands for interacting with protobuf code. It activates when the code language is set to \"protobuf\" and applies the <code>user.code_block_c_like</code> tag. It defines voice commands for common keywords like <code>message</code>, <code>package</code>, <code>reserved</code>, and <code>import</code>, and provides commands for specifying types using the <code>user.code_type</code> list defined in <code>proto.py</code>. For example, saying \"type string\" will insert the text <code>string</code>, and saying \"repeated type int32\" will insert the text <code>repeated int32</code>.</p>"},{"location":"lang/python/","title":"python","text":"<p>The <code>community/lang/python</code> directory contains files that provide support for Python development in Talon. It primarily defines code actions, lists, and grammar to make writing Python code easier and faster using voice commands.</p> <p>The most important files in this directory are:</p> <ul> <li> <p><code>python.py</code>: This file defines the core logic for Python support. It includes:</p> <ul> <li>A context that activates when the code language is set to Python.</li> <li>Several lists (<code>ctx.lists</code>) that provide vocabulary for common Python constructs. These include:<ul> <li><code>user.code_common_function</code>:  Common Python functions like <code>print</code>, <code>len</code>, and <code>range</code>.</li> <li><code>user.python_docstring_fields</code>: Fields used in Python docstrings like <code>:param:</code>, <code>:return:</code>, and <code>:type:</code>.</li> <li><code>user.code_type</code>: Python data types such as <code>int</code>, <code>str</code>, <code>list</code>, and <code>dict</code>.</li> <li><code>user.code_keyword</code>: Python keywords like <code>class</code>, <code>return</code>, <code>import</code>, <code>True</code>, and <code>False</code>.</li> <li><code>user.python_exception</code>: A comprehensive list of Python exceptions.</li> </ul> </li> <li>An action class (<code>UserActions</code>) that implements the following:<ul> <li>Actions to insert code operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>==</code>, <code>!=</code>).</li> <li>Actions to insert code structures such as <code>if</code>, <code>elif</code>, <code>else</code>, <code>for</code>, <code>while</code>, and <code>match</code>/<code>case</code>.</li> <li>Actions to insert common keywords like <code>class</code>, <code>return</code>, <code>import</code>, <code>None</code>, <code>True</code>, and <code>False</code>.</li> <li>Actions to insert function definitions (both public and private).</li> <li>Actions to insert type hints for variables and return types.</li> <li>Actions to insert <code>break</code> and <code>continue</code> statements.</li> <li>Actions to insert comments and docstrings.</li> </ul> </li> </ul> </li> <li> <p><code>python.talon</code>: This file defines the Talon grammar for Python. It includes:</p> <ul> <li>Tags for Python (e.g., <code>user.code_imperative</code>, <code>user.code_object_oriented</code>, <code>user.code_comment_documentation</code>).</li> <li>Settings to control how function names and variable names are formatted.</li> <li>Grammar rules that map voice commands to actions defined in <code>python.py</code>. For example:<ul> <li><code>state def</code> inserts <code>def</code>.</li> <li><code>state try</code> inserts <code>try:\\n</code>.</li> <li><code>state raise {user.python_exception}</code> inserts a <code>raise</code> statement with the selected exception.</li> <li><code>dock string</code> calls the <code>user.code_comment_documentation()</code> action to insert a docstring.</li> <li><code>dock {user.python_docstring_fields}</code> inserts a docstring field.</li> <li><code>dock type {user.code_type}</code> inserts a type hint in a docstring.</li> <li><code>dock returns type {user.code_type}</code> inserts a return type hint in a docstring.</li> <li><code>import &lt;user.code_libraries&gt;</code> inserts an import statement for a library and moves the cursor to the end of the line.</li> </ul> </li> </ul> </li> </ul> <p>Together, these files provide a comprehensive set of tools for coding in Python with Talon. The <code>python.py</code> file defines the logic and available actions, while <code>python.talon</code> maps voice commands to those actions and sets up the grammar. The lists in <code>python.py</code> provide the necessary vocabulary for these commands to function.</p>"},{"location":"lang/r/","title":"r","text":"<p>The <code>community/lang/r</code> directory contains the Talon files for enabling R language support.</p> <p>The file <code>r.py</code> defines the core functionality for R support in Talon. It sets the context for R code (<code>code.language: r</code>) and defines several lists:</p> <ul> <li><code>user.code_common_function</code>: This list contains a large number of common R functions, grouped by package (base R, dplyr, ggplot2, purrr, stringr, tidyr, readr/readxl, Shiny) for easy access. These are used to insert code snippets using voice commands.</li> <li><code>user.code_libraries</code>: This list contains a list of R libraries and their associated names.</li> <li><code>user.code_parameter_name</code>: This list contains common parameter names in R.</li> <li>An <code>UserActions</code> class provides methods that implement common code insertion and manipulation actions, such as inserting operators, control flow statements, and comments, or defining functions.</li> </ul> <p>The <code>r.talon</code> file contains Talon voice commands and settings specific to R:</p> <ul> <li>It sets tags for R code, including <code>user.code_imperative</code>, <code>user.code_block_c_like</code>, <code>user.code_comment_line</code>, <code>user.code_data_bool</code>, <code>user.code_data_null</code>, <code>user.code_functions</code>, <code>user.code_functions_common</code>, <code>user.code_libraries</code>, <code>user.code_operators_assignment</code>, <code>user.code_operators_bitwise</code>, and <code>user.code_operators_math</code>. These tags activate certain functionalities or voice commands from other files, such as how to handle comments or which mathematical operators are available.</li> <li>It sets formatting rules for functions and variables using settings like <code>user.code_private_function_formatter = \"SNAKE_CASE\"</code>.</li> <li>It defines voice commands, including <code>(op | is) in</code>, which inserts the R membership operator <code>%in%</code>.</li> <li>It defines a voice command for toggling libraries using <code>toggle library: user.code_toggle_libraries()</code>.</li> <li>The voice command <code>library &lt;user.code_libraries&gt;</code> inserts a library name into a <code>library()</code> call.</li> <li>The command <code>(chain | pipe that)</code> inserts the pipe operator <code>%&gt;%</code> to chain operations.</li> <li>The command <code>state na</code> inserts the <code>NA</code> value</li> <li>The command <code>^function define &lt;user.text&gt;$</code> defines a private function.</li> <li>The command <code>named arg {user.code_parameter_name}</code> inserts a named argument into a function call.</li> </ul> <p>These two files work together to provide a robust R development experience with Talon.  The Python file provides the underlying logic and list of available functions and libraries, while the Talon file provides the voice commands.</p>"},{"location":"lang/ruby/","title":"ruby","text":"<p>The <code>community/lang/ruby</code> directory contains files that provide support for the Ruby programming language in Talon.</p> <p>The file <code>ruby.talon</code> is a Talon file that defines the language tag for Ruby (<code>code.language: ruby</code>) and declares a number of tags used for code navigation and formatting, such as <code>user.code_imperative</code>, <code>user.code_object_oriented</code>, <code>user.code_comment_line</code>, and many more. It also sets some settings related to how functions and variables should be formatted using snake case. Finally, it provides some basic commands such as <code>args pipe</code> to insert <code>| |</code>, <code>dock string</code> to insert documentation comments (<code>##</code>), and <code>instance</code> to insert <code>@</code> followed by a formatted variable name.  It also defines some states, such as <code>state end</code> to insert <code>\"end\"</code>, <code>state begin</code> to insert <code>\"begin\"</code>, <code>state rescue</code> to insert <code>\"rescue \"</code>, and <code>state module</code> to insert <code>\"module \"</code>.</p> <p>The file <code>ruby.py</code> is a Python file that defines actions specific to Ruby code. It defines a context that matches when the <code>code.language</code> is set to <code>ruby</code>. Inside of that context, it defines an action class <code>UserActions</code> that defines actions to insert various Ruby-specific code constructs such as operators, keywords, and common syntax.</p> <p>These files work together to provide a comprehensive set of tools for writing Ruby code with Talon. The <code>.talon</code> file defines the language context and basic tags, while the <code>.py</code> file implements the actions that are triggered by voice commands.  The settings defined in <code>ruby.talon</code> are used by functions defined in <code>ruby.py</code>.</p>"},{"location":"lang/rust/","title":"rust","text":"<p>The <code>community/lang/rust</code> directory contains files that provide support for the Rust programming language in Talon.</p> <p>The <code>rust.py</code> file at https://github.com/talonhub/community/blob/main/lang/rust/rust.py defines the core functionality for Rust support. It includes:</p> <ul> <li>Context and lists: It sets up a Talon context that activates when the code language is set to Rust. It defines several lists that are used in the <code>rust.talon</code> file for grammar. These lists include:<ul> <li><code>code_type</code>: A list of Rust's scalar, compound, standard library, and standard sync types.</li> <li><code>code_type_modifier</code>: A list of modifiers for types such as <code>mut</code>, <code>&amp;</code>, and <code>&amp;mut</code>.</li> <li><code>code_macros</code>: A list of Rust macros, including function-like, array-like, and block-like macros.</li> <li><code>code_trait</code>: A list of Rust traits such as <code>Fn</code>, <code>From</code>, and <code>Iterator</code>.</li> <li><code>code_libraries</code>: A list of standard library modules that can be imported using the <code>use</code> keyword.</li> <li><code>code_common_function</code>: A list of common functions and macros.</li> </ul> </li> <li>Actions: It defines a set of actions for working with Rust code, including:<ul> <li>Actions for inserting code structures like <code>if</code>, <code>for</code>, <code>while</code>, <code>loop</code>, and <code>match</code> statements.</li> <li>Actions for inserting comments, including line, documentation, and block comments.</li> <li>Actions for inserting operators, including arithmetic, logical, assignment, and bitwise operators.</li> <li>Actions for inserting function declarations, including private, protected, and public functions.</li> <li>Actions for inserting macros, with different handling for function, array, and block macros.</li> <li>Actions for inserting specific keywords like <code>self</code>, <code>true</code>, <code>false</code>, and <code>None</code>.</li> <li>Actions for inserting implementations of a trait using <code>impl</code>.</li> </ul> </li> <li>Helper Functions:<ul> <li><code>code_insert_function_or_macro</code>:  A helper function to insert a function or macro, handling selections and delimiters.</li> <li><code>repeat_call</code>: A helper function to repeat a callable a number of times.</li> </ul> </li> </ul> <p>The <code>rust.talon</code> file at https://github.com/talonhub/community/blob/main/lang/rust/rust.talon defines the voice commands that trigger the actions defined in <code>rust.py</code>.  It includes:</p> <ul> <li>Tagging: It applies several tags to enable language specific functionality.</li> <li>Settings: It defines the default formatters for functions and variables.</li> <li>Grammar: It defines rules for many Rust keywords, including: <code>unsafe</code>, <code>struct</code>, <code>enum</code>, <code>async</code>, <code>pub</code>, <code>const</code>, <code>fn</code>, <code>impl</code>, <code>let</code>, <code>mod</code>, <code>trait</code>, <code>match</code>, <code>Some</code>, <code>static</code>, <code>use</code>, <code>ref</code>, <code>dyn</code>, and <code>self</code>.</li> <li>Complex Grammar: It defines more complex rules for inserting code, including:<ul> <li>Rules to insert <code>if let Some</code>, <code>if let Ok</code>, and <code>if let Err</code> statements.</li> <li>Rules to insert documentation and block documentation comments.</li> <li>Rules to insert and implement traits and dynamic traits.</li> <li>Rules for inserting types and type modifiers</li> <li>Rules for inserting macros.</li> </ul> </li> <li>Synonyms: Defines some synonyms for some actions or language constructs, like <code>is some</code> for <code>.is_some()</code>.</li> </ul> <p>These two files work together to provide a comprehensive set of tools for working with Rust code using voice commands. The <code>rust.py</code> file provides the underlying logic and actions, while the <code>rust.talon</code> file provides the voice commands that trigger those actions, allowing users to write Rust code more quickly and easily with voice.</p>"},{"location":"lang/scala/","title":"scala","text":"<p>The <code>community/lang/scala</code> directory contains the Talon files for programming in Scala.</p> <p>The file <code>scala.py</code> defines the core functionality for Scala programming within Talon. It sets up a context that is activated when the user is coding in Scala (<code>code.language: scala</code>). It defines lists for common Scala types, modifiers, and keywords, making them available for use in voice commands. This file also implements many actions used to insert code snippets, such as operators, control flow statements, and comments. Most of these actions simply insert the necessary characters or use existing Talon actions to move the cursor and achieve the desired result.</p> <p>The file <code>scala.talon</code> configures the tags, settings, and simple phrases used when programming in Scala. It enables several tags related to imperative programming, object-oriented programming, C-like syntax, and specific code features like comments, boolean data, null values, functions, libraries, and operators. This allows other Talon files to target specific tags (e.g. <code>user.code_functions</code>) and have consistent functionality across different languages. It also sets formatting conventions for function and variable names. Lastly, this file defines simple phrases to make coding quicker, such as \"op right arrow\" to insert <code>\" -&gt; \"</code> and \"state match\" to insert <code>match {</code> with the cursor in the proper place.</p>"},{"location":"lang/sql/","title":"sql","text":"<p>The <code>community/lang/sql</code> directory contains files to add support for SQL in Talon.</p> <p>The most important files are:</p> <ul> <li> <p><code>sql.talon</code>: This file defines the voice commands for SQL. It includes common keywords like <code>select</code>, <code>from</code>, <code>where</code>, <code>order by</code>, and <code>group by</code>, as well as commands for inserting different types of joins, and creating <code>with</code> clauses. It also includes commands for inserting the <code>.id</code> suffix, and for inserting dates. The <code>column</code> command inserts a comma and a new line, which is useful when building lists of columns.</p> <p>The <code>sql.talon</code> file also tags the context with <code>user.code_operators_math</code>, <code>user.code_comment_line</code>, <code>user.code_comment_block_c_like</code>, <code>user.code_data_null</code>, and <code>user.code_functions_common</code>, which allows it to inherit commands from other files and makes the <code>sql</code> context easily extended with additional functionality. *   <code>sql.py</code>: This file defines the context for SQL and adds actions for inserting common SQL operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>IN</code>, <code>NOT IN</code>, <code>AND</code>, <code>OR</code>, and <code>NULL</code>, as well as a function for inserting other functions and null checks.</p> <p>It also defines a list of common functions, which at the moment only includes <code>count</code>, <code>min</code>, and <code>max</code>, but can be expanded on for different SQL dialects. The python file makes it so the talon commands for common operators, comments, null values, and function insertion are usable, as these actions are defined in python.</p> </li> </ul> <p>These two files work together to provide a complete set of commands for writing SQL code. The <code>sql.talon</code> file provides the basic commands for SQL keywords, while <code>sql.py</code> defines the context and provides actions for inserting operators, null values and functions. This allows the user to use simple voice commands to write SQL code more easily.</p>"},{"location":"lang/stata/","title":"stata","text":"<p>The <code>community/lang/stata</code> directory contains files that add Stata language support to Talon.</p> <p>The file <code>stata.py</code> defines the core logic for Stata code manipulation. This file sets the context for Stata code using <code>ctx.matches = r\"\"\" code.language: stata \"\"\"</code> which activates the defined actions and lists when the code language is detected as Stata. It defines lists for code parameters, common functions, and libraries which are used in code insertion, and defines many actions, including:</p> <ul> <li><code>code_comment_line_prefix</code>: Inserts a comment prefix (<code>*</code>) at the beginning of the line.</li> <li><code>code_private_function</code> and <code>code_default_function</code>: Creates a Stata program block with the user's input as the program's name.</li> <li><code>code_insert_named_argument</code>: Inserts a named argument with a trailing space.</li> <li><code>code_insert_function</code>: Inserts a Stata function name with a selected argument.</li> <li>A variety of actions for inserting Stata control flow statements (if, else if, else, for, foreach, while), break and continue statements.</li> <li><code>code_import</code>: Inserts <code>ssc install</code> for installing Stata packages.</li> <li><code>code_insert_library</code>: Inserts <code>ssc install</code> followed by a selected library name.</li> <li>Actions for inserting operators (subscript, assignment, math, equality, and logical operators).</li> </ul> <p>The file <code>stata.talon</code> is the Talon script which activates the actions defined in <code>stata.py</code>. It sets tags for imperative code, C-like comment blocks, regular comment blocks, comment lines, functions, common functions, libraries, array operators and assignment operators. It sets the <code>user.code_private_function_formatter</code> setting to <code>SNAKE_CASE</code> to apply snake case formatting to function names. Finally, it defines voice commands for: * Inserting named arguments via <code>arg {user.code_parameter_name}</code> * Inserting for loops via <code>state for val</code> * Inserting <code>ssc install</code> via <code>s s c install</code> * Inserting <code>ssc install</code> followed by a library name via <code>s s c install &lt;user.code_libraries&gt;</code> * Toggling library/package inserts via <code>toggle imports</code> or <code>toggle packages</code></p>"},{"location":"lang/tags/","title":"tags","text":"<p>The <code>community/lang/tags</code> directory contains a collection of files that define tags, actions, and rules for various programming language constructs. These files work together to provide a more natural and efficient way to write code using voice commands.</p> <p>The directory is organized by concept, with each concept having a corresponding <code>.py</code> file that defines the actions, and a corresponding <code>.talon</code> file that defines the voice commands. For example, <code>operators_math.py</code> defines actions for inserting mathematical operators, and <code>operators_math.talon</code> defines the voice commands for those actions.</p> <p>Here's a breakdown of the most important files and how they work together:</p> <ul> <li><code>comment_block.py</code>, <code>comment_block.talon</code>, <code>comment_line.py</code>, <code>comment_line.talon</code>, <code>comment_documentation.py</code>, and <code>comment_documentation.talon</code>: These files define commands for inserting various types of comments. The <code>.py</code> files define actions for inserting block comments, line comments, and documentation comments, while the <code>.talon</code> files provide the voice commands for these actions. Notably, <code>comment_block.py</code> defines a <code>code_comment_block_c_like</code> tag and associated actions that are specific to C-style block comments.</li> <li><code>operators_*.py</code> and <code>operators_*.talon</code>: These files define commands for inserting operators. There are several pairs of these files, such as <code>operators_math.py</code> and <code>operators_math.talon</code>, <code>operators_assignment.py</code> and <code>operators_assignment.talon</code>, <code>operators_pointer.py</code> and <code>operators_pointer.talon</code>, <code>operators_array.py</code> and <code>operators_array.talon</code>, <code>operators_lambda.py</code> and <code>operators_lambda.talon</code>, and <code>operators_bitwise.py</code> and <code>operators_bitwise.talon</code>. Each pair defines actions and voice commands for specific kinds of operators. For example, <code>operators_math</code> covers mathematical, comparison, and logical operators; <code>operators_assignment</code> handles assignment and combined assignment operators; and <code>operators_pointer</code> defines pointer-related operators. The <code>.talon</code> files often use the <code>tag(): user.code_operators_math</code> syntax to enable related tags.</li> <li><code>data_bool.py</code> and <code>data_bool.talon</code>: These files define commands for inserting boolean values (<code>true</code> and <code>false</code>). The <code>.py</code> file defines the actions, and the <code>.talon</code> file defines the voice commands.</li> <li><code>data_null.py</code> and <code>data_null.talon</code>: These files define commands for inserting null values and checking for null. The <code>.py</code> file defines the actions, and the <code>.talon</code> file defines the voice commands.</li> <li><code>object_oriented.py</code> and <code>object_oriented.talon</code>: These files provide commands related to object-oriented programming. The <code>.py</code> file defines actions for object access, self-references, and class definitions. The <code>.talon</code> file provides the voice commands and uses the <code>user.code_object_oriented</code> tag to enable these commands.</li> <li><code>functions.py</code>, <code>functions.talon</code>, <code>functions_common.py</code>, and <code>functions_common.talon</code>: These files define commands for working with functions. <code>functions.py</code> defines actions for inserting function declarations with various modifiers and type annotations. <code>functions.talon</code> defines voice commands for these actions. <code>functions_common.py</code> and <code>functions_common.talon</code> define a mechanism for selecting and inserting common functions using a GUI, along with corresponding voice commands. <code>functions_common_gui_active.talon</code> provides a tag to signify that the function picker GUI is currently displayed.</li> <li><code>imperative.py</code> and <code>imperative.talon</code>: These files provide commands for common imperative programming constructs like if, else, for, and while statements. <code>imperative.py</code> defines the actions, and <code>imperative.talon</code> defines the voice commands. <code>imperative.py</code> also defines the <code>code_block_c_like</code> tag, which indicates that the language uses C-style code blocks (braces).</li> <li><code>libraries.py</code> and <code>libraries.talon</code>: These files define commands for importing libraries. <code>libraries.py</code> defines actions for importing libraries, while <code>libraries.talon</code> defines the voice command for this action and enables the <code>user.code_libraries</code> tag.</li> <li><code>keywords.py</code> and <code>keywords.talon</code>: These files define commands for inserting keywords. <code>keywords.py</code> defines an action that inserts keywords. <code>keywords.talon</code> defines the voice command for inserting one or more keywords.</li> </ul> <p>These files demonstrate how Talon's tagging and action system is used to create a rich, extensible, and easily customized programming environment using voice commands. The separation of actions and voice commands allows for flexible customization and language-specific implementations.</p>"},{"location":"lang/talon/","title":"talon","text":"<p>The <code>community/lang/talon</code> directory contains files that extend Talon's functionality for editing and creating Talon code, including <code>.talon</code> and <code>.talon-list</code> files. It also provides utilities for working with Talon's API in Python.</p> <p>Here's a breakdown of the key files and how they work together:</p> <ul> <li><code>talon.py</code>: This Python file is the core of the Talon language support. It defines several contexts (<code>ctx_talon</code>, <code>ctx_talon_python</code>, and <code>ctx_talon_lists</code>) that provide actions specific to Talon code and Python code used within Talon.<ul> <li>It defines tags like <code>user.talon_python</code> and <code>user.talon_populate_lists</code> to enable certain features.</li> <li>It creates lists (<code>user.talon_actions</code>, <code>user.talon_lists</code>, etc.) that can be used in Talon scripts. The <code>user.talon_populate_lists</code> tag must be active for these lists to populate.</li> <li>It registers <code>on_update_decls</code> which automatically updates the talon lists when the Talon registry changes. This allows the lists of actions, captures etc, to be populated from the global talon state.</li> <li>It defines actions like <code>talon_code_insert_action_call</code>, <code>talon_code_enable_tag</code>, and <code>talon_code_enable_setting</code> which can be used to insert code snippets and modify the Talon state when writing Talon code.</li> <li>It defines action classes for the different contexts, providing different behavior for Python and Talon files.</li> <li>It provides common code operators and a generic function insert action for convenience in both Talon and Python contexts.</li> </ul> </li> <li> <p><code>talon_common.talon</code>: This Talon file defines commands that are common to both Talon and Python files. It includes commands for:</p> <ul> <li>Setting tags using <code>tag set {user.talon_tags}</code>.</li> <li>Using lists with <code>list {user.talon_lists}: \"{{{talon_lists}}}\"</code>.</li> <li>Using captures with <code>capture {user.talon_captures}: \"&lt;{talon_captures}&gt;\"</code>.</li> <li>Setting settings with <code>setting {user.talon_settings}: user.talon_code_enable_setting(talon_settings)</code>.</li> <li>Dictating key combos with <code>key &lt;user.keys&gt; over: \"{keys}\"</code> and <code>key &lt;user.modifiers&gt; over: \"{modifiers}\"</code>.</li> <li>Inserting actions with <code>action {user.talon_actions}: user.talon_code_insert_action_call(talon_actions, edit.selected_text())</code>.</li> <li>It activates when the <code>user.talon_python</code> tag is enabled or when the code language is set to either <code>talon</code> or <code>python</code>.</li> </ul> </li> <li> <p><code>talon_python_activator.talon</code>: This file activates the <code>user.talon_python</code> tag which enables the Python specific functionality in <code>talon.py</code> and <code>talon_common.talon</code>. By default it is enabled when editing any python file, but it also includes commented out examples to restrict this functionality to only certain python files.</p> </li> <li><code>talon-list.talon</code>: This file provides a command to insert a list when writing a talon list file. This command is <code>list [require] {user.talon_lists}: \"list: {talon_lists}\"</code> and it requires that the <code>user.talon_populate_lists</code> tag is active.</li> <li><code>talon_code_common_function.talon-list</code>: This file defines a list of common functions (e.g. \"insert\", \"key\", \"print\") that are available when writing talon code. This is used by the <code>user.code_functions_common</code> tag enabled in <code>talon.talon</code>.</li> <li><code>talon_context.talon</code>: This file provides commands for inserting context requirements in <code>.talon</code> and <code>.talon-list</code> files. It enables adding <code>os</code>, <code>win.title</code>, <code>app</code>, <code>mode</code>, <code>tag</code>, and <code>hostname</code> to a context. It requires that the <code>user.talon_python</code> tag is active.</li> <li><code>talon.talon</code>: This file activates several tags that are useful when writing talon code. It activates the <code>user.code_operators_math</code>, <code>user.code_operators_assignment</code>, <code>user.code_comment_line</code>, and <code>user.code_functions_common</code> tags. It also shows an example of enabling the <code>user.talon_populate_lists</code> tag (which is disabled by default) and it also defines a command <code>setting block: insert(\"settings():\\n\\t\")</code> that allows users to insert the beginning of a settings block.</li> </ul> <p>In summary, these files work together to provide a comprehensive set of tools for creating and editing Talon code. They provide context-aware actions, auto-completion for Talon constructs, and ways to manage and navigate code. The <code>talon.py</code> file is the core, defining the logic, while the <code>.talon</code> files provide the voice commands and context activation.</p>"},{"location":"lang/terraform/","title":"terraform","text":"<p>The <code>community/lang/terraform</code> directory contains files to enable voice control of Terraform code using Talon.</p> <p>The most important files are:</p> <ul> <li><code>terraform.talon</code>: This file contains the Talon commands for working with Terraform code. It defines tags to activate the grammar, and commands to insert various elements, such as resource and data blocks, module blocks, common properties, and operators.<ul> <li>The file also uses custom actions to insert module, resource, and data blocks.</li> <li>It enables c-like comments and code blocks, as well as common operators.</li> </ul> </li> <li><code>terraform.py</code>: This file contains the Python implementation of the custom actions and lists used in <code>terraform.talon</code>.<ul> <li>It defines lists of common types (string, number, bool, etc.) and common Terraform properties (name, type, description, etc.).</li> <li>It implements the custom actions used in <code>terraform.talon</code> for inserting Terraform blocks and operators. For example, <code>code_terraform_module_block(text)</code> inserts a module-related block of a given type, and <code>code_terraform_resource(text)</code> inserts a new resource block.</li> <li>It also defines the behavior for inserting operators such as assignment, subtraction, addition, multiplication, division, modulo, equality, inequality, greater than, less than, and/or, etc.</li> </ul> </li> </ul> <p>These files work together to provide a comprehensive set of commands for controlling Terraform code by voice. The <code>terraform.talon</code> file defines the grammar and calls actions in <code>terraform.py</code> to insert code. The lists defined in <code>terraform.py</code> are used to provide voice commands to insert types, properties, and module blocks.</p>"},{"location":"lang/typescript/","title":"typescript","text":"<p>The <code>community/lang/typescript</code> directory contains files that add support for the TypeScript language to Talon.</p> <p>The file <code>typescript.talon</code> defines the basic grammar for working with TypeScript. It specifies that the code language is <code>typescript</code> or <code>typescriptreact</code>. It defines voice commands for inserting type unions (<code>type union</code>), intersections (<code>type intersect</code>), type definitions (<code>state type</code>), and <code>as const</code>.</p> <p>The file <code>typescript.py</code> defines the context and actions specific to TypeScript. It sets the context to be active when the code language is <code>typescript</code> or <code>typescriptreact</code> and the mode is <code>command</code>. It defines a list of code types <code>user.code_type</code>, including <code>boolean</code>, <code>integer</code>, <code>string</code>, <code>null</code>, <code>undefined</code>, <code>number</code>, and <code>any</code>. It defines the following actions on the <code>user</code> action class: *   <code>code_private_function</code>: inserts a private function declaration. *   <code>code_protected_function</code>: inserts a protected function declaration. *   <code>code_public_function</code>: inserts a public function declaration. *   <code>code_insert_type_annotation</code>: inserts a type annotation. *   <code>code_insert_return_type</code>: inserts a return type.</p>"},{"location":"lang/vimscript/","title":"vimscript","text":"<p>The <code>community/lang/vimscript</code> directory contains files that add support for the Vimscript language to Talon.</p> <p>The core logic is in <code>vimscript.py</code>. This file defines a Talon <code>Context</code> that activates when the code language is set to \"vimscript\". It defines two lists: <code>vimscript_functions</code> which contains common Vimscript functions and their spoken forms, and <code>vimscript_scope</code> which contains the different scoping prefixes used in Vimscript. It also defines a number of actions under the <code>user</code> namespace that are used to insert operators, comments, and control flow statements.</p> <p>The file <code>vimscript.talon</code> provides the spoken commands to trigger the functionality defined in <code>vimscript.py</code>. It tags the context with <code>user.code_imperative</code>, <code>user.code_operators_assignment</code>, <code>user.code_operators_math</code>, and <code>user.code_comment_line</code>, providing common code editing features. It also sets the formatting rules for variable and function names to <code>SNAKE_CASE</code>. There are voice commands for inserting variable declarations, functions, and control flow keywords.</p>"},{"location":"migration_helpers/","title":"migration_helpers","text":"<p>The <code>community/migration_helpers</code> directory contains a single file, <code>migration_helpers.py</code>. This file provides functionality to convert CSV files into <code>.talon-list</code> files, which are used by Talon to define lists of words or phrases that can be recognized by voice.</p> <p>Here's a breakdown of how it works:</p> <ul> <li> <p><code>CSVData</code> dataclass: This dataclass is used to define how a specific CSV file should be converted. It contains the following information:</p> <ul> <li><code>name</code>: The name of the Talon list that will be generated.</li> <li><code>path</code>: The path to the CSV file.</li> <li><code>newpath</code>: The path where the generated <code>.talon-list</code> file will be created. It can also be a function to dynamically generate the path.</li> <li><code>is_first_line_header</code>: A boolean that indicates whether the first line of the CSV file is a header that should be skipped.</li> <li><code>is_spoken_form_first</code>: A boolean that indicates whether the spoken form or value is first in the CSV file.</li> <li><code>custom_header</code>: An optional function to generate a custom header for the <code>.talon-list</code> file.</li> <li><code>custom_value_converter</code>: An optional function to convert the value for the generated <code>.talon-list</code> file.</li> </ul> </li> <li> <p><code>supported_csv_files</code> list: This list contains <code>CSVData</code> objects for the CSV files that are automatically migrated by the script. Each entry specifies the location of a CSV file and the corresponding <code>.talon-list</code> that should be generated. For example, <code>user.git_argument</code> in <code>apps/git/git_arguments.csv</code> becomes <code>apps/git/git_argument.talon-list</code>. The <code>user.system_paths</code> list has a lambda which generates a different file name per hostname.</p> </li> <li> <p><code>convert_csv_to_talonlist(input_csv, config)</code> function: This function takes a <code>csv.reader</code> object and a <code>CSVData</code> object and converts the data from the CSV file to the format expected by <code>.talon-list</code> files. It skips empty lines, lines starting with <code>#</code> and also performs the following:</p> <ul> <li>Handles cases where the CSV file has one or two columns.</li> <li>Supports an optional spoken form.</li> <li>Applies custom value converters.</li> <li>Adds a header describing the list.</li> <li>Ensures that non-printable characters are escaped when generating the talon-list.</li> </ul> </li> <li> <p><code>convert_files(csv_files_list)</code> function: This function iterates through all <code>.csv</code> files in the repository, checking them against <code>supported_csv_files</code>. It uses the <code>convert_csv_to_talonlist</code> function to convert the data and writes it to the correct location in a <code>.talon-list</code> file and also renames the <code>.csv</code> file to a <code>.csv-converted-to-talon-list</code> file. It will not overwrite a <code>.talon-list</code> file without making a backup, and will not try to convert CSV files that have been renamed.</p> </li> <li> <p><code>Actions</code> class: This class defines the <code>migrate_known_csv_files</code> action that can be called from Talon to migrate all known CSV files and a <code>migrate_custom_csv</code> action that can be called for a single custom CSV.</p> </li> <li> <p><code>on_ready</code> function: This function is called when Talon is ready and will trigger the migration of known CSV files to <code>.talon-list</code> files. If the Talon action is not available yet, it will print a warning to the user.</p> </li> </ul>"},{"location":"plugin/","title":"plugin","text":"<p>The <code>community/plugin</code> directory contains a collection of subdirectories, each implementing a distinct set of features to enhance the Talon voice control experience. These plugins range from basic text manipulation and command repetition to complex desktop management and custom UI elements.</p> <p>Here's an overview of the most significant subdirectories and files:</p> <ul> <li><code>macro</code>: This directory implements a macro recording and playback system. It contains <code>macro.talon</code>, which defines voice commands for recording, playing, saving, and copying macros, and <code>macro.py</code>, which contains the Python logic for managing the macro recording and playback process. These files work together to allow users to automate sequences of voice commands.</li> <li><code>desktops</code>: This directory provides cross-platform virtual desktop management. It includes <code>desktops.py</code>, which defines the basic actions, <code>desktops.talon</code>, which exposes the actions via voice commands, and platform-specific implementations in <code>desktops_mac.py</code>, <code>desktops_linux.py</code>, and <code>desktops_win.py</code>. This allows users to switch between virtual desktops and move windows across them using voice.</li> <li><code>mouse</code>: This directory provides comprehensive mouse control through voice. It includes <code>mouse_cursor.py</code> which controls the mouse cursor, <code>mouse.talon</code> which provides the voice commands for mouse control, <code>mouse.py</code> which defines mouse actions, and <code>mouse_scroll.py</code> which implements mouse wheel scrolling and gaze-based scrolling.</li> <li><code>talon_draft_window</code>: This directory contains code for a dedicated text editing window, leveraging word labels for voice-driven manipulation. It includes <code>draft_talon_helpers.py</code> which initializes the module, contexts, and actions, <code>draft_ui.py</code> which manages the text area and labels, <code>draft_window_open.talon</code> and <code>draft_window.talon</code> which define voice commands, and <code>draft_global.talon</code> for global commands.</li> <li><code>repeater</code>: This directory adds functionality to repeat commands and phrases. It includes <code>pop_twice_to_repeat.py</code> which repeats a command on a double pop noise, and <code>repeater.talon</code> which defines voice commands for repeating actions, phrases, and commands a specified number of times.</li> <li><code>datetimeinsert</code>: This directory provides a plugin for inserting the current date and time in various formats. It includes <code>datetimeinsert.py</code>, which defines the actions for formatting time, and <code>datetimeinsert.talon</code>, which exposes the actions via voice commands.</li> <li><code>cancel</code>: This directory provides a way to cancel a spoken command using the phrase \"cancel cancel\". It includes <code>cancel.py</code> which handles the cancellation logic, and <code>cancel.talon</code> which defines the \"cancel cancel\" command.</li> <li><code>subtitles</code>: This directory provides a plugin to display subtitles of speech input on the screen. It includes <code>on_phrase.py</code> which captures spoken phrases, <code>subtitles.py</code> which handles the display logic and settings, and <code>subtitles.talon</code> which defines the default settings.</li> <li><code>are_you_sure</code>: This directory implements a confirmation dialog before executing a potentially destructive action. It includes <code>are_you_sure.py</code> which manages the confirmation dialog, and <code>are_you_sure.talon</code> which defines the voice commands for confirming or canceling.</li> <li><code>talon_helpers</code>: This directory contains debugging and helper utilities for Talon. It contains <code>talon_helpers.talon</code> for voice commands, <code>talon_helpers.py</code> for python actions, and <code>create_app_context.py</code> for actions related to creating new app contexts.</li> <li><code>gamepad</code>: This directory provides gamepad support for Talon. It includes <code>gamepad.py</code> and <code>gamepad.talon</code> which implement the core gamepad functionality, and <code>gamepad_tester.py</code> and related <code>.talon</code> files which implement an on-screen visual representation of the gamepad state.</li> <li><code>text_navigation</code>: This directory implements advanced text navigation using voice. It includes <code>text_navigation.py</code> which contains the logic for moving, selecting, and deleting text, and <code>text_navigation.talon</code>, <code>before_or_after.talon-list</code> and <code>navigation_action.talon-list</code> which define the voice commands and vocabulary.</li> <li><code>then</code>: This directory includes <code>then.talon</code>, which provides a \"then\" command to chain otherwise ambiguous commands.</li> <li><code>microphone_selection</code>: This directory contains files for a microphone selection UI. It includes <code>microphone_selection.py</code> which creates the UI, and <code>microphone_selection.talon</code> which provides the voice commands.</li> <li><code>draft_editor</code>: This directory contains files for using a text editor as a draft editor in Talon. It includes <code>draft_editor.py</code> which manages the draft editor, and <code>draft_editor.talon</code> and <code>draft_editor_open.talon</code> which define the voice commands for opening, submitting, and discarding the draft.</li> <li><code>symbols</code>: This directory provides commands for inserting and wrapping text with various symbols. It contains <code>symbols_deprecated.talon</code> with deprecated commands, and <code>symbols.talon</code> for the new preferred method of inserting symbols.</li> <li><code>media</code>: This directory implements basic media controls. It includes <code>media.py</code>, which defines a custom <code>play_pause</code> action, and <code>media.talon</code>, which exposes the action as a voice command.</li> <li><code>command_history</code>: This directory adds command history functionality to Talon. It includes <code>command_history.py</code>, which manages the command history, and <code>command_history.talon</code>, which defines voice commands to display and manage the history.</li> <li><code>screenshot</code>: This directory provides screenshot functionality in Talon. It includes <code>screenshot.py</code> which defines the screenshot actions, and <code>screenshot.talon</code> which defines voice commands for taking screenshots.</li> <li><code>mode_indicator</code>: This directory implements a graphical mode indicator. It includes <code>mode_indicator.py</code> which defines the logic for displaying the mode indicator, and <code>mode_indicator.talon</code> which defines the default settings.</li> <li><code>listening_timeout</code>: This directory implements a timeout for speech recognition. It contains <code>listening_timeout.py</code> which implements the timeout logic and settings.</li> </ul> <p>Additionally, the directory contains these files directly in the <code>community/plugin</code> directory:</p> <ul> <li><code>paste_to_insert.py</code>: This file modifies the default <code>insert</code> action to paste text above a certain threshold defined by the <code>user.paste_to_insert_threshold</code> setting. This allows longer blocks of text to be inserted more reliably than by repeatedly pressing keys.</li> <li><code>README.md</code>: This file provides a high-level overview of the plugins contained in this directory.</li> <li><code>eye_tracking_settings.py</code>: This file contains commented-out code to configure eye tracking and zoom mouse settings.</li> </ul> <p>In summary, the <code>community/plugin</code> directory serves as a central location for a variety of useful Talon extensions, ranging from simple text manipulation to more complex functionalities like desktop management and custom UI elements. The plugins are implemented as a combination of Python files that handle logic and state, and <code>.talon</code> files that define the voice commands, often in conjunction with settings files to customize their behavior.</p>"},{"location":"plugin/are_you_sure/","title":"are_you_sure","text":"<p>The <code>are_you_sure</code> plugin provides a way to require confirmation before executing a potentially destructive action. It displays a message to the user with \"Yes I am sure\" and \"Cancel\" buttons.</p> <p>The core logic is implemented in <code>are_you_sure.py</code>. This file defines the <code>ConfirmationState</code> class which manages the state of the confirmation dialog, including the message, the actions to be performed on confirmation or cancellation, and the display of the ImGUI window. The <code>actions.user.are_you_sure_set_on_confirmation_action</code> action sets the confirmation message and callbacks, and displays the dialog. The <code>actions.user.are_you_sure_confirm</code> action performs the registered action, and the <code>actions.user.are_you_sure_cancel</code> action cancels the registered action. The ImGUI window is defined in the <code>gui</code> function.</p> <p>The <code>are_you_sure.talon</code> file contains the Talon commands that trigger the confirm and cancel actions in the <code>are_you_sure</code> dialog. It activates when the <code>user.are_you_sure</code> tag is active.</p> <p>The <code>README.md</code> file describes how to use the <code>are_you_sure</code> plugin, provides a simple example, and links to the source code. The example demonstrates how to use the <code>actions.user.are_you_sure_set_on_confirmation_action</code> to prompt a user before calling the <code>app.notify</code> action.</p>"},{"location":"plugin/cancel/","title":"cancel","text":"<p>The <code>community/plugin/cancel</code> directory contains files that implement the ability to cancel a spoken command using a specific phrase.</p> <p>The core logic is implemented in cancel.py. This file defines an action <code>cancel_current_phrase()</code> which sets a global timestamp. It also sets a <code>pre:phrase</code> handler, which is called before each command phrase is executed. This handler checks if a spoken phrase:</p> <ul> <li>Started before Talon woke up. This is to prevent accidental commands from being executed if Talon is activated with a non-speech sound or a key press.</li> <li>Ends with the cancel phrase defined as <code>\"cancel cancel\"</code>.</li> </ul> <p>If either of these conditions is true, then the phrase is canceled.</p> <p>The cancel.talon file defines the grammar to invoke the cancel functionality. It defines two commands:</p> <ul> <li><code>cancel cancel$: skip()</code>: This maps the spoken phrase \"cancel cancel\" to a <code>skip()</code> action. In the context of Talon, this action consumes the spoken phrase, preventing it from being executed as a command. The actual logic for canceling a phrase based on this is in <code>cancel.py</code></li> <li><code>ignore [&lt;phrase&gt;]$: app.notify(\"Command ignored\")</code>: This allows you to say \"ignore\" followed by any phrase and it will notify the user of the ignored command. It's designed for situations where you want to say something aloud to a human but don't want Talon to interpret it as a command.</li> </ul>"},{"location":"plugin/command_history/","title":"command_history","text":"<p>The <code>command_history</code> directory contains files that implement a command history feature for Talon.</p> <p>The core logic is in <code>command_history.py</code>. This file defines:</p> <ul> <li><code>command_history_size</code> and <code>command_history_display</code> settings to control how much history is stored and displayed.</li> <li>An <code>on_phrase</code> function that is called each time Talon hears speech. The <code>on_phrase</code> function adds the spoken text to a global <code>history</code> variable and truncates it based on <code>command_history_size</code>. It also calls <code>actions.user.history_transform_phrase_text</code> to allow modifications to the captured text before it is added to the history.</li> <li>An ImGUI window <code>gui</code> that displays the command history. The number of lines displayed depends on <code>command_history_display</code>, unless the user has toggled the <code>hist_more</code> variable to show the whole history. This window also includes a button to close the command history window.</li> <li>A set of actions implemented in the <code>Actions</code> class. These actions control the command history such as toggling the display, clearing the history, and retrieving a specific history entry. Notably, the <code>history_transform_phrase_text</code> action allows for customization of how text is added to the history; by default it only displays text when speech is enabled and joins words with spaces.</li> </ul> <p><code>command_history.talon</code> defines a set of Talon commands that are linked to the actions in <code>command_history.py</code>. These commands enable users to interact with the command history using speech. For example \"command history\" toggles the display, \"command history clear\" clears the history, and \"command history more\" displays the entire history.</p> <p>The files work together to provide the command history functionality. <code>command_history.py</code> defines the core logic and UI, while <code>command_history.talon</code> exposes that functionality via voice commands.</p>"},{"location":"plugin/datetimeinsert/","title":"datetimeinsert","text":"<p>The <code>community/plugin/datetimeinsert</code> directory contains files for a Talon plugin that inserts the current date and time in various formats.</p> <p>The core logic is in <code>datetimeinsert.py</code>. It defines two actions, <code>time_format</code> and <code>time_format_utc</code>, which return the current time and current UTC time respectively, formatted according to a provided format string. If no format string is provided, the time is returned in ISO format. These actions are made available to Talon scripts through the <code>@mod.action_class</code> decorator.</p> <p><code>datetimeinsert.talon</code> provides voice commands to insert the date and time using the actions defined in <code>datetimeinsert.py</code>. The commands call <code>user.time_format</code> and <code>user.time_format_utc</code> with specific format strings to produce the desired output.  For example, \"date insert\" inserts the current date in the format \"YYYY-MM-DD\". There are commands for inserting date and timestamps, both in the local timezone and UTC, and with high-resolution timestamps including milliseconds.</p>"},{"location":"plugin/desktops/","title":"desktops","text":"<p>This directory contains files for managing virtual desktops across different operating systems.</p> <p>The core functionality is defined in <code>desktops.py</code>, which defines a set of actions for desktop manipulation. These actions are initially implemented with a \"Not supported on this operating system\" message. This file also contains the <code>Actions</code> class that is inherited from in platform-specific files.</p> <p><code>desktops.talon</code> provides the Talon commands for interacting with the actions defined in <code>desktops.py</code>. It maps voice commands like \"desk one\", \"desk next\", \"window move desk two\", etc., to the corresponding actions.</p> <p>The remaining files provide platform-specific implementations of the actions defined in <code>desktops.py</code>.  They are all context-specific using <code>talon.Context</code>, and override the \"Not supported\" implementations from <code>desktops.py</code></p> <ul> <li><code>desktops_mac.py</code> provides the implementations for macOS, using keyboard shortcuts like <code>ctrl-number</code> to switch desktops and mouse drags to move windows between desktops. It also adds special handling for the Amethyst window manager using <code>ctrl-alt-shift-number</code>.</li> <li><code>desktops_linux.py</code> uses the <code>ui.switch_workspace</code> function and <code>ui.active_window().workspace</code> properties to manage virtual desktops on Linux.</li> <li><code>desktops_win.py</code> provides implementations for Windows, using keyboard shortcuts like <code>super-ctrl-right</code> and <code>super-tab</code>. It does not include window movement commands.</li> </ul> <p>In summary, this directory provides a cross-platform way to manage virtual desktops using Talon, with platform-specific implementations. The files work together by defining the initial actions, the talon commands, and the specific implementations for each operating system.</p>"},{"location":"plugin/draft_editor/","title":"draft_editor","text":"<p>The <code>draft_editor</code> directory contains files that implement a \"draft editor\" feature for Talon. This allows users to quickly copy some text to a separate editor, edit it, and then paste the result back into the original location.</p> <p>The core logic is found in <code>draft_editor.py</code>. This Python file defines the actions and behavior of the draft editor. </p> <p>Here's how it works:</p> <ul> <li>Tagging: It uses Talon tags (<code>draft_editor_active</code>, <code>draft_editor_app_running</code>, <code>draft_editor_app_focused</code>) to keep track of the state of the draft editor.</li> <li>App Detection: It detects which application to use as the draft editor based on the <code>user.draft_editor</code> setting. If this setting is not configured, it defaults to a list of common code editor names like \"Visual Studio Code\" and \"Code\". It uses <code>ui.apps</code> to determine running applications.</li> <li>Opening the Draft Editor: The <code>draft_editor_open</code> action opens a new tab in the configured draft editor application, pastes the selected text (if any) into it, and sets the <code>draft_editor_active</code> tag.</li> <li>Submitting the Draft: The <code>draft_editor_submit</code> action selects all text in the editor, saves the selected text as the <code>last_draft</code>, closes the tab, and then attempts to return focus to the original window and paste the text. If focus cannot return to the original window, the user will need to manually focus the correct window, and use \"draft submit\" again.</li> <li>Discarding the Draft: The <code>draft_editor_discard</code> action closes the draft editor tab without pasting it. </li> <li>Pasting Last Draft: The <code>draft_editor_paste_last</code> action will paste the previously submitted <code>last_draft</code>.</li> </ul> <p>The other <code>.talon</code> files define the voice commands that interact with the Python logic:</p> <ul> <li><code>draft_editor.talon</code> defines the commands used to open a draft editor from the main application.<ul> <li>\"draft this\" opens a draft editor with the current selection.</li> <li>\"draft all\" opens a draft editor with the entire document.</li> <li>\"draft line\" opens a draft editor with the current line.</li> <li>\"draft top\" opens a draft editor with content from the start of the file up to the cursor.</li> <li>\"draft bottom\" opens a draft editor with content from the cursor to the end of the file.</li> <li>\"draft submit\" pastes the last submitted draft. This can be used in case the user has to manually focus the intended destination, instead of using <code>draft_editor_submit</code>.</li> </ul> </li> <li><code>draft_editor_open.talon</code> defines the commands used when the draft editor is open and focused.<ul> <li>\"draft submit\" submits the current draft using <code>draft_editor_submit</code>.</li> <li>\"draft discard\" discards the current draft using <code>draft_editor_discard</code>.</li> </ul> </li> </ul> <p>In summary, this plugin provides a convenient way to use a text editor as a scratchpad for editing text within Talon. It uses tags, application detection, and actions to manage the draft editor's state and behavior.</p>"},{"location":"plugin/dropdown/","title":"dropdown","text":"<p>The <code>community/plugin/dropdown</code> directory contains a single file, <code>dropdown.talon</code>.</p> <p>This file contains Talon commands for interacting with dropdown menus. However, the content of the file indicates that these commands are deprecated and have been replaced with <code>choose</code> and <code>choose up</code> commands.</p>"},{"location":"plugin/gamepad/","title":"gamepad","text":"<p>The <code>community/plugin/gamepad</code> directory contains code that enables the use of a gamepad to control a computer, and a visual tester for debugging the gamepad integration.</p> <p>The core functionality is in <code>gamepad.py</code> and <code>gamepad.talon</code>. The python file defines actions for each gamepad input, such as <code>gamepad_press_dpad_left</code> and <code>gamepad_stick_left</code>. It also defines helper functions such as <code>gamepad_scroll</code> and <code>gamepad_mouse_move</code>. The talon file maps gamepad events to the actions defined in the python file. For example, it maps the gamepad <code>dpad_left:down</code> event to the <code>user.gamepad_button_down(\"dpad_left\")</code> action, which then calls <code>actions.user.gamepad_press_dpad_left()</code>.</p> <p>The <code>README.md</code> provides a basic overview of the plugin. It includes a link to a demo video of the plugin in use and instructions for how to use the included gamepad tester.</p> <p>The <code>gamepad_settings.talon</code> file contains a commented out tag <code>user.gamepad</code>. Uncommenting this tag will enable the gamepad functionality defined in <code>gamepad.talon</code>.</p> <p>The gamepad tester functionality is defined in <code>gamepad_tester.py</code>, <code>gamepad_tester_open.talon</code>, and <code>gamepad_tester.talon</code>. The python file defines an on-screen GUI that renders the current state of the gamepad buttons, triggers, and sticks. The <code>gamepad_tester.talon</code> file has a single command, <code>\"gamepad tester\"</code>, which toggles the gamepad tester UI using the <code>user.gamepad_tester_toggle</code> action defined in the python file. The <code>gamepad_tester_open.talon</code> file maps gamepad events to actions that update the state of the gamepad tester UI. For example, the <code>gamepad(dpad_up:down)</code> event triggers the <code>user.gamepad_tester_button(\"dpad_up\", true)</code> action, which updates the on-screen representation of the D-pad up button to indicate that it is pressed.</p>"},{"location":"plugin/listening_timeout/","title":"listening_timeout","text":"<p>The <code>community/plugin/listening_timeout</code> directory contains code that implements a timeout for speech recognition. If no speech is detected for a configurable period of time, speech recognition will be disabled.</p> <p>The main logic for this functionality is in the <code>listening_timeout.py</code> file.</p> <p>Here's a breakdown of how it works:</p> <ul> <li>Settings: The module exposes two settings: <code>listening_timeout_minutes</code> (an integer that specifies the timeout in minutes) and <code>listening_timeout_show_notification</code> (a boolean that, if enabled, causes a notification to be displayed when the timeout is triggered).</li> <li>Timeout Trigger: The <code>SpeechActions.enable()</code> and <code>post_phrase()</code> functions are used to start and reset the timeout timer using <code>cron.after()</code> which calls <code>check_timeout()</code> when the timer expires. <code>SpeechActions.enable()</code> is called when speech recognition is enabled. <code>post_phrase()</code> is called after Talon recognizes a phrase.</li> <li>Timeout Logic: The <code>check_timeout()</code> function checks if the timeout has expired by comparing the last phrase time to the current time. If the timeout has expired, <code>UserActions.listening_timeout_expired()</code> is called which disables speech recognition and may display a notification if the <code>listening_timeout_show_notification</code> setting is enabled.</li> <li>Notification: The <code>show_notification()</code> function displays a notification using <code>actions.app.notify()</code> when the timeout expires and the <code>listening_timeout_show_notification</code> setting is enabled.</li> <li>Initialization: When the Talon app starts and is ready, the <code>on_ready()</code> function initializes the <code>last_phrase_time</code> and starts the timeout job if speech is enabled. It also registers the <code>post_phrase()</code> function so it will be called after every phrase.</li> </ul> <p>In summary, <code>listening_timeout.py</code> adds a speech timeout feature to Talon that disables speech recognition after a period of inactivity and provides a notification when the timeout is reached. This can help prevent Talon from unintentionally interpreting ambient sounds as speech, while enabling automatic re-enabling of speech recognition whenever a phrase is recognized.</p>"},{"location":"plugin/macro/","title":"macro","text":"<p>This directory contains files that implement a macro recording and playback system. It allows users to record sequences of voice commands and replay them later with a single command.</p> <p>The core functionality is split between the Talon file <code>macro.talon</code> and the Python file <code>macro.py</code>.</p>"},{"location":"plugin/macro/#macrotalon","title":"<code>macro.talon</code>","text":"<p>This file defines the voice commands that users will use to interact with the macro system. It provides commands for:</p> <ul> <li>Starting and stopping macro recording (<code>macro record</code>, <code>macro stop</code>).</li> <li>Playing back a macro, either the last recorded or a named one (<code>macro play [{user.saved_macros}]</code>).</li> <li>Copying a macro to the clipboard as a Talon command, either the last recorded or a named one (<code>macro copy [{user.saved_macros}]</code>, <code>macro copy as &lt;user.text&gt;</code>).</li> <li>Saving a macro with a name (<code>macro save as &lt;user.text&gt;</code>).</li> <li>Listing and closing the list of saved macros (<code>macro list</code>, <code>macro list close</code>).</li> </ul>"},{"location":"plugin/macro/#macropy","title":"<code>macro.py</code>","text":"<p>This file contains the Python implementation of the macro system. It defines the actions that are performed when the voice commands in <code>macro.talon</code> are spoken. Key parts of this file are:</p> <ul> <li><code>Actions</code> class: This class defines all the actions the <code>macro.talon</code> file uses, including recording, stopping, saving, playing, and copying macros.</li> <li><code>macro_record()</code>: Initializes a new macro recording by resetting the <code>macro</code> list and sets the <code>recording</code> flag to <code>True</code>.</li> <li><code>macro_stop()</code>: Stops the macro recording and removes the \"stop\", \"play\", or \"save\" command from the macro.</li> <li><code>macro_save(name)</code>: Saves the current macro under the specified <code>name</code> and updates a list of saved macros called <code>user.saved_macros</code>.</li> <li><code>macro_play(name)</code>: Plays back the macro by using <code>actions.mimic()</code> to simulate the recorded voice commands. If a <code>name</code> is specified it will load the macro saved under that name, otherwise it will replay the last recorded command.</li> <li><code>macro_copy(name)</code>: Copies the macro as a series of <code>mimic()</code> commands to the clipboard as text that can be pasted into a Talon file. If a <code>name</code> is specified, it will load that macro. If a <code>name</code> is not specified, it will copy the most recently recorded macro.</li> <li><code>macro_append_command(words)</code>: Appends the command that was just uttered to the <code>macro</code> list.</li> <li><code>speech_system.register(\"pre:phrase\", fn)</code>: Registers a callback function <code>fn</code> that is called before a phrase is processed. This function is responsible for listening to what was spoken while recording and passing it on to the <code>macro_append_command</code> function to be added to the current <code>macro</code> list.</li> <li><code>macro_list_gui()</code>: Creates an imgui interface to display a list of the user's saved macros.</li> </ul>"},{"location":"plugin/macro/#how-they-work-together","title":"How they work together","text":"<p>The <code>.talon</code> file provides the user interface for the macro functionality, allowing the user to control the macro recording and playback process with voice commands. The <code>.py</code> file handles the logic, state management, and execution.</p> <p>When a user speaks a command like \"macro record,\" the corresponding action in <code>macro.py</code> is triggered and the system starts recording the user's subsequent voice commands. These commands are stored in the <code>macro</code> list in <code>macro.py</code>. When the user says \"macro stop\", the recording stops and the <code>macro</code> list contains a series of lists of words that were spoken during the recording.</p> <p>Commands like \"macro play\" or \"macro save as\" then access that list to replay or save them for later use.</p>"},{"location":"plugin/media/","title":"media","text":"<p>The <code>community/plugin/media</code> directory contains code for controlling media playback and volume.</p> <p>The core functionality is in media.py, which defines a custom <code>play_pause</code> action. This action sends a <code>play_pause</code> keypress on Windows and a <code>play</code> keypress on other platforms.</p> <p>The file media.talon exposes the <code>play_pause</code> action as a voice command, along with other media controls like setting the volume or going to the next or previous track. These commands use the built-in Talon <code>key</code> action to send key presses like <code>volup</code>, <code>voldown</code>, <code>mute</code>, <code>next</code>, and <code>prev</code>.</p>"},{"location":"plugin/microphone_selection/","title":"microphone_selection","text":"<p>The <code>community/plugin/microphone_selection</code> directory contains files that implement a user interface for selecting a microphone in Talon.</p> <p>The core logic is in <code>microphone_selection.py</code>. This file defines a module that:</p> <ul> <li>Uses the <code>cubeb</code> library to get a list of available microphones.</li> <li>Creates an <code>imgui</code> graphical user interface to display the list of microphones.</li> <li>Provides actions for toggling the GUI, hiding the GUI, and selecting a microphone.</li> <li>Registers a callback to update the list of microphones when devices change.</li> </ul> <p>The <code>update_microphone_list</code> function populates the global <code>microphone_device_list</code> variable with available microphone names. It always includes \"None\" and \"System Default\" at the beginning of the list to match Talon's context menu. On Windows, it filters out microphones that are not currently enabled.</p> <p>The <code>gui</code> function creates the <code>imgui</code> interface. It displays a list of buttons, each corresponding to a microphone. Clicking a button triggers the <code>microphone_select</code> action.</p> <p>The <code>microphone_selection_toggle</code> action toggles the visibility of the GUI.</p> <p>The <code>microphone_select</code> action takes an index as an argument, and uses it to select a microphone from <code>microphone_device_list</code>. It uses <code>actions.sound.set_microphone</code> to change the active microphone, and notifies the user of the change.</p> <p>The <code>on_ready</code> function registers the <code>devices_changed</code> callback with <code>cubeb</code> and updates the list of microphones when Talon is ready.</p> <p>The file <code>microphone_selection.talon</code> provides voice commands to interact with the functionality defined in the python file. These voice commands are:</p> <ul> <li><code>microphone show</code>: Toggles the microphone selection GUI.</li> <li><code>microphone close</code>: Hides the microphone selection GUI.</li> <li><code>microphone pick &lt;number_small&gt;</code>: Selects a microphone using its index from the GUI.</li> </ul>"},{"location":"plugin/mode_indicator/","title":"mode_indicator","text":"<p>The <code>community/plugin/mode_indicator</code> directory contains a plugin that displays a graphical indicator showing the current Talon mode. The indicator is a circle with a color that changes based on the active mode (command, dictation, sleep, etc.) and the microphone status.</p> <p>The core logic resides in <code>mode_indicator.py</code>. This file defines the plugin's behavior using the Talon framework. It manages the indicator's display, position, size, and color. The indicator is drawn on a canvas, and its appearance is controlled by several settings, which can be configured in the <code>mode_indicator.talon</code> file.</p> <p>Here is how it works:</p> <ul> <li>The script initializes several settings to control the mode indicator's appearance, such as <code>mode_indicator_show</code> (whether to show the indicator), <code>mode_indicator_size</code>, <code>mode_indicator_x</code>, <code>mode_indicator_y</code>, and various color settings for different modes and microphone states.</li> <li>The <code>on_update_contexts</code> function determines the current Talon mode (<code>sleep</code>, <code>dictation</code>, <code>mixed</code>, <code>command</code>, or <code>other</code>) based on the active contexts. When the mode changes, the indicator is updated.</li> <li>The <code>poll_microphone</code> function checks the active microphone and updates the indicator if the microphone state has changed (e.g., muted).</li> <li>The <code>update_indicator</code> function handles showing, hiding, and moving the indicator based on the <code>user.mode_indicator_show</code> setting.</li> <li>The <code>on_draw</code> function is called by the canvas to draw the indicator as a colored circle with a gradient. The colors are determined by the current mode and configured in <code>mode_indicator.talon</code>.</li> <li>The <code>move_indicator</code> function calculates the indicator's position based on the user's settings for <code>x</code> and <code>y</code> position.</li> <li>The <code>on_update_settings</code> is called when the settings are changed and updates the indicator if any of the mode indicator settings changed.</li> <li>The <code>on_ready</code> function registers callbacks to listen for context and setting changes.</li> </ul> <p>The file <code>mode_indicator.talon</code> provides the default settings for the mode indicator. This is where users can customize the indicator's appearance, including its size, position, transparency, colors for different modes and microphone states.  By default the indicator is not shown, the size is 30 pixels, it is centered horizontally, and at the top vertically.  The default colors are: black for mute, grey for sleep, gold for dictation, MediumSeaGreen for mixed, CornflowerBlue for command, and GhostWhite for other.</p> <p>The <code>README.md</code> file provides a basic description of the plugin, example images of the different modes, and a link to a demo video on YouTube: YouTube - Mode indicator demo. It also explains how to enable the plugin by changing the <code>user.mode_indicator_show</code> setting in <code>mode_indicator.talon</code>.</p>"},{"location":"plugin/mouse/","title":"mouse","text":"<p>The <code>community/plugin/mouse</code> directory contains files for controlling the mouse cursor and scrolling behavior within Talon. It provides functionalities such as hiding/showing the cursor, simulating mouse clicks, dragging, and scrolling, as well as integrating with eye-tracking for gaze-based scrolling.</p> <p>Here's a breakdown of the key files and their roles:</p> <ul> <li><code>mouse_cursor.py</code>: This file is responsible for hiding and showing the mouse cursor, particularly on Windows. It defines a <code>mouse_cursor_commands_enable</code> tag, which enables the commands defined in <code>mouse_cursor.talon</code>. It uses the Windows registry to replace the default cursor with a hidden cursor image. It also defines <code>mouse_cursor_show</code> and <code>mouse_cursor_hide</code> actions.</li> <li><code>mouse.talon</code>: This Talon file defines voice commands for various mouse actions, including:<ul> <li>Toggling control mouse, zoom mouse, and camera overlay modes.</li> <li>Simulating left, right, and middle mouse clicks.</li> <li>Performing single, double, and triple clicks.</li> <li>Initiating and ending mouse drags.</li> <li>Scrolling the mouse wheel up, down, left, and right.</li> <li>Copying the current mouse position.</li> <li>It also includes deprecated commands.</li> <li>It interacts with the <code>mouse.py</code>, <code>mouse_scroll.py</code>, and <code>tracking</code> files.</li> </ul> </li> <li><code>mouse.py</code>: This file defines actions for controlling mouse behavior and settings for mouse functionality:<ul> <li><code>mouse_wake</code> to enable control mouse, zoom mouse and hide the cursor (conditionally based on <code>mouse_wake_hides_cursor</code> setting)</li> <li><code>mouse_sleep</code> to disable control and zoom mouse and show the cursor.</li> <li><code>mouse_drag</code> and <code>mouse_drag_end</code> for starting and stopping drags.</li> <li><code>mouse_drag_toggle</code> for toggling drags.</li> <li><code>copy_mouse_position</code> for copying the current mouse position to the clipboard.</li> <li><code>mouse_move_center_active_window</code> to move the cursor to the center of the active window.</li> <li><code>noise_trigger_pop</code> which handles pop noises to trigger clicks or stop drags/scrolls. It respects the <code>mouse_enable_pop_click</code>, <code>mouse_enable_pop_stops_scroll</code>, and <code>mouse_enable_pop_stops_drag</code> settings.</li> </ul> </li> <li><code>mouse_scroll.py</code>: This file handles mouse wheel scrolling and defines actions for scrolling up, down, left, and right. It also provides continuous scroll functionalities and gaze based scrolling:<ul> <li><code>mouse_scroll_up</code>, <code>mouse_scroll_down</code>, <code>mouse_scroll_left</code>, and <code>mouse_scroll_right</code> for discrete scrolling.</li> <li><code>mouse_scroll_up_continuous</code>, <code>mouse_scroll_down_continuous</code> and <code>mouse_gaze_scroll</code> for continuous scrolling.</li> <li><code>mouse_scroll_stop</code> for stopping continuous scrolling.</li> <li><code>hiss_scroll_up</code> and <code>hiss_scroll_down</code> for changing the direction of scroll on a hiss.</li> <li>A GUI is created to display the current scroll mode.</li> <li><code>noise_trigger_hiss</code> is triggered on a hiss.</li> <li>It interacts with the <code>tracking</code> module to toggle the control mouse.</li> <li>It defines settings for wheel amounts, continuous scroll amounts, and acceleration factors.</li> </ul> </li> <li><code>mouse_cursor.talon</code>: This file defines voice commands for showing or hiding the mouse cursor and is enabled by the <code>user.mouse_cursor_commands_enable</code> tag defined in <code>mouse_cursor.py</code>.</li> </ul> <p>These files work together to provide a comprehensive set of mouse control features. The <code>mouse.talon</code> file provides the voice interface, calling functions from <code>mouse.py</code> and <code>mouse_scroll.py</code>, which in turn interact with the operating system via Talon's built-in actions and <code>ctrl</code>. The <code>mouse_cursor.py</code> and <code>mouse_cursor.talon</code> files provide functions for hiding and showing the cursor on Windows.</p> <p>The <code>mouse.py</code> file also contains settings that customize the behavior of the scripts, such as enabling pop clicks, stopping scroll, and stopping drag. The <code>mouse_scroll.py</code> provides settings for the scroll wheel amount, continuous scrolling amounts, and the acceleration factor.</p>"},{"location":"plugin/repeater/","title":"repeater","text":"<p>The <code>community/plugin/repeater</code> directory contains code that adds functionality to repeat commands and phrases in Talon.</p> <p>The file <code>pop_twice_to_repeat.py</code> implements a feature that repeats the previous command if the user makes a \"pop\" noise twice in quick succession. It achieves this by:</p> <ul> <li>Tracking the time of the last \"pop\" noise.</li> <li>If the current \"pop\" occurs within the time window configured by the <code>user.double_pop_speed_minimum</code> and <code>user.double_pop_speed_maximum</code> settings, it calls <code>actions.core.repeat_command()</code>. This time window is necessary to avoid accidental repeats from two pops that are not intended to be a double pop.</li> <li>It uses a tag <code>user.pop_twice_to_repeat</code> to enable this functionality in command mode.</li> <li>It ensures that it does not interfere with mouse zoom which also uses the pop noise.</li> </ul> <p>The file <code>repeater.talon</code> defines Talon commands for repeating actions:</p> <ul> <li>It enables repeating a command a specified number of times by saying \"repeat that &lt;number&gt; times\" or \"&lt;ordinal number&gt;\".</li> <li>It provides a \"repeat that\" or \"twice\" command for repeating the command once.</li> <li>It supports repeating the last spoken phrase using \"repeat phrase\" or \"again\" and an optional number of times.</li> <li>It calls <code>actions.core.repeat_command()</code> for all of the above, using the number of repetitions spoken as an argument, with the spoken number decremented by one to account for the initial action. For example, saying \"three times\" will cause <code>actions.core.repeat_command(2)</code> to be called.</li> <li>It calls <code>actions.core.repeat_partial_phrase()</code> to repeat the last spoken phrase a specified number of times.</li> </ul>"},{"location":"plugin/screenshot/","title":"screenshot","text":"<p>The <code>community/plugin/screenshot</code> directory contains the code for a screenshot utility in Talon. It allows users to take screenshots of their entire screen, specific windows, or selected areas, and save them to a file or the clipboard.</p> <p>The core logic is in <code>screenshot.py</code>, which defines the following actions:</p> <ul> <li><code>screenshot(screen_number: Optional[int] = None)</code>: Takes a screenshot of the entire screen. It accepts an optional screen number to capture a specific screen in a multi-monitor setup. If no screen number is provided, the main screen is used.</li> <li><code>screenshot_window()</code>: Takes a screenshot of the active window.</li> <li><code>screenshot_selection()</code>: Triggers the system's built-in screenshot selection tool.</li> <li><code>screenshot_selection_clip()</code>: Triggers the system's built-in screenshot selection tool and copies the result to the clipboard.</li> <li><code>screenshot_settings()</code>: Opens the system screenshot settings UI (currently only implemented for macOS).</li> <li><code>screenshot_clipboard(screen_number: Optional[int] = None)</code>: Takes a screenshot of the entire screen and copies it to the clipboard. It also accepts an optional screen number.</li> <li><code>screenshot_window_clipboard()</code>: Takes a screenshot of the active window and copies it to the clipboard.</li> <li><code>screenshot_rect(rect: ui.Rect, title: str = \"\", screen_num: Optional[int] = None)</code>: Takes a screenshot of a given rectangle on the screen. This is a lower-level function intended for use by other parts of Talon.</li> </ul> <p>The <code>screenshot.py</code> file also includes helper functions like <code>clipboard_rect</code>, <code>get_screenshot_path</code>, <code>flash_rect</code>, and <code>get_screen</code>. Notably, the <code>get_screenshot_path</code> function determines where to save the screenshot based on a user setting and includes a timestamp in the filename. The <code>flash_rect</code> function briefly flashes a white rectangle on the screen before taking a screenshot to provide visual feedback to the user.</p> <p>Context-specific actions for triggering selection screenshots are defined for Mac, Windows, and Linux in the <code>screenshot.py</code> file, using separate <code>Context</code> objects: <code>ctx_mac</code>, <code>ctx_win</code>, and <code>ctx_linux</code>. They trigger OS-specific commands using <code>actions.key()</code>.</p> <p>The file <code>screenshot.talon</code> defines the voice commands that invoke the actions defined in <code>screenshot.py</code>. It provides a straightforward way to trigger the screenshot actions through voice commands. For example, saying \"grab screen\" will trigger <code>user.screenshot()</code>, and \"grab window clip\" will trigger <code>user.screenshot_window_clipboard()</code>. The grammar includes an optional screen number to choose a particular screen to screenshot.</p>"},{"location":"plugin/subtitles/","title":"subtitles","text":"<p>The <code>community/plugin/subtitles</code> directory contains the code for a custom subtitles plugin for Talon. This plugin displays subtitles of speech input on the screen. It allows customization of the subtitles' appearance, location, and duration.</p> <p>The core functionality resides in these files:</p> <ul> <li> <p><code>on_phrase.py</code>: This file hooks into Talon's speech system to capture spoken phrases. The <code>on_pre_phrase</code> function is registered to be called on every spoken phrase. It extracts the spoken words and calls the <code>show_subtitle</code> function from <code>subtitles.py</code> to display the subtitle on the screen. This file also contains logic to skip phrases in sleep mode.</p> </li> <li> <p><code>subtitles.py</code>: This file implements the subtitle display logic.</p> <ul> <li>It defines various settings using the <code>setting</code> function decorator such as <code>show</code>, <code>screens</code>, <code>size</code>, <code>color</code>, <code>color_outline</code>, <code>timeout_per_char</code>, <code>timeout_min</code>, <code>timeout_max</code>, and <code>y</code>.</li> <li>The <code>show_subtitle</code> function is the main entry point for displaying subtitles. It clears existing subtitles and creates a new canvas for each screen selected by the user, then calls <code>show_text_on_screen</code> to display the subtitle.</li> <li>The <code>get_screens</code> function determines which screens to display the subtitles on, based on the user's <code>subtitles_screens</code> setting.</li> <li>The <code>show_text_on_screen</code> creates a canvas on the given screen and uses <code>on_draw</code> to actually draw the text. It sets a timeout to clear the canvas.</li> <li>The <code>on_draw</code> function is where the text is rendered using Skia. It calculates the position of the text, applies a drop shadow, sets the colors, and draws the text and its outline using settings defined in <code>subtitles.talon</code>.</li> <li>The <code>calculate_timeout</code> function calculates how long the subtitle should be displayed on the screen using user defined settings.</li> <li>The <code>set_text_size_and_get_rect</code> function calculates the size of text based on the screen size and scales the font down so that the text will fit within the screen bounds.</li> <li>The <code>clear_canvases</code> function closes all open canvases and clears the list of canvases.</li> </ul> </li> <li> <p><code>subtitles.talon</code>: This file defines the default settings for the subtitles plugin. These settings include:</p> <ul> <li><code>user.subtitles_show</code>: A boolean to enable or disable the subtitles.</li> <li><code>user.subtitles_screens</code>: The screens on which to display subtitles.</li> <li><code>user.subtitles_size</code>: The size of the subtitle text.</li> <li><code>user.subtitles_color</code>: The color of the subtitle text.</li> <li><code>user.subtitles_color_outline</code>: The outline color of the subtitle text.</li> <li><code>user.subtitles_timeout_per_char</code>: The time to extend the timeout for each character.</li> <li><code>user.subtitles_timeout_min</code>: The minimum display time for a subtitle.</li> <li><code>user.subtitles_timeout_max</code>: The maximum display time for a subtitle.</li> <li><code>user.subtitles_y</code>: The vertical position of the subtitle.</li> </ul> </li> <li> <p><code>README.md</code>: This file provides documentation for the subtitles plugin, including how to enable/disable the subtitles and other configuration options in <code>subtitles.talon</code>.</p> </li> </ul> <p>In summary, the plugin works by intercepting spoken phrases, rendering those phrases as text on screen according to the configurable settings, and automatically removing those subtitles after a set time.</p>"},{"location":"plugin/symbols/","title":"symbols","text":"<p>The <code>community/plugin/symbols</code> directory contains Talon files related to inserting and wrapping text with various symbols.</p> <p>The file <code>symbols_deprecated.talon</code> defines a series of deprecated commands for inserting matched delimiters or wrapping a selection in delimiters. For example, the command <code>empty string</code> inserts two single quotes with the cursor between them and <code>quote that</code> wraps the selected text with single quotes. These commands are deprecated and should not be used. They use the <code>user.deprecate_command</code> command with the date \"2024-11-24\".</p> <p>The file <code>symbols.talon</code> defines commands for inserting common symbols, like <code>new line</code> or <code>arrow</code>, and implements the <code>user.delimiter_pair_insert</code> and <code>user.delimiter_pair_wrap_selection</code> actions. These actions are then bound to the <code>user.delimiter_pair</code> grammar. For example, <code>(parens | args)</code> is bound to the <code>\"()\"</code> string, and when spoken with the <code>that</code> suffix will call the <code>user.delimiter_pair_wrap_selection</code> action and wrap the selection with parentheses. When spoken without the suffix it will call the <code>user.delimiter_pair_insert</code> action and insert two parentheses with the cursor between them. This file implements the preferred way to insert or wrap text with delimiters.</p>"},{"location":"plugin/talon_draft_window/","title":"talon_draft_window","text":"<p>The <code>talon_draft_window</code> directory contains the code for a Talon plugin that provides a dedicated window for editing text, using a system of word labels to enable voice-driven manipulation.</p> <p>The core logic resides in these files:</p> <ul> <li><code>draft_talon_helpers.py</code>: This file sets up the Talon module, contexts, settings, and actions that manage the draft window. It initializes the <code>DraftManager</code> which is responsible for the UI. It also handles settings for the window's theme, text size, and label styling.  It defines actions for showing, hiding, selecting text, positioning the caret, and resizing the draft window. It also includes a workaround for the experimental textarea's undo functionality. Finally it defines capture groups for anchors (<code>&lt;user.draft_anchor&gt;</code>) and positions (<code>&lt;user.draft_window_position&gt;</code>).</li> <li><code>draft_ui.py</code>:  This file contains the <code>DraftManager</code> class, which manages the text area using Talon's experimental textarea API, and the logic to generate word labels. It implements <code>calculate_text_anchors</code> which assigns a letter to each word in the draft window. This class also sets the style of the text area, and handles moving and resizing of the window.</li> </ul> <p>These files provide the user-facing interface and customization options:</p> <ul> <li><code>draft_window_open.talon</code>: This file defines Talon commands that are active when the draft window is open (but not necessarily focused). It includes commands to hide the window and to submit the text in the window back to the editor.</li> <li><code>draft_window.talon</code>: This file contains Talon commands that are active when the draft window is focused. It defines commands for replacing words, positioning the cursor, selecting words, deleting words and applying formatters using the anchor labels. It also enables smart dictation mode.</li> <li><code>settings.talon.example</code>: Provides example settings that the user can copy into their own Talon files to customize the appearance of the draft window.</li> </ul> <p>These files support the plugin's functionality:</p> <ul> <li><code>__init__.py</code>: An empty file that allows pytest to run the tests.</li> <li><code>test_draft_ui.py</code>: Contains unit tests for the <code>calculate_text_anchors</code> function in <code>draft_ui.py</code>.</li> <li><code>LICENSE</code>: Contains the MIT license for this project.</li> </ul> <p>Finally, <code>draft_global.talon</code> defines commands to show the draft window globally in command mode. It includes commands to open the window in different positions and sizes, and also to copy the current selection into the draft window.</p> <p>In summary, <code>draft_talon_helpers.py</code> and <code>draft_ui.py</code> implement the core functionality of the plugin.  The <code>.talon</code> files provide the voice commands to make use of the functionality, while <code>test_draft_ui.py</code> and <code>LICENSE</code> provide support and licensing. <code>README.md</code> provides documentation about how to use the plugin.</p>"},{"location":"plugin/talon_helpers/","title":"talon_helpers","text":"<p>The <code>community/plugin/talon_helpers</code> directory contains files that provide actions for debugging and interacting with Talon.</p> <ul> <li> <p><code>talon_helpers.talon</code> defines the voice commands that trigger the actions in <code>talon_helpers.py</code> and <code>create_app_context.py</code>.</p> <ul> <li>It includes commands for checking for updates, opening debug windows and logs, and copying application context information to the clipboard.</li> <li>It also provides commands for simulating phrases, debugging actions, lists, tags, modes, and scopes. These commands are useful for understanding the current state of Talon.</li> <li>Finally, there are commands to help create new application contexts.</li> </ul> </li> <li> <p><code>talon_helpers.py</code> provides python implementations of the actions called in <code>talon_helpers.talon</code>.</p> <ul> <li>It includes actions for adding context information to the clipboard for use in <code>.talon</code> and <code>.py</code> files, tailored for macOS, Windows, and Linux.</li> <li>It has actions to simulate a phrase and dump the result to the log, find an action, and dump the contents of a list to the console.</li> <li>There are debugging actions to output active tags, modes, and scopes, including the ability to copy lists to the clipboard, as well as output settings.</li> <li>It has actions that return active context information, including the application name, executable, bundle, title, and hostname.</li> <li>Finally, there are actions that provide various debugging information for the current application, including versions, window info, and pretty printing.</li> </ul> </li> <li> <p><code>create_app_context.py</code> has actions to create new application context files for the current application.</p> <ul> <li>The <code>talon_create_app_context</code> action will generate a new directory in the <code>community/apps</code> directory with a <code>.talon</code> and <code>.py</code> file for the current application.</li> <li>It creates default context files that include the application name, platform, and other information used to define application contexts in Talon.</li> <li>The <code>talon_create_windows_app_context</code>, <code>talon_create_linux_app_context</code>, and <code>talon_create_mac_app_context</code> actions create context files that include explicit platform information.</li> </ul> </li> </ul> <p>These files work together to provide a suite of useful tools for Talon users to debug and understand their Talon configuration, and quickly generate new application contexts.</p>"},{"location":"plugin/text_navigation/","title":"text_navigation","text":"<p>The <code>community/plugin/text_navigation</code> directory contains files that enable advanced text navigation using Talon. It allows users to move, select, copy, cut, or delete text based on various criteria, including specific characters, phrases, or predefined units like words or parenthesized expressions.</p> <p>The core logic resides in <code>text_navigation.py</code>. It defines the <code>navigation</code> action, which takes a direction, a target (specified by a regex), an action (like \"GO\", \"SELECT\", \"COPY\", etc), and a position relative to the target (before or after). This action is then used to perform the requested text operation. The file also provides helper functions for finding text in different directions, handling different actions and selections, and moving the cursor. There are also a number of lists defined here which are referenced in the talon files.</p> <p>The <code>text_navigation.talon</code> file defines the grammar that allows users to invoke the text navigation commands. The main command <code>navigate</code> takes a variety of options: an arrow key direction (left, right, up, down), a navigation action (move, extend, select, cut, copy, clear), a navigation target name, a before/after specifier, an ordinal number, and a navigation target itself. The file also contains some convenience commands for selecting words, small words, or big words.</p> <p>The <code>before_or_after.talon-list</code> defines the vocabulary for specifying the position of the cursor relative to the target text, such as \"before\" or \"after\". The <code>navigation_action.talon-list</code> defines the vocabulary for the different navigation actions, such as \"move\", \"extend\", \"select\", \"clear\", \"cut\", and \"copy\". These lists are then used in the <code>text_navigation.talon</code> grammar.</p> <p>Together, these files enable complex text navigation with voice commands. For example, a user could say \"navigate left copy third word\" to copy the third word to the left of the cursor, or \"navigate up clear phrase I think\" to delete the next occurrence of \"I think\" on the preceding lines.</p>"},{"location":"plugin/then/","title":"then","text":"<p>The <code>community/plugin/then</code> directory contains a single file, <code>then.talon</code>. This file defines a command called \"then\" that can be used to chain commands that could otherwise be ambiguous. The <code>then</code> command itself does nothing; it exists to act as a delimiter in a phrase.</p> <p>For example, the phrase \"post line air\" could mean \"move the cursor to the end of the line containing the 'a' hat\" or \"move the cursor to the end of the current line, followed by insert the letter 'a'.\" The \"then\" command resolves this ambiguity: \"post line then air\" is interpreted as two separate commands.</p>"},{"location":"tags/","title":"tags","text":"<p>The <code>community/tags</code> directory contains a collection of subdirectories, each representing a different tag in the Talon system. These tags are used to group related commands and functionality. This directory also contains a top-level <code>README.md</code> file which describes each of the subdirectories.</p> <p>Here is a breakdown of the key subdirectories within <code>community/tags</code>:</p> <ul> <li><code>messaging</code>: This tag provides a generic set of commands and actions for controlling multi-channel messaging applications. It includes commands for navigating between workspaces and channels, marking channels as read, searching for messages, and uploading files. The <code>messaging.talon</code> file defines the voice commands, while <code>messaging.py</code> defines the underlying actions.</li> <li><code>file_manager</code>: This tag implements a voice-controlled file manager. The <code>file_manager.talon</code> file defines commands for navigating directories, selecting files, creating folders, opening terminals, and showing file properties. The core logic is implemented in <code>file_manager.py</code>, which handles the file system interactions, the user interface, and the updates of available files and directories.</li> <li><code>browser</code>: This tag provides a common interface for controlling web browsers. The <code>browser.py</code> file defines actions for tab navigation, address bar control, and browsing history manipulation. The <code>browser.talon</code> file binds those actions to voice commands. The <code>browser_mac.py</code> file provides macOS-specific actions that override the default actions on macOS.</li> <li><code>command_search</code>: This tag provides a way to search for and execute other Talon commands by name or description using a phrase like \"please [command]\". The <code>command_search.py</code> file defines the <code>command_search</code> tag and action, while the <code>command_search.talon</code> file defines the speech rules to trigger that action. The action needs to be implemented.</li> <li><code>chapters</code>: This tag is used to navigate chapters in a reader application. The <code>chapters.py</code> file defines actions for jumping between chapters, and the <code>chapters.talon</code> file maps these actions to voice commands.</li> <li><code>pages</code>: This tag is intended to be used for applications or contexts that support page navigation. The <code>pages.py</code> defines the <code>user.pages</code> tag and actions for navigating between pages, and also rotation. The <code>pages.talon</code> binds these actions to voice commands and also enables the <code>user.navigation</code> tag.</li> <li><code>splits</code>: This tag provides functionality for managing window splits, commonly found in tiling window managers and some IDEs. The <code>splits.py</code> file defines actions for manipulating window splits, and <code>splits.talon</code> binds these actions to voice commands.</li> <li><code>find</code>: This tag provides simple find functionality. The <code>find.py</code> file defines the <code>find</code> tag, and the <code>find.talon</code> file defines the voice commands that are associated with it, such as \"hunt this\" and \"hunt next\".</li> <li><code>line_commands</code>: This tag provides a set of generic line navigation and manipulation commands. The <code>line_commands.py</code> file defines actions such as selecting lines, moving lines, indenting, and moving by camel case. The <code>line_commands.talon</code> file maps these actions to voice commands such as \"go 10\", \"comment line 5\", and \"drag line down\".</li> <li><code>emoji</code>: This tag contains functionality for inserting emoji, emoticons, and kaomoji using Talon. The <code>emoji.py</code> file defines the <code>user.emoji</code> tag and the lists that will be populated with emoji. The <code>emoji.talon</code> file binds those lists to voice commands. The <code>emoticon.talon-list</code>, <code>kaomoji.talon-list</code>, and <code>emoji.talon-list</code> files define the content of those lists.</li> <li><code>find_and_replace</code>: This tag provides more advanced find and replace functionality. The <code>find_and_replace.py</code> file defines actions for finding and replacing text. The <code>find_and_replace.talon</code> file defines voice commands that use the actions in <code>find_and_replace.py</code>, and also enables the <code>user.find</code> tag.</li> <li><code>debugger</code>: This tag provides voice control of a debugger. The <code>debugger.talon</code> file defines the voice commands and the <code>debugger.py</code> file defines the actions that are called by the talon file. The python file also defines a list of valid registers.</li> <li><code>multiple_cursors</code>: This tag adds support for multiple cursors to Talon. The <code>multiple_cursors.py</code> defines the actions that are used for multi-cursor selection, and the <code>multiple_cursors.talon</code> file defines the voice commands for those actions.</li> <li><code>terminal</code>: This tag provides support for interacting with terminal applications using Talon. The <code>terminal.py</code> file defines the actions for interacting with the terminal, and <code>unix_shell.py</code> and <code>windows_shell.py</code> implement these actions for Unix-like and Windows environments respectively. The <code>terminal.talon</code> file defines the voice commands for these actions. The <code>readline.py</code> file provides actions for editing text in terminals using readline keybindings. The <code>unix_utilities.py</code>, <code>unix_utilities.talon</code>, and <code>unix_utility.talon-list</code> files provide a tag, a list of common unix utilities, and a voice command for using them.</li> <li><code>address</code>: This tag provides a way to navigate to a location using an address, like a file path or URL. The <code>address.talon</code> file provides voice commands for navigating to an address, copying an address, and focusing the address input field. The <code>address.py</code> file defines the <code>address</code> tag and actions and must be implemented by other files to handle the details of a specific address.</li> </ul> <p>In summary, the <code>community/tags</code> directory is a collection of reusable components that provide common functionality in Talon. Each subdirectory contains a tag, and the associated files implement actions that provide specific functionality related to that tag. The voice commands for these actions are defined in <code>.talon</code> files within each subdirectory.</p>"},{"location":"tags/address/","title":"address","text":"<p>The <code>community/tags/address</code> directory defines a tag and related actions for applications that support navigating to a location using an address, like a file path or URL.</p> <p>The directory contains two files:</p> <ul> <li><code>address.talon</code>: This file defines the Talon commands that use the <code>user.address</code> tag. It provides voice commands for navigating to an address, copying an address, and focusing the address input field. The command <code>go [to] &lt;user.address&gt;</code> executes the <code>user.address_navigate</code> action, passing the captured address as an argument. The commands <code>address copy</code>, <code>copy path</code>, <code>url copy</code>, <code>copy address</code>, and <code>copy url</code> all execute <code>user.address_copy_address</code>. The commands <code>address bar</code>, <code>go address</code>, and <code>go url</code> all execute <code>user.address_focus</code>.</li> <li><code>address.py</code>: This file defines the <code>address</code> tag and actions. It defines the <code>address</code> tag and the actions <code>address_focus</code>, <code>address_copy_address</code>, and <code>address_navigate</code>. The <code>address</code> capture is a placeholder and must be implemented by the context that wishes to support the grammar.</li> </ul> <p>Together these two files provide the core functionality of the <code>address</code> tag and are used by other contexts to navigate to different locations with a voice command.</p>"},{"location":"tags/browser/","title":"browser","text":"<p>The <code>community/tags/browser</code> directory contains files that implement browser-specific functionality for Talon. It provides a common interface for controlling browsers across different platforms.</p> <p>The core functionality is in <code>browser.py</code>, which defines actions for controlling browser tabs and navigation.  It also contains functions for determining the current address, which it does by parsing the window title. Some key actions include:</p> <ul> <li><code>address()</code>: Extracts the URL from the window title. This is used to copy the address, duplicate tabs, and other address-based actions.</li> <li><code>focus_address()</code>: Focuses the browser's address bar.</li> <li><code>go(url)</code>: Navigates to a given URL.</li> <li><code>go_back()</code> / <code>go_forward()</code>: Navigates back or forward in browsing history.</li> <li><code>tab_jump(number)</code> / <code>tab_final()</code>: Jumps to a specific tab.</li> <li><code>focus_page()</code>: Sets focus back to the web page content, removing focus from the address bar or other UI elements.</li> </ul> <p>The file <code>browser.talon</code> defines Talon commands that trigger the actions in <code>browser.py</code>. For example, the command \"go home\" will call the <code>browser.go_home()</code> action, which presses alt-home. It also tags the context with <code>user.address</code>, <code>user.find</code>, and <code>user.navigation</code>, which enables additional commands defined elsewhere (not in this directory).</p> <p>The <code>browser_mac.py</code> file contains actions that are specific to macOS. For example, the address detection is different; it uses the Accessibility API if possible, otherwise it falls back to using AppleScript. It also defines some of the same browser actions as <code>browser.py</code> but using the macOS command key. If <code>browser_mac.py</code> and <code>browser.py</code> define the same actions, then <code>browser_mac.py</code> will override <code>browser.py</code> on macOS.</p>"},{"location":"tags/chapters/","title":"chapters","text":"<p>The <code>community/tags/chapters</code> directory defines a tag and actions for navigating chapters in a reader application.</p> <p>The core logic is defined in <code>chapters.py</code>. It defines a <code>chapters</code> tag which can be used to activate this functionality. It also defines an <code>Actions</code> class that provides actions to jump between chapters.</p> <ul> <li><code>chapter_current()</code>: Returns the current chapter number.</li> <li><code>chapter_next()</code>: Navigates to the next chapter using <code>chapter_jump()</code> and <code>chapter_current()</code>.</li> <li><code>chapter_previous()</code>: Navigates to the previous chapter using <code>chapter_jump()</code> and <code>chapter_current()</code>.</li> <li><code>chapter_jump(number)</code>: Navigates to the specified chapter number.</li> <li><code>chapter_final()</code>: Navigates to the final chapter.</li> </ul> <p>These actions are bound to voice commands in <code>chapters.talon</code>. This file uses the <code>user.chapters</code> tag to activate this functionality.</p> <ul> <li>\"chapter next\": Calls <code>user.chapter_next()</code>.</li> <li>\"chapter last\": Calls <code>user.chapter_previous()</code>.</li> <li>\"go chapter <code>&lt;number&gt;</code>\": Calls <code>user.chapter_jump(number)</code>.</li> <li>\"go chapter final\": Calls <code>user.chapter_final()</code>.</li> </ul> <p>In summary, these files provide a way to navigate chapters in a reader application using voice commands. The <code>chapters.py</code> file defines the actions, while <code>chapters.talon</code> maps those actions to voice commands.</p>"},{"location":"tags/command_search/","title":"command_search","text":"<p>The <code>community/tags/command_search</code> directory contains files for a command that enables searching for and executing other commands by name or description using a phrase like \"please [command]\".</p> <ul> <li> <p><code>command_search.py</code>: This file defines a Talon module and tag named <code>command_search</code>. It includes an action <code>command_search</code> that accepts a text string as input which is intended to search for and run a command. Currently this action is a placeholder, and it needs to be implemented.</p> </li> <li> <p><code>command_search.talon</code>: This file contains the Talon code for the <code>command_search</code> tag. It defines a speech rule such that when the user says \"please [text]\", the <code>user.command_search</code> action is triggered.</p> </li> </ul>"},{"location":"tags/debugger/","title":"debugger","text":"<p>The <code>community/tags/debugger</code> directory contains files that enable voice control of a debugger. It provides a set of commands to control program execution, inspect memory, and manage breakpoints, all through voice commands defined in Talon.</p> <p>The two files in this directory, debugger.talon and debugger.py, work together to provide this functionality.</p> <ul> <li><code>debugger.talon</code> defines the voice commands themselves. It uses the <code>user.debugger</code> tag, which is enabled by the <code>debugger.py</code> file. This file maps spoken phrases to actions, like <code>step into</code> which will execute <code>user.debugger_step_into()</code> or <code>show registers</code> which executes <code>user.debugger_show_registers()</code>. It also includes commands for breakpoints, register manipulation, and memory inspection. The file allows for optional arguments to commands, like <code>&lt;number_small&gt;</code> in <code>clear (break | break point) &lt;number_small&gt;</code> which calls <code>user.debugger_clear_breakpoint_id(number_small)</code>.</li> <li><code>debugger.py</code> defines the actions that are called by the <code>debugger.talon</code> file and the context and the list of registers. It defines an action class which contains empty methods for each command defined in the talon file. This file also defines the register list <code>self.registers</code> which is then used in the talon file to determine valid registers. The <code>registers</code> capture rule is used to pass register names to actions.</li> </ul>"},{"location":"tags/emoji/","title":"emoji","text":"<p>The <code>community/tags/emoji</code> directory contains files for inserting emoji, emoticons, and kaomoji using Talon. It defines a tag, lists, and Talon commands for this purpose.</p> <p>The <code>emoji.py</code> file defines the <code>user.emoji</code> tag, as well as the <code>user.emoticon</code>, <code>user.emoji</code>, and <code>user.kaomoji</code> lists, but does not populate them with data.</p> <p>The <code>emoji.talon</code> file contains the Talon commands for inserting the different kinds of emoji. It uses the <code>user.emoji</code> tag and the three lists defined in <code>emoji.py</code>. For example, saying \"emoticon happy\" will insert <code>:)</code> because the <code>happy</code> key in the <code>user.emoticon</code> list is mapped to that value. Saying \"emoji angry\" will insert <code>\ud83d\ude20</code>. The <code>user.paste()</code> action is used for emoji and kaomoji since they are unicode and can't easily be typed.</p> <p>The <code>emoticon.talon-list</code>, <code>kaomoji.talon-list</code>, and <code>emoji.talon-list</code> files define the contents of the three lists, respectively. Each of these files defines a <code>user</code> list with keys mapped to values, for example the <code>happy</code> key in <code>emoticon.talon-list</code> is mapped to the value <code>:)</code>.</p>"},{"location":"tags/file_manager/","title":"file_manager","text":"<p>The <code>community/tags/file_manager</code> directory contains the core logic for a file manager tag in Talon. It provides a way to navigate, select, and manipulate files and directories using voice commands. This functionality is implemented in the <code>file_manager.talon</code> and <code>file_manager.py</code> files.</p> <ul> <li> <p><code>file_manager.talon</code> defines the voice commands and their corresponding actions. These commands allow the user to:</p> <ul> <li>Navigate directories using commands like \"go parent\", and \"follow\" with a directory name or number.</li> <li>Select directories and files by name or number.</li> <li>Open files and directories using their name or number.</li> <li>Create new folders using \"folder new\" followed by a name.</li> <li>Show properties of files or folders using \"properties show\".</li> <li>Open a terminal in the current location with \"terminal here\".</li> <li>Navigate through pages of directories and files using \"folder next/last\" and \"file next/last\".</li> <li>Refresh the file list using \"manager refresh\".</li> <li>Show or hide file and directory pickers using \"manager show\" and \"manager close\".</li> </ul> <p>The file utilizes the <code>user.file_manager_directories</code> and <code>user.file_manager_files</code> lists to populate the available options for navigation and selection which are defined in <code>file_manager.py</code>.</p> </li> <li> <p><code>file_manager.py</code> contains the core Python implementation of the file manager logic. It defines actions, captures, settings, lists, and the UI that makes the voice commands function.</p> <ul> <li>It defines the <code>user.file_manager</code> tag which is used by the <code>file_manager.talon</code> file to enable its commands. It also defines the lists <code>user.file_manager_directories</code> and <code>user.file_manager_files</code> to hold the current available directories and files, which are populated using the <code>get_directory_map</code> and <code>get_file_map</code> functions.</li> <li>The <code>Actions</code> class defines all of the actions used by the talon file, including the <code>file_manager_open_directory</code>, <code>file_manager_select_file</code>, <code>file_manager_new_folder</code>, etc. These actions are implemented using the <code>Pathlib</code> module to interact with the filesystem.</li> <li>The <code>gui_folders</code> and <code>gui_files</code> functions are used to render an imgui window displaying the current list of directories and files. These windows are shown or hidden by the <code>file_manager_toggle_pickers</code> action. They also provide a way to navigate through pages of directories and files when the limit set by <code>file_manager_imgui_limit</code> has been reached.</li> <li>The <code>update_lists</code> function updates the <code>user.file_manager_directories</code> and <code>user.file_manager_files</code> lists based on the current path. It uses <code>get_directory_map</code> and <code>get_file_map</code> to retrieve a list of directories and files which are used in the <code>gui_files</code> and <code>gui_folders</code> functions for display.</li> <li>The file sets up event handlers that use <code>actions.user.file_manager_current_path()</code> to determine the current path of the file manager and update the available files and directories. When the current path changes, the lists are updated and the imgui windows are refreshed.</li> </ul> </li> </ul> <p>The <code>file_manager.talon</code> file defines the voice interface and delegates the actual logic of interacting with the file system to <code>file_manager.py</code>. Together, these files provide the foundation for a voice-controlled file management system in Talon.</p>"},{"location":"tags/find/","title":"find","text":"<p>The <code>community/tags/find</code> directory defines a tag and associated commands for find functionality within Talon.</p> <p>The file <code>find.py</code> defines the <code>find</code> tag, which can be enabled in other contexts to activate the commands defined by this directory.</p> <p>The file <code>find.talon</code> defines the voice commands associated with the <code>find</code> tag. These include commands such as \"hunt this\" to open a find dialog (with optional pasting of the selection), \"hunt this [text]\" to open a find dialog with the specified text, \"hunt next\" to find the next occurrence, and \"hunt previous\" to find the previous occurrence. These commands mostly wrap around Talon's built-in edit actions such as <code>edit.find()</code>, <code>edit.find_next()</code>, and <code>edit.find_previous()</code>.</p>"},{"location":"tags/find_and_replace/","title":"find_and_replace","text":"<p>The <code>community/tags/find_and_replace</code> directory contains files that provide generic find and replace functionality for Talon.</p> <p>The core logic is defined in the <code>find_and_replace.py</code> file. This file defines a Talon module tag <code>user.find_and_replace</code> which can be used to enable the find and replace commands. It also defines a class <code>Actions</code> which provides several actions that can be used to perform find and replace operations. These actions are:</p> <ul> <li><code>find_everywhere(text: str)</code>: Finds the given text across the project.</li> <li><code>find_toggle_match_by_case()</code>: Toggles case sensitivity for find operations.</li> <li><code>find_toggle_match_by_word()</code>: Toggles whole word matching for find operations.</li> <li><code>find_toggle_match_by_regex()</code>: Toggles regular expression matching for find operations.</li> <li><code>replace(text: str)</code>: Search and replace for text in the active editor.</li> <li><code>replace_everywhere(text: str)</code>: Search and replace for text across the entire project.</li> <li><code>replace_confirm()</code>: Confirms replace at the current cursor position.</li> <li><code>replace_confirm_all()</code>: Confirms replace all.</li> <li><code>select_previous_occurrence(text: str)</code>: Selects the previous occurrence of the text in the editor.</li> <li><code>select_next_occurrence(text: str)</code>: Selects the next occurrence of the text in the editor.</li> </ul> <p>The <code>find_and_replace.talon</code> file provides voice commands that use the actions defined in <code>find_and_replace.py</code>. It enables the commands when the <code>user.find_and_replace</code> tag is active, and also enables the <code>user.find</code> tag.  Some of the key commands include:</p> <ul> <li><code>hunt all</code>: Uses <code>find_everywhere</code> action to find text across project.</li> <li><code>hunt all &lt;user.text&gt;</code>: Finds the specified text across the project.</li> <li><code>hunt case</code>: Toggles case matching.</li> <li><code>hunt word</code>: Toggles whole word matching.</li> <li><code>hunt expression</code>: Toggles regex matching.</li> <li><code>replace this [&lt;user.text&gt;]</code>: Replaces text in the active editor.</li> <li><code>replace all</code>: Replaces text in the entire project</li> <li><code>replace &lt;user.text&gt; all</code>: Replaces the specified text across the entire project</li> <li><code>replace confirm that</code>: Confirms the replace operation.</li> <li><code>replace confirm all</code>: Confirms all replace operations.</li> </ul> <p>There are also several \"quick replace\" commands that mirror functionality in editors like JetBrains products which are built on the select/replace/navigate actions. Some examples of these commands are:</p> <ul> <li><code>clear last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text and deletes it.</li> <li><code>clear next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text and deletes it.</li> <li><code>comment last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text and toggles comments on that line.</li> <li><code>comment next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text and toggles comments on that line.</li> <li><code>go last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text and moves the cursor to the end of it.</li> <li><code>go next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text and moves the cursor to the end of it.</li> <li><code>paste last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text and pastes clipboard at the end of the selection.</li> <li><code>paste next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text and pastes clipboard at the end of the selection.</li> <li><code>replace last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text and pastes the clipboard to replace it.</li> <li><code>replace next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text and pastes the clipboard to replace it.</li> <li><code>select last &lt;user.text&gt; [over]</code>: Selects the previous occurrence of the text.</li> <li><code>select next &lt;user.text&gt; [over]</code>: Selects the next occurrence of the text.</li> <li>The same commands with <code>clip</code> instead of <code>&lt;user.text&gt;</code> uses the current clipboard text for the find.</li> </ul> <p>These files work together by defining the actions in Python and then binding them to voice commands in Talon. The tag system allows the commands to be enabled on a per-context basis as needed.</p>"},{"location":"tags/line_commands/","title":"line_commands","text":"<p>The <code>community/tags/line_commands</code> directory provides a set of generic line navigation and manipulation commands for Talon. It defines a tag, <code>user.line_commands</code>, which enables these commands when active.</p> <p>The core logic is found in <code>line_commands.py</code>, which defines the actions that can be performed.</p> <ul> <li><code>extend_until_line(line: int)</code>: Extends the current selection to the specified line.</li> <li><code>select_range(line_start: int, line_end: int)</code>: Selects a range of lines from <code>line_start</code> to <code>line_end</code>.</li> <li><code>extend_camel_left()</code>: Extends the selection by camel case/subword to the left.</li> <li><code>extend_camel_right()</code>: Extends the selection by camel case/subword to the right.</li> <li><code>camel_left()</code>: Moves the cursor to the left by camel case/subword.</li> <li><code>camel_right()</code>: Moves the cursor to the right by camel case/subword.</li> <li><code>line_clone(line: int)</code>: Clones the specified line at the current cursor position.</li> </ul> <p>These actions are then used in <code>line_commands.talon</code> to create voice commands. Some notable commands include:</p> <ul> <li><code>go &lt;number&gt;</code>: Jumps to the specified line number.</li> <li><code>go &lt;number&gt; end</code>: Jumps to the specified line number and moves the cursor to the end of the line.</li> <li><code>comment [line] &lt;number&gt;</code>: Comments out the specified line.</li> <li><code>comment &lt;number&gt; until &lt;number&gt;</code>: Comments out the lines from the first number until the second.</li> <li><code>clear [line] &lt;number&gt;</code>: Deletes the specified line.</li> <li><code>clear &lt;number&gt; until &lt;number&gt;</code>: Deletes the specified lines.</li> <li><code>copy [line] &lt;number&gt;</code>: Copies the specified line.</li> <li><code>copy &lt;number&gt; until &lt;number&gt;</code>: Copies the specified lines.</li> <li><code>cut [line] &lt;number&gt;</code>: Cuts the specified line.</li> <li><code>cut [line] &lt;number&gt; until &lt;number&gt;</code>: Cuts the specified lines.</li> <li><code>(paste | replace) &lt;number&gt; until &lt;number&gt;</code>: Pastes over the specified lines.</li> <li><code>(select | cell | sell) [line] &lt;number&gt;</code>: Selects the specified line.</li> <li><code>(select | cell | sell) &lt;number&gt; until &lt;number&gt;</code>: Selects the specified lines.</li> <li><code>tab that</code>: Indents the current line.</li> <li><code>tab [line] &lt;number&gt;</code>: Indents the specified line.</li> <li><code>tab &lt;number&gt; until &lt;number&gt;</code>: Indents the specified lines.</li> <li><code>retab that</code>: Unindents the current line.</li> <li><code>retab [line] &lt;number&gt;</code>: Unindents the specified line.</li> <li><code>retab &lt;number&gt; until &lt;number&gt;</code>: Unindents the specified lines.</li> <li><code>drag [line] down</code>: Moves the current line down.</li> <li><code>drag [line] up</code>: Moves the current line up.</li> <li><code>drag up [line] &lt;number&gt;</code>: Moves the specified line up.</li> <li><code>drag up &lt;number&gt; until &lt;number&gt;</code>: Moves the specified lines up.</li> <li><code>drag down [line] &lt;number&gt;</code>: Moves the specified line down.</li> <li><code>drag down &lt;number&gt; until &lt;number&gt;</code>: Moves the specified lines down.</li> <li><code>clone [line] &lt;number&gt;</code>: Clones the specified line.</li> <li><code>select camel left</code>: Extends selection by camel case/subword to the left.</li> <li><code>select camel right</code>: Extends selection by camel case/subword to the right.</li> <li><code>go camel left</code>: Moves cursor by camel case/subword to the left.</li> <li><code>go camel right</code>: Moves cursor by camel case/subword to the right.</li> </ul> <p>The file also includes deprecated commands such as <code>lend</code> and <code>bend</code> which provide aliases to <code>edit.line_end()</code> and <code>edit.line_start()</code> respectively and provides deprecation warnings.</p> <p>In summary, this directory provides a comprehensive set of voice commands for line navigation, selection, and manipulation, using the Talon framework. The python file defines the actions, and the talon file binds these actions to voice commands.</p>"},{"location":"tags/messaging/","title":"messaging","text":"<p>This directory contains files that provide a tag and actions for controlling generic multi-channel messaging applications.</p> <p>The file <code>messaging.talon</code> defines the voice commands that users can use to interact with messaging applications. It uses the <code>user.messaging</code> tag, and it defines commands for navigating between workspaces and channels, marking channels as read, searching for messages, and uploading files. These commands map to actions defined in the <code>messaging.py</code> file.</p> <p>The file <code>messaging.py</code> defines the <code>messaging</code> tag and a set of actions that can be used to control messaging applications. The <code>messaging</code> tag is used by other Talon files, such as <code>messaging.talon</code>, to activate the messaging commands. The actions are generic and need to be implemented by specific application integrations (e.g. Slack, Discord). The actions provided in the file are:</p> <ul> <li><code>messaging_workspace_previous</code> / <code>messaging_workspace_next</code>: Move between servers or workspaces.</li> <li><code>messaging_open_channel_picker</code>: Open a channel picker.</li> <li><code>messaging_channel_previous</code> / <code>messaging_channel_next</code>: Move between channels.</li> <li><code>messaging_unread_previous</code> / <code>messaging_unread_next</code>: Move between unread channels.</li> <li><code>messaging_open_search</code>: Open the search interface.</li> <li><code>messaging_mark_workspace_read</code>: Marks all messages in the current workspace as read.</li> <li><code>messaging_mark_channel_read</code>: Marks all messages in the current channel as read.</li> <li><code>messaging_upload_file</code>: Upload a file as a message.</li> </ul> <p>In summary, the files in this directory provide a generic set of commands and actions that can be used to control different messaging applications. The <code>messaging.talon</code> file defines the voice commands and the <code>messaging.py</code> file defines the actions that the commands map to.</p>"},{"location":"tags/multiple_cursors/","title":"multiple_cursors","text":"<p>This directory contains files that add support for multiple cursors to Talon.</p> <p>The <code>multiple_cursors</code> tag is defined in multiple_cursors.py. This file defines the <code>multiple_cursors</code> tag and the actions it exposes. The actions themselves do not perform any operations, but instead, other files can implement them (e.g. in an editor-specific file). For example, a file for VS Code could define <code>multi_cursor_enable</code> to enable multiple cursors in VS Code. The actions defined are:</p> <ul> <li><code>multi_cursor_enable</code>: Enables multi-cursor mode</li> <li><code>multi_cursor_disable</code>: Disables multi-cursor mode</li> <li><code>multi_cursor_add_above</code>: Adds a cursor to the line above the current cursor</li> <li><code>multi_cursor_add_below</code>: Adds a cursor to the line below the current cursor</li> <li><code>multi_cursor_select_fewer_occurrences</code>: Removes the last cursor and selection</li> <li><code>multi_cursor_select_more_occurrences</code>: Adds a cursor to the next occurrence of the selection</li> <li><code>multi_cursor_skip_occurrence</code>: Skips adding a cursor at the next occurrence of the selection</li> <li><code>multi_cursor_select_all_occurrences</code>: Adds a cursor to every occurrence of the current selection</li> <li><code>multi_cursor_add_to_line_ends</code>: Adds a cursor to the end of every selected line</li> </ul> <p>multiple_cursors.talon binds voice commands to the actions in <code>multiple_cursors.py</code>. This file enables the user to control multiple cursors with their voice. For example, saying \"cursor multiple\" will call the <code>user.multi_cursor_enable()</code> action, while saying \"cursor up\" will call <code>user.multi_cursor_add_above()</code>.</p>"},{"location":"tags/pages/","title":"pages","text":"<p>The <code>community/tags/pages</code> directory defines a <code>user.pages</code> tag, which is intended to be used for applications or contexts that support page navigation.</p> <p>The core logic is defined in <code>pages.py</code>. This file defines the <code>user.pages</code> tag and an action class that includes the following actions:</p> <ul> <li><code>page_current() -&gt; int</code>: Returns the current page number.</li> <li><code>page_next()</code>: Navigates to the next page. It does this by calling <code>actions.user.page_jump</code> with the current page number + 1.</li> <li><code>page_previous()</code>: Navigates to the previous page. It does this by calling <code>actions.user.page_jump</code> with the current page number - 1.</li> <li><code>page_jump(number: int)</code>: Navigates to a specific page number.</li> <li><code>page_final()</code>: Navigates to the final page.</li> <li><code>page_rotate_right()</code>: Rotates the document 90 degrees to the right.</li> <li><code>page_rotate_left()</code>: Rotates the document 90 degrees to the left.</li> </ul> <p>Note that <code>page_current</code> and <code>page_jump</code> are intended to be overridden by other files.</p> <p><code>pages.talon</code> defines voice commands that use the actions defined in <code>pages.py</code>. Notably, it also includes the line <code>tag(): user.navigation</code> which causes the <code>user.navigation</code> tag to be enabled whenever the <code>user.pages</code> tag is enabled. This will often result in other files becoming active. The following commands are defined:</p> <ul> <li><code>page next</code>: Calls <code>user.page_next()</code>.</li> <li><code>page last</code>: Calls <code>user.page_previous()</code>.</li> <li><code>go page &lt;number&gt;</code>: Calls <code>user.page_jump(number)</code>.</li> <li><code>go page final</code>: Calls <code>user.page_final()</code>.</li> <li><code>rotate right</code>: Calls <code>user.page_rotate_right()</code>.</li> <li><code>rotate left</code>: Calls <code>user.page_rotate_left()</code>.</li> </ul> <p>In summary, this directory provides a base set of actions and voice commands for applications that involve page navigation. The <code>user.pages</code> tag activates these commands in the appropriate contexts.</p>"},{"location":"tags/splits/","title":"splits","text":"<p>The <code>community/tags/splits</code> directory contains files for managing window splits. This functionality is commonly used in tiling window managers and some IDEs.</p> <p>The core logic is in <code>splits.py</code>. It defines a Talon module tag called <code>splits</code> which can be used to enable these commands. It also defines a set of actions for manipulating window splits:   * <code>split_window_right</code>: Moves the active window to the right split.   * <code>split_window_left</code>: Moves the active window to the left split.   * <code>split_window_down</code>: Moves the active window to the lower split.   * <code>split_window_up</code>: Moves the active window to the upper split.   * <code>split_window_vertically</code>: Splits the window vertically.   * <code>split_window_horizontally</code>: Splits the window horizontally.   * <code>split_flip</code>: Flips the orientation of the active split.   * <code>split_maximize</code>: Maximizes the active split.   * <code>split_reset</code>: Resets the split sizes.   * <code>split_window</code>: Splits the window.   * <code>split_clear</code>: Clears the current split.   * <code>split_clear_all</code>: Clears all splits.   * <code>split_next</code>: Moves to the next split.   * <code>split_last</code>: Moves to the last split.   * <code>split_number</code>: Moves to the specified split based on an index.</p> <p>The <code>splits.talon</code> file defines the voice commands that trigger the actions in <code>splits.py</code>. For example, saying \"split right\" will call the <code>split_window_right()</code> action. The <code>&lt;number&gt;</code> command is used to navigate to specific splits, e.g., \"go split 1\", \"go split 2\", etc.</p>"},{"location":"tags/terminal/","title":"terminal","text":"<p>This directory, <code>community/tags/terminal</code>, contains files that provide support for interacting with terminal applications using Talon. It includes implementations for both Unix-like and Windows terminals, as well as a more general set of actions and tags to support common workflows.</p> <p>The core functionality is defined in  <code>terminal.py</code>, which specifies the actions that are available for terminal interaction, such as <code>terminal_list_directories</code>, <code>terminal_change_directory</code>, and <code>terminal_kill_all</code>. These actions are then implemented for specific terminal environments.</p> <p>The files <code>unix_shell.py</code> and <code>windows_shell.py</code> implement the terminal actions for Unix-like and Windows environments respectively. They provide the specific commands (e.g., <code>ls</code>, <code>cd</code>, <code>clear</code>) that will be executed when the corresponding actions are invoked. Both files also contain an example of how to add the <code>user.unix_utilities</code> tag to a context.</p> <p>The file <code>terminal.talon</code> provides the voice commands for these terminal actions. For example, saying \"lisa\" will execute <code>terminal_list_directories</code> and \"katie dir foo\" will execute <code>terminal_change_directory(\"foo\")</code>. It also provides some convenience commands such as \"go\" to change directory and \"copy paste\" to copy then paste.</p> <p>The file <code>readline.py</code> provides actions for editing text in terminals using readline keybindings. This provides common commands for moving the cursor, deleting and copying text.</p> <p>The files <code>unix_utilities.py</code> and <code>unix_utilities.talon</code> along with <code>unix_utility.talon-list</code> provide a tag and a list of common unix utilities that can be used in the terminal. The <code>unix_utilities.py</code> defines the <code>user.unix_utilities</code> tag and the <code>user.unix_utility</code> list. The <code>unix_utility.talon-list</code> defines the items in the <code>user.unix_utility</code> list, with commands like <code>awk</code>, <code>base64</code>, and <code>grep</code>. Finally, the <code>unix_utilities.talon</code> provides the voice command that uses the list to insert the selected command.</p> <p>These files work together to provide a comprehensive set of voice commands for interacting with terminal applications, including common navigation, text manipulation, and utility commands.</p>"},{"location":"test/","title":"test","text":"<p>The <code>community/test</code> directory contains tests for the community repository. It includes subdirectories with stub implementations of Talon APIs and several test files.</p> <p>The <code>stubs</code> subdirectory contains stub implementations of Talon APIs used for testing. This allows tests to run without a full Talon installation, providing a more isolated and faster testing environment. It contains the following subdirectories and files:</p> <ul> <li><code>stubs/README.md</code>: This file provides an overview of the purpose of the stubs directory and how it is used in tests. It explains that the stub implementations are mostly no-ops but have some functionality for introspection and changing within tests.</li> <li><code>stubs/talon</code>: This directory contains the primary Talon stubs. It has a subdirectory <code>stubs/talon/experimental</code>, and two files: <code>stubs/talon/__init__.py</code> and <code>stubs/talon/grammar.py</code>.</li> <li><code>stubs/talon/experimental</code>: This subdirectory contains stubs for experimental Talon features. Currently it contains only <code>stubs/talon/experimental/textarea.py</code>, which provides type hints for the <code>TextArea</code> related classes.</li> <li><code>stubs/talon/__init__.py</code>: This file defines classes that mimic key Talon components, such as <code>actions</code>, <code>Module</code>, <code>Context</code>, <code>ImgUI</code>, <code>UI</code>, <code>Settings</code>, <code>Registry</code>, <code>Resource</code>, and <code>App</code>. These stubs provide simplified implementations of their Talon counterparts, allowing tests to interact with them without relying on the actual Talon runtime. The <code>Actions</code> class simulates the <code>talon.actions</code> module, allowing tests to register and call actions. The <code>Module</code> class simulates the <code>talon.Module</code> class, providing stub implementations for <code>list</code>, <code>setting</code>, <code>capture</code>, <code>tag</code> and <code>action_class</code>. The <code>Context</code> class simulates the <code>talon.Context</code> class, offering stub implementations of <code>action_class</code> and <code>capture</code> methods as well as a <code>lists</code> property.</li> <li><code>stubs/talon/grammar.py</code>: This file provides a stub implementation of the <code>Phrase</code> class, used as a type hint in the community code.</li> </ul> <p>The following test files are located in the <code>community/test</code> directory:</p> <ul> <li><code>test_formatters.py</code>: This file tests the text formatting actions provided by <code>core.formatters</code>. It checks various formatting options such as <code>SNAKE_CASE</code>, <code>NO_SPACES</code>, <code>CAPITALIZE</code>, <code>CAPITALIZE_FIRST_WORD</code>, and <code>CAPITALIZE_ALL_WORDS</code> on different input strings.</li> <li><code>test_create_spoken_forms.py</code>: This file tests the functionality of <code>core.create_spoken_forms</code>, which is used to generate different spoken forms of phrases. It tests various aspects of the function, including excluding words, handling empty input, handling minimum term lengths, expanding special characters, expanding abbreviations, handling upper case, handling small words, exploding packed words, and edge cases with random inputs. It also uses a mocked version of <code>core.user_settings.track_csv_list</code> to avoid external file access during tests.</li> <li><code>test_dictation.py</code>: This file tests the <code>core.text.text_and_dictation</code> module, which is responsible for formatting dictation. It includes tests for basic formatting, capitalization and spacing, and forcing capitalization and spacing behavior.</li> <li><code>test_code_modified_function.py</code>: This file tests the <code>talon.actions.user.code_modified_function</code> action defined in <code>lang.tags.functions</code>. It checks that the action calls the correct target function based on the modifiers provided. It uses <code>unittest.mock.MagicMock</code> to verify which action is called.</li> </ul> <p>In summary, the <code>community/test</code> directory contains various tests for Talon functionality in the community repository, along with stubbed Talon implementations to enable isolated and faster testing. The test files cover functionality for text formatting, spoken forms generation, dictation, and code modification actions. The stubs ensure tests are not dependent on a full Talon install.</p>"},{"location":"test/stubs/","title":"stubs","text":"<p>The <code>community/test/stubs</code> directory provides stub implementations of Talon APIs for use in tests. These stubs allow for isolated testing of Talon scripts without needing a full Talon installation. This directory is made available to tests by pytest's pythonpath configuration. The implementation of the stubs are mostly no-ops, but some functionality is implemented to allow for introspection and changing within tests. This is described in the top level <code>README</code>.</p> <p>The directory contains a subdirectory <code>talon</code> which contains the primary Talon stubs. It contains stubs for various Talon modules and classes. These stubs are used in tests to simulate the Talon environment without needing a full Talon installation. </p> <p>The <code>talon</code> directory contains one subdirectory, <code>experimental</code>, and two files: <code>__init__.py</code> and <code>grammar.py</code>.</p> <p>The <code>experimental</code> subdirectory contains stubs for experimental Talon features, and currently only includes <code>textarea.py</code>, which provides type hints for the <code>TextArea</code> related classes.</p> <p>The <code>__init__.py</code> file is the main stub file. It defines classes that mimic key Talon components such as <code>actions</code>, <code>Module</code>, <code>Context</code>, <code>ImgUI</code>, <code>UI</code>, <code>Settings</code>, <code>Registry</code>, <code>Resource</code>, and <code>App</code>. These classes provide simplified implementations of their Talon counterparts, allowing tests to interact with them without relying on the actual Talon runtime. The <code>Actions</code> class simulates the <code>talon.actions</code> module, allowing tests to register and call actions. The <code>Module</code> class simulates the <code>talon.Module</code> class, providing stub implementations for <code>list</code>, <code>setting</code>, <code>capture</code>, <code>tag</code> and <code>action_class</code>. The <code>Context</code> class simulates the <code>talon.Context</code> class, offering stub implementations of <code>action_class</code> and <code>capture</code> methods as well as a <code>lists</code> property. The <code>ImgUI</code>, <code>UI</code>, <code>Settings</code>, <code>Registry</code>, <code>Resource</code>, and <code>App</code> classes provide stubs for their respective Talon counterparts, preventing crashes and enabling basic interactions during testing.</p> <p>The <code>grammar.py</code> file provides stub implementations of the <code>Phrase</code> class, used as a type hint in the community code, and prevents tests from incorrectly identifying actual objects as the stub <code>Phrase</code> type.</p>"},{"location":"test/stubs/talon/","title":"talon","text":"<p>The <code>community/test/stubs/talon</code> directory provides stub implementations of various Talon modules and classes. These stubs are used in tests to simulate the Talon environment without needing a full Talon installation. This allows for isolated testing of Talon scripts.</p> <p>The directory contains one subdirectory, <code>experimental</code>, and two files: <code>__init__.py</code> and <code>grammar.py</code>.</p> <p>The <code>experimental</code> subdirectory contains stubs for experimental Talon features. As of now, it only includes <code>textarea.py</code>, which provides type hints for the <code>TextArea</code> related classes.</p> <p>The <code>__init__.py</code> file is the main stub file. It defines classes that mimic key Talon components such as <code>actions</code>, <code>Module</code>, <code>Context</code>, <code>ImgUI</code>, <code>UI</code>, <code>Settings</code>, <code>Registry</code>, <code>Resource</code>, and <code>App</code>. These classes provide simplified implementations of their Talon counterparts, allowing tests to interact with them without relying on the actual Talon runtime.</p> <p>Here is a breakdown of key components within <code>__init__.py</code>:</p> <ul> <li><code>Actions</code>: This class simulates the <code>talon.actions</code> module. It allows tests to register and call actions. It includes helper functions for module and test action registration, and provides an error if actions are called incorrectly.</li> <li><code>Module</code>: This class simulates the <code>talon.Module</code> class. It provides stub implementations for <code>list</code>, <code>setting</code>, <code>capture</code>, <code>tag</code> and <code>action_class</code>.</li> <li><code>Context</code>: This class simulates the <code>talon.Context</code> class, offering stub implementations of <code>action_class</code> and <code>capture</code> methods as well as a <code>lists</code> property.</li> <li><code>ImgUI</code>, <code>UI</code>, <code>Settings</code>, <code>Registry</code>, <code>Resource</code>, and <code>App</code>: These classes provide stubs for their respective Talon counterparts, preventing crashes and enabling basic interactions during testing.</li> </ul> <p>The <code>grammar.py</code> file provides stub implementations of the <code>Phrase</code> class. This is used as a type hint in the community code, and this file prevents tests from incorrectly identifying actual objects as the stub <code>Phrase</code> type.</p> <p>These stubs work together to create a mock Talon environment, allowing tests to run without a full Talon installation and without modifying the community codebase to suit testing needs. This enables better isolated and faster testing.</p>"},{"location":"test/stubs/talon/experimental/","title":"experimental","text":"<p>The <code>community/test/stubs/talon/experimental</code> directory contains type stubs for Talon's experimental features. These stubs help with static analysis and code completion in IDEs.</p> <p>The single file, <code>textarea.py</code>, provides type hints for classes related to text areas. It defines <code>TextArea</code>, <code>Span</code>, <code>DarkThemeLabels</code>, and <code>LightThemeLabels</code> as <code>None</code>, indicating that the exact type information is not available but that these names exist within the Talon experimental API.</p>"}]}